{
  "version": 3,
  "sources": ["assert.ts", "encoding.ts", "syscall.ts", "object.ts", "util.ts", "file.ts", "package.ts", "path.ts", "template.ts", "symlink.ts", "module.ts", "target.ts", "resolve.ts", "blob.ts", "directory.ts", "artifact.ts", "error.ts", "include.ts", "log.ts", "main.ts", "system.ts", "value.ts", "runtime.ts"],
  "sourcesContent": ["export let assert: (\n\tcondition: unknown,\n\tmessage?: string,\n) => asserts condition = (condition, message) => {\n\tif (!condition) {\n\t\tthrow new Error(message ?? \"Failed assertion.\");\n\t}\n};\n\nexport let unimplemented = (message?: string): never => {\n\tthrow new Error(message ?? \"Reached unimplemented code.\");\n};\n\nexport let unreachable = (message?: string): never => {\n\tthrow new Error(message ?? \"Reached unreachable code.\");\n};\n\nexport let todo = (): never => {\n\tthrow new Error(\"Reached todo.\");\n};\n", "import * as syscall from \"./syscall.ts\";\n\nexport namespace base64 {\n\texport let decode = (value: string): Uint8Array => {\n\t\treturn syscall.encoding.base64.decode(value);\n\t};\n\n\texport let encode = (value: Uint8Array): string => {\n\t\treturn syscall.encoding.base64.encode(value);\n\t};\n}\n\nexport namespace hex {\n\texport let decode = (value: string): Uint8Array => {\n\t\treturn syscall.encoding.hex.decode(value);\n\t};\n\n\texport let encode = (value: Uint8Array): string => {\n\t\treturn syscall.encoding.hex.encode(value);\n\t};\n}\n\nexport namespace json {\n\texport let decode = (value: string): unknown => {\n\t\treturn syscall.encoding.json.decode(value);\n\t};\n\n\texport let encode = (value: any): string => {\n\t\treturn syscall.encoding.json.encode(value);\n\t};\n}\n\nexport namespace toml {\n\texport let decode = (value: string): unknown => {\n\t\treturn syscall.encoding.toml.decode(value);\n\t};\n\n\texport let encode = (value: any): string => {\n\t\treturn syscall.encoding.toml.encode(value);\n\t};\n}\n\nexport namespace utf8 {\n\texport let decode = (value: Uint8Array): string => {\n\t\treturn syscall.encoding.utf8.decode(value);\n\t};\n\n\texport let encode = (value: string): Uint8Array => {\n\t\treturn syscall.encoding.utf8.encode(value);\n\t};\n}\n\nexport namespace yaml {\n\texport let decode = (value: string): unknown => {\n\t\treturn syscall.encoding.yaml.decode(value);\n\t};\n\n\texport let encode = (value: any): string => {\n\t\treturn syscall.encoding.yaml.encode(value);\n\t};\n}\n", "import { Artifact } from \"./artifact.ts\";\nimport { Blob } from \"./blob.ts\";\nimport { Checksum } from \"./checksum.ts\";\nimport { Directory } from \"./directory.ts\";\nimport { Object_ } from \"./object.ts\";\nimport { Target } from \"./target.ts\";\nimport { Value } from \"./value.ts\";\n\ndeclare global {\n\tfunction syscall(syscall: \"build\", target: Target): Promise<Value>;\n\n\tfunction syscall(syscall: \"bundle\", artifact: Artifact): Promise<Directory>;\n\n\tfunction syscall(\n\t\tsyscall: \"checksum\",\n\t\talgorithm: Checksum.Algorithm,\n\t\tbytes: string | Uint8Array,\n\t): Checksum;\n\n\tfunction syscall(\n\t\tsyscall: \"decompress\",\n\t\tblob: Blob,\n\t\tformat: Blob.CompressionFormat,\n\t): Promise<Blob>;\n\n\tfunction syscall(\n\t\tsyscall: \"download\",\n\t\turl: string,\n\t\tchecksum: Checksum,\n\t): Promise<Blob>;\n\n\tfunction syscall(\n\t\tsyscall: \"encoding_base64_decode\",\n\t\tvalue: string,\n\t): Uint8Array;\n\n\tfunction syscall(\n\t\tsyscall: \"encoding_base64_encode\",\n\t\tvalue: Uint8Array,\n\t): string;\n\n\tfunction syscall(syscall: \"encoding_hex_decode\", value: string): Uint8Array;\n\n\tfunction syscall(syscall: \"encoding_hex_encode\", value: Uint8Array): string;\n\n\tfunction syscall(syscall: \"encoding_json_decode\", value: string): unknown;\n\n\tfunction syscall(syscall: \"encoding_json_encode\", value: any): string;\n\n\tfunction syscall(syscall: \"encoding_toml_decode\", value: string): unknown;\n\n\tfunction syscall(syscall: \"encoding_toml_encode\", value: any): string;\n\n\tfunction syscall(syscall: \"encoding_utf8_decode\", value: Uint8Array): string;\n\n\tfunction syscall(syscall: \"encoding_utf8_encode\", value: string): Uint8Array;\n\n\tfunction syscall(syscall: \"encoding_yaml_decode\", value: string): unknown;\n\n\tfunction syscall(syscall: \"encoding_yaml_encode\", value: any): string;\n\n\tfunction syscall(\n\t\tsyscall: \"extract\",\n\t\tblob: Blob,\n\t\tformat: Blob.ArchiveFormat,\n\t): Promise<Artifact>;\n\n\tfunction syscall(syscall: \"load\", id: Object_.Id): Promise<Object_>;\n\n\tfunction syscall(syscall: \"log\", value: string): void;\n\n\tfunction syscall(syscall: \"read\", blob: Blob): Promise<Uint8Array>;\n\n\tfunction syscall(syscall: \"store\", object: Object_): Promise<Object_.Id>;\n}\n\nexport let build = async (target: Target): Promise<Value> => {\n\ttry {\n\t\treturn await syscall(\"build\", target);\n\t} catch (cause) {\n\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t}\n};\n\nexport let bundle = async (artifact: Artifact): Promise<Directory> => {\n\ttry {\n\t\treturn await syscall(\"bundle\", artifact);\n\t} catch (cause) {\n\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t}\n};\n\nexport let checksum = (\n\talgorithm: Checksum.Algorithm,\n\tbytes: string | Uint8Array,\n): Checksum => {\n\ttry {\n\t\treturn syscall(\"checksum\", algorithm, bytes);\n\t} catch (cause) {\n\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t}\n};\n\nexport let decompress = async (\n\tblob: Blob,\n\tformat: Blob.CompressionFormat,\n): Promise<Blob> => {\n\ttry {\n\t\treturn await syscall(\"decompress\", blob, format);\n\t} catch (cause) {\n\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t}\n};\n\nexport let download = async (\n\turl: string,\n\tchecksum: Checksum,\n): Promise<Blob> => {\n\ttry {\n\t\treturn await syscall(\"download\", url, checksum);\n\t} catch (cause) {\n\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t}\n};\n\nexport let encoding = {\n\tbase64: {\n\t\tdecode: (value: string): Uint8Array => {\n\t\t\ttry {\n\t\t\t\treturn syscall(\"encoding_base64_decode\", value);\n\t\t\t} catch (cause) {\n\t\t\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t\t\t}\n\t\t},\n\n\t\tencode: (value: Uint8Array): string => {\n\t\t\ttry {\n\t\t\t\treturn syscall(\"encoding_base64_encode\", value);\n\t\t\t} catch (cause) {\n\t\t\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t\t\t}\n\t\t},\n\t},\n\n\thex: {\n\t\tdecode: (value: string): Uint8Array => {\n\t\t\ttry {\n\t\t\t\treturn syscall(\"encoding_hex_decode\", value);\n\t\t\t} catch (cause) {\n\t\t\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t\t\t}\n\t\t},\n\n\t\tencode: (value: Uint8Array): string => {\n\t\t\ttry {\n\t\t\t\treturn syscall(\"encoding_hex_encode\", value);\n\t\t\t} catch (cause) {\n\t\t\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t\t\t}\n\t\t},\n\t},\n\n\tjson: {\n\t\tdecode: (value: string): unknown => {\n\t\t\ttry {\n\t\t\t\treturn syscall(\"encoding_json_decode\", value);\n\t\t\t} catch (cause) {\n\t\t\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t\t\t}\n\t\t},\n\n\t\tencode: (value: any): string => {\n\t\t\ttry {\n\t\t\t\treturn syscall(\"encoding_json_encode\", value);\n\t\t\t} catch (cause) {\n\t\t\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t\t\t}\n\t\t},\n\t},\n\n\ttoml: {\n\t\tdecode: (value: string): unknown => {\n\t\t\ttry {\n\t\t\t\treturn syscall(\"encoding_toml_decode\", value);\n\t\t\t} catch (cause) {\n\t\t\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t\t\t}\n\t\t},\n\n\t\tencode: (value: any): string => {\n\t\t\ttry {\n\t\t\t\treturn syscall(\"encoding_toml_encode\", value);\n\t\t\t} catch (cause) {\n\t\t\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t\t\t}\n\t\t},\n\t},\n\n\tutf8: {\n\t\tdecode: (value: Uint8Array): string => {\n\t\t\ttry {\n\t\t\t\treturn syscall(\"encoding_utf8_decode\", value);\n\t\t\t} catch (cause) {\n\t\t\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t\t\t}\n\t\t},\n\n\t\tencode: (value: string): Uint8Array => {\n\t\t\ttry {\n\t\t\t\treturn syscall(\"encoding_utf8_encode\", value);\n\t\t\t} catch (cause) {\n\t\t\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t\t\t}\n\t\t},\n\t},\n\n\tyaml: {\n\t\tdecode: (value: string): unknown => {\n\t\t\ttry {\n\t\t\t\treturn syscall(\"encoding_yaml_decode\", value);\n\t\t\t} catch (cause) {\n\t\t\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t\t\t}\n\t\t},\n\n\t\tencode: (value: any): string => {\n\t\t\ttry {\n\t\t\t\treturn syscall(\"encoding_yaml_encode\", value);\n\t\t\t} catch (cause) {\n\t\t\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t\t\t}\n\t\t},\n\t},\n};\n\nexport let extract = async (\n\tblob: Blob,\n\tformat: Blob.ArchiveFormat,\n): Promise<Artifact> => {\n\ttry {\n\t\treturn await syscall(\"extract\", blob, format);\n\t} catch (cause) {\n\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t}\n};\n\nexport let log = (value: string) => {\n\ttry {\n\t\treturn syscall(\"log\", value);\n\t} catch (cause) {\n\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t}\n};\n\nexport let load = async (id: Object_.Id): Promise<Object_> => {\n\ttry {\n\t\treturn await syscall(\"load\", id);\n\t} catch (cause) {\n\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t}\n};\n\nexport let read = async (blob: Blob): Promise<Uint8Array> => {\n\ttry {\n\t\treturn await syscall(\"read\", blob);\n\t} catch (cause) {\n\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t}\n};\n\nexport let store = async (object: Object_): Promise<Object_.Id> => {\n\ttry {\n\t\treturn await syscall(\"store\", object);\n\t} catch (cause) {\n\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t}\n};\n", "import { Blob } from \"./blob.ts\";\nimport { Directory } from \"./directory.ts\";\nimport { File } from \"./file.ts\";\nimport { Package } from \"./package.ts\";\nimport { Symlink } from \"./symlink.ts\";\nimport { Target } from \"./target.ts\";\n\nexport type Object_ =\n\t| { kind: \"blob\"; value: Blob.Object_ }\n\t| { kind: \"directory\"; value: Directory.Object_ }\n\t| { kind: \"file\"; value: File.Object_ }\n\t| { kind: \"symlink\"; value: Symlink.Object_ }\n\t| { kind: \"package\"; value: Package.Object_ }\n\t| { kind: \"target\"; value: Target.Object_ };\n\nexport namespace Object_ {\n\texport type Id = string;\n\n\texport class Handle {\n\t\t#state: State;\n\n\t\tconstructor(state: State) {\n\t\t\tthis.#state = state;\n\t\t}\n\n\t\tget state(): State {\n\t\t\treturn this.#state;\n\t\t}\n\n\t\tstatic withId(id: Id): Handle {\n\t\t\treturn new Handle({ id, object: undefined });\n\t\t}\n\n\t\tstatic withObject(object: Object_): Handle {\n\t\t\treturn new Handle({ id: undefined, object });\n\t\t}\n\n\t\texpectId(): Id {\n\t\t\tif (this.#state.id === undefined) {\n\t\t\t\tthrow new Error();\n\t\t\t}\n\t\t\treturn this.#state.id;\n\t\t}\n\n\t\texpectObject(): Object_ {\n\t\t\tif (this.#state.object === undefined) {\n\t\t\t\tthrow new Error();\n\t\t\t}\n\t\t\treturn this.#state.object;\n\t\t}\n\n\t\tasync id(): Promise<Id> {\n\t\t\tawait this.store();\n\t\t\treturn this.#state.id!;\n\t\t}\n\n\t\tasync object(): Promise<Object_> {\n\t\t\tawait this.load();\n\t\t\treturn this.#state.object!;\n\t\t}\n\n\t\tasync load() {\n\t\t\tif (this.#state.object === undefined) {\n\t\t\t\tthis.#state.object = await syscall(\"load\", this.#state.id!);\n\t\t\t}\n\t\t}\n\n\t\tasync store() {\n\t\t\tif (this.#state.id === undefined) {\n\t\t\t\tthis.#state.id = await syscall(\"store\", this.#state.object!);\n\t\t\t}\n\t\t}\n\t}\n\n\texport type State = {\n\t\tid: Id | undefined;\n\t\tobject: Object_ | undefined;\n\t};\n}\n", "export type MaybeArray<T> = T | Array<T>;\n\nexport type NestedArray<T> = Array<MaybeNestedArray<T>>;\n\nexport type MaybeNestedArray<T> = T | Array<MaybeNestedArray<T>>;\n\nexport let flatten = <T>(value: NestedArray<T>): Array<T> => {\n\t// @ts-ignore\n\treturn value.flat(Infinity);\n};\n", "import { Artifact } from \"./artifact.ts\";\nimport { assert as assert_, unreachable } from \"./assert.ts\";\nimport { Blob, blob } from \"./blob.ts\";\nimport { Object_ } from \"./object.ts\";\nimport { Unresolved, resolve } from \"./resolve.ts\";\nimport { MaybeNestedArray, flatten } from \"./util.ts\";\n\nexport let file = async (...args: Array<Unresolved<File.Arg>>) => {\n\treturn await File.new(...args);\n};\n\nexport class File {\n\t#handle: Object_.Handle;\n\n\tconstructor(handle: Object_.Handle) {\n\t\tthis.#handle = handle;\n\t}\n\n\tstatic withId(id: File.Id): File {\n\t\treturn new File(Object_.Handle.withId(id));\n\t}\n\n\tstatic async new(...args: Array<Unresolved<File.Arg>>): Promise<File> {\n\t\tlet {\n\t\t\tcontents: contentsArgs,\n\t\t\texecutable,\n\t\t\treferences,\n\t\t} = flatten(\n\t\t\tawait Promise.all(\n\t\t\t\targs.map(async function map(\n\t\t\t\t\tunresolvedArg: Unresolved<File.Arg>,\n\t\t\t\t): Promise<\n\t\t\t\t\tMaybeNestedArray<{\n\t\t\t\t\t\tcontents: Blob.Arg;\n\t\t\t\t\t\texecutable?: boolean;\n\t\t\t\t\t\treferences?: Array<Artifact>;\n\t\t\t\t\t}>\n\t\t\t\t> {\n\t\t\t\t\tlet arg = await resolve(unresolvedArg);\n\t\t\t\t\tif (Blob.Arg.is(arg)) {\n\t\t\t\t\t\treturn { contents: arg };\n\t\t\t\t\t} else if (File.is(arg)) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tcontents: await arg.contents(),\n\t\t\t\t\t\t\texecutable: await arg.executable(),\n\t\t\t\t\t\t\treferences: await arg.references(),\n\t\t\t\t\t\t};\n\t\t\t\t\t} else if (arg instanceof Array) {\n\t\t\t\t\t\treturn await Promise.all(arg.map(map));\n\t\t\t\t\t} else if (typeof arg === \"object\") {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tcontents: arg.contents,\n\t\t\t\t\t\t\texecutable: arg.executable,\n\t\t\t\t\t\t\treferences: arg.references,\n\t\t\t\t\t\t};\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn unreachable();\n\t\t\t\t\t}\n\t\t\t\t}),\n\t\t\t),\n\t\t).reduce<{\n\t\t\tcontents: Array<Blob.Arg>;\n\t\t\texecutable: boolean;\n\t\t\treferences: Array<Artifact>;\n\t\t}>(\n\t\t\t(value, { contents, executable, references }) => {\n\t\t\t\tvalue.contents.push(contents);\n\t\t\t\tvalue.executable =\n\t\t\t\t\texecutable !== undefined ? executable : value.executable;\n\t\t\t\tvalue.references.push(...(references ?? []));\n\t\t\t\treturn value;\n\t\t\t},\n\t\t\t{ contents: [], executable: false, references: [] },\n\t\t);\n\t\tlet contents = await blob(...contentsArgs);\n\t\treturn new File(\n\t\t\tObject_.Handle.withObject({\n\t\t\t\tkind: \"file\",\n\t\t\t\tvalue: { contents, executable, references },\n\t\t\t}),\n\t\t);\n\t}\n\n\tstatic is(value: unknown): value is File {\n\t\treturn value instanceof File;\n\t}\n\n\tstatic expect(value: unknown): File {\n\t\tassert_(File.is(value));\n\t\treturn value;\n\t}\n\n\tstatic assert(value: unknown): asserts value is File {\n\t\tassert_(File.is(value));\n\t}\n\n\tasync id(): Promise<File.Id> {\n\t\treturn (await this.#handle.id()) as File.Id;\n\t}\n\n\tasync object(): Promise<File.Object_> {\n\t\tlet object = await this.#handle.object();\n\t\tassert_(object.kind === \"file\");\n\t\treturn object.value;\n\t}\n\n\tget handle(): Object_.Handle {\n\t\treturn this.#handle;\n\t}\n\n\tasync contents(): Promise<Blob> {\n\t\treturn (await this.object()).contents;\n\t}\n\n\tasync executable(): Promise<boolean> {\n\t\treturn (await this.object()).executable;\n\t}\n\n\tasync references(): Promise<Array<Artifact>> {\n\t\treturn (await this.object()).references;\n\t}\n\n\tasync size(): Promise<number> {\n\t\treturn (await this.contents()).size();\n\t}\n\n\tasync bytes(): Promise<Uint8Array> {\n\t\treturn (await this.contents()).bytes();\n\t}\n\n\tasync text(): Promise<string> {\n\t\treturn (await this.contents()).text();\n\t}\n}\n\nexport namespace File {\n\texport type Arg = Blob.Arg | File | Array<Arg> | ArgObject;\n\n\texport type ArgObject = {\n\t\tcontents: Blob.Arg;\n\t\texecutable?: boolean;\n\t\treferences?: Array<Artifact>;\n\t};\n\n\texport type Id = string;\n\n\texport type Object_ = {\n\t\tcontents: Blob;\n\t\texecutable: boolean;\n\t\treferences: Array<Artifact>;\n\t};\n}\n", "import { Artifact } from \"./artifact.ts\";\nimport { assert as assert_ } from \"./assert.ts\";\nimport { Object_ } from \"./object.ts\";\n\nexport class Package {\n\t#handle: Object_.Handle;\n\n\tconstructor(handle: Object_.Handle) {\n\t\tthis.#handle = handle;\n\t}\n\n\tstatic withId(id: Package.Id): Package {\n\t\treturn new Package(Object_.Handle.withId(id));\n\t}\n\n\tstatic is(value: unknown): value is Package {\n\t\treturn value instanceof Package;\n\t}\n\n\tstatic expect(value: unknown): Package {\n\t\tassert_(Package.is(value));\n\t\treturn value;\n\t}\n\n\tstatic assert(value: unknown): asserts value is Package {\n\t\tassert_(Package.is(value));\n\t}\n\n\tasync id(): Promise<Package.Id> {\n\t\treturn (await this.#handle.id()) as Package.Id;\n\t}\n\n\tasync object(): Promise<Package.Object_> {\n\t\tlet object = await this.#handle.object();\n\t\tassert_(object.kind === \"package\");\n\t\treturn object.value;\n\t}\n\n\tget handle(): Object_.Handle {\n\t\treturn this.#handle;\n\t}\n\n\tasync artifact(): Promise<Artifact> {\n\t\treturn (await this.object()).artifact;\n\t}\n\n\tasync dependencies(): Promise<{ [dependency: string]: Package }> {\n\t\treturn (await this.object()).dependencies;\n\t}\n}\n\nexport namespace Package {\n\texport type Arg = Package | Array<Arg> | ArgObject;\n\n\texport type ArgObject = {\n\t\tartifact: Artifact;\n\t\tdependencies?: { [dependency: string]: Package.Arg };\n\t};\n\n\texport type Id = string;\n\n\texport type Object_ = {\n\t\tartifact: Artifact;\n\t\tdependencies: { [dependency: string]: Package };\n\t};\n}\n", "import { assert as assert_, unreachable } from \"./assert.ts\";\n\nexport let relpath = (...args: Array<Relpath.Arg>): Relpath => {\n\treturn Relpath.new(...args);\n};\n\nexport let subpath = (...args: Array<Subpath.Arg>): Subpath => {\n\treturn Subpath.new(...args);\n};\n\ntype RelpathConstructorArg = {\n\tparents?: number;\n\tsubpath?: Subpath;\n};\n\nexport class Relpath {\n\t#parents: number;\n\t#subpath: Subpath;\n\n\tconstructor(arg?: RelpathConstructorArg) {\n\t\tthis.#parents = arg?.parents ?? 0;\n\t\tthis.#subpath = arg?.subpath ?? new Subpath();\n\t}\n\n\tstatic new(...args: Array<Relpath.Arg>): Relpath {\n\t\treturn args.reduce(function reduce(path: Relpath, arg: Relpath.Arg) {\n\t\t\tif (typeof arg === \"string\") {\n\t\t\t\tfor (let component of arg.split(\"/\")) {\n\t\t\t\t\tif (component === \"\" || component === \".\") {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else if (component === \"..\") {\n\t\t\t\t\t\tpath = path.parent();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpath.#subpath.push(component);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (arg instanceof Relpath) {\n\t\t\t\tfor (let i = 0; i < arg.#parents; i++) {\n\t\t\t\t\tpath.parent();\n\t\t\t\t}\n\t\t\t\tpath.#subpath.join(arg.#subpath);\n\t\t\t} else if (arg instanceof Subpath) {\n\t\t\t\tpath.#subpath.join(arg);\n\t\t\t} else if (arg instanceof Array) {\n\t\t\t\targ.forEach((arg) => reduce(path, arg));\n\t\t\t} else {\n\t\t\t\treturn unreachable();\n\t\t\t}\n\t\t\treturn path;\n\t\t}, new Relpath());\n\t}\n\n\tisEmpty(): boolean {\n\t\treturn this.#parents == 0 && this.#subpath.isEmpty();\n\t}\n\n\tparents(): number {\n\t\treturn this.#parents;\n\t}\n\n\tsubpath(): Subpath {\n\t\treturn this.#subpath;\n\t}\n\n\tparent(): Relpath {\n\t\tif (this.#subpath.isEmpty()) {\n\t\t\tthis.#parents += 1;\n\t\t} else {\n\t\t\tthis.#subpath.pop();\n\t\t}\n\t\treturn this;\n\t}\n\n\tjoin(other: Relpath.Arg): Relpath {\n\t\tother = Relpath.new(other);\n\t\tfor (let i = 0; i < other.#parents; i++) {\n\t\t\tthis.parent();\n\t\t}\n\t\tthis.#subpath.join(other.#subpath);\n\t\treturn this;\n\t}\n\n\textension(): string | undefined {\n\t\treturn this.#subpath.extension();\n\t}\n\n\ttoSubpath(): Subpath {\n\t\tif (this.#parents > 0) {\n\t\t\tthrow new Error(\"Cannot convert to subpath.\");\n\t\t}\n\t\treturn this.#subpath;\n\t}\n\n\ttoString(): string {\n\t\tlet string = \"\";\n\t\tfor (let i = 0; i < this.#parents; i++) {\n\t\t\tstring += \"../\";\n\t\t}\n\t\tstring += this.#subpath.toString();\n\t\treturn string;\n\t}\n}\n\nexport namespace Relpath {\n\texport type Arg = Subpath.Arg | Relpath | Array<Arg>;\n\n\texport namespace Arg {\n\t\texport let is = (value: unknown): value is Relpath.Arg => {\n\t\t\treturn (\n\t\t\t\tSubpath.Arg.is(value) ||\n\t\t\t\tvalue instanceof Relpath ||\n\t\t\t\t(value instanceof Array && value.every(Relpath.Arg.is))\n\t\t\t);\n\t\t};\n\n\t\texport let expect = (value: unknown): Relpath.Arg => {\n\t\t\tassert_(is(value));\n\t\t\treturn value;\n\t\t};\n\n\t\texport let assert = (value: unknown): asserts value is Relpath.Arg => {\n\t\t\tassert_(is(value));\n\t\t};\n\t}\n}\n\nexport class Subpath {\n\t#components: Array<string>;\n\n\tconstructor(components?: Array<string>) {\n\t\tthis.#components = components ?? [];\n\t}\n\n\tstatic new(...args: Array<Subpath.Arg>): Subpath {\n\t\treturn Relpath.new(...args).toSubpath();\n\t}\n\n\tcomponents(): Array<string> {\n\t\treturn [...this.#components];\n\t}\n\n\tisEmpty(): boolean {\n\t\treturn this.#components.length == 0;\n\t}\n\n\tjoin(other: Subpath): Subpath {\n\t\tthis.#components.push(...other.#components);\n\t\treturn this;\n\t}\n\n\tpush(component: string) {\n\t\tthis.#components.push(component);\n\t}\n\n\tpop() {\n\t\tthis.#components.pop();\n\t}\n\n\textension(): string | undefined {\n\t\treturn this.#components.at(-1)?.split(\".\").at(-1);\n\t}\n\n\ttoRelpath(): Relpath {\n\t\treturn Relpath.new(this);\n\t}\n\n\ttoString(): string {\n\t\treturn this.#components.join(\"/\");\n\t}\n}\n\nexport namespace Subpath {\n\texport type Arg = undefined | string | Subpath | Array<Arg>;\n\n\texport namespace Arg {\n\t\texport let is = (value: unknown): value is Subpath.Arg => {\n\t\t\treturn (\n\t\t\t\tvalue === undefined ||\n\t\t\t\ttypeof value === \"string\" ||\n\t\t\t\tvalue instanceof Subpath ||\n\t\t\t\t(value instanceof Array && value.every(Subpath.Arg.is))\n\t\t\t);\n\t\t};\n\n\t\texport let expect = (value: unknown): Subpath.Arg => {\n\t\t\tassert_(is(value));\n\t\t\treturn value;\n\t\t};\n\n\t\texport let assert = (value: unknown): asserts value is Subpath.Arg => {\n\t\t\tassert_(is(value));\n\t\t};\n\t}\n}\n", "import { Artifact } from \"./artifact.ts\";\nimport { assert as assert_, unreachable } from \"./assert.ts\";\nimport { Unresolved, resolve } from \"./resolve.ts\";\nimport { MaybeNestedArray, flatten } from \"./util.ts\";\n\nexport let t = async (\n\tstrings: TemplateStringsArray,\n\t...placeholders: Array<Unresolved<Template.Arg>>\n): Promise<Template> => {\n\t// Collect the strings and placeholders.\n\tlet components: Array<Unresolved<Template.Arg>> = [];\n\tfor (let i = 0; i < strings.length - 1; i++) {\n\t\tlet string = strings[i]!;\n\t\tcomponents.push(string);\n\t\tlet placeholder = placeholders[i]!;\n\t\tcomponents.push(placeholder);\n\t}\n\tcomponents.push(strings[strings.length - 1]!);\n\treturn await template(...components);\n};\n\nexport let template = (\n\t...args: Array<Unresolved<Template.Arg>>\n): Promise<Template> => {\n\treturn Template.new(...args);\n};\n\nexport class Template {\n\t#components: Array<Template.Component>;\n\n\tconstructor(components: Array<Template.Component>) {\n\t\tthis.#components = components;\n\t}\n\n\tstatic async new(\n\t\t...args: Array<Unresolved<Template.Arg>>\n\t): Promise<Template> {\n\t\t// Collect the components.\n\t\tlet components = flatten(\n\t\t\tawait Promise.all(\n\t\t\t\targs.map(async function map(arg): Promise<\n\t\t\t\t\tMaybeNestedArray<Template.Component>\n\t\t\t\t> {\n\t\t\t\t\targ = await resolve(arg);\n\t\t\t\t\tif (arg === undefined) {\n\t\t\t\t\t\treturn [];\n\t\t\t\t\t} else if (Template.Component.is(arg)) {\n\t\t\t\t\t\treturn arg;\n\t\t\t\t\t} else if (Template.is(arg)) {\n\t\t\t\t\t\treturn arg.components;\n\t\t\t\t\t} else if (arg instanceof Array) {\n\t\t\t\t\t\treturn await Promise.all(arg.map(map));\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn unreachable();\n\t\t\t\t\t}\n\t\t\t\t}),\n\t\t\t),\n\t\t).reduce<Array<Template.Component>>((components, component) => {\n\t\t\tcomponents.push(component);\n\t\t\treturn components;\n\t\t}, []);\n\n\t\t// Normalize the components.\n\t\tcomponents = components.reduce<Array<Template.Component>>(\n\t\t\t(components, component) => {\n\t\t\t\tlet lastComponent = components.at(-1);\n\t\t\t\tif (component === \"\") {\n\t\t\t\t\t// Ignore empty string components.\n\t\t\t\t} else if (\n\t\t\t\t\ttypeof lastComponent === \"string\" &&\n\t\t\t\t\ttypeof component === \"string\"\n\t\t\t\t) {\n\t\t\t\t\t// Merge adjacent string components.\n\t\t\t\t\tcomponents.splice(-1, 1, lastComponent + component);\n\t\t\t\t} else {\n\t\t\t\t\tcomponents.push(component);\n\t\t\t\t}\n\t\t\t\treturn components;\n\t\t\t},\n\t\t\t[],\n\t\t);\n\n\t\treturn new Template(components);\n\t}\n\n\tstatic is(value: unknown): value is Template {\n\t\treturn value instanceof Template;\n\t}\n\n\tstatic expect(value: unknown): Template {\n\t\tassert_(Template.is(value));\n\t\treturn value;\n\t}\n\n\tstatic assert(value: unknown): asserts value is Template {\n\t\tassert_(Template.is(value));\n\t}\n\n\t/** Join an array of templates with a separator. */\n\tstatic async join(\n\t\tseparator: Unresolved<Template.Arg>,\n\t\t...args: Array<Unresolved<Template.Arg>>\n\t): Promise<Template> {\n\t\tlet separatorTemplate = await template(separator);\n\t\tlet argTemplates = await Promise.all(args.map((arg) => template(arg)));\n\t\targTemplates = argTemplates.filter((arg) => arg.components.length > 0);\n\t\tlet templates = [];\n\t\tfor (let i = 0; i < argTemplates.length; i++) {\n\t\t\tif (i > 0) {\n\t\t\t\ttemplates.push(separatorTemplate);\n\t\t\t}\n\t\t\tlet argTemplate = argTemplates[i];\n\t\t\tassert_(argTemplate);\n\t\t\ttemplates.push(argTemplate);\n\t\t}\n\t\treturn template(...templates);\n\t}\n\n\tget components(): Array<Template.Component> {\n\t\treturn this.#components;\n\t}\n}\n\nexport namespace Template {\n\texport type Arg = undefined | Component | Template | Array<Arg>;\n\n\texport namespace Arg {\n\t\texport let is = (value: unknown): value is Arg => {\n\t\t\treturn (\n\t\t\t\tvalue === undefined ||\n\t\t\t\tComponent.is(value) ||\n\t\t\t\tTemplate.is(value) ||\n\t\t\t\t(value instanceof Array && value.every((value) => Arg.is(value)))\n\t\t\t);\n\t\t};\n\t}\n\n\texport type Component = string | Artifact;\n\n\texport namespace Component {\n\t\texport let is = (value: unknown): value is Component => {\n\t\t\treturn typeof value === \"string\" || Artifact.is(value);\n\t\t};\n\t}\n}\n", "import { Artifact } from \"./artifact.ts\";\nimport { assert as assert_, unreachable } from \"./assert.ts\";\nimport { Directory } from \"./directory.ts\";\nimport { File } from \"./file.ts\";\nimport { Object_ } from \"./object.ts\";\nimport { Relpath, relpath } from \"./path.ts\";\nimport { Unresolved, resolve } from \"./resolve.ts\";\nimport { Template, t } from \"./template.ts\";\nimport { MaybeNestedArray, flatten } from \"./util.ts\";\n\nexport let symlink = async (\n\t...args: Array<Unresolved<Symlink.Arg>>\n): Promise<Symlink> => {\n\treturn await Symlink.new(...args);\n};\n\nexport class Symlink {\n\t#handle: Object_.Handle;\n\n\tconstructor(handle: Object_.Handle) {\n\t\tthis.#handle = handle;\n\t}\n\n\tstatic withId(id: Symlink.Id): Symlink {\n\t\treturn new Symlink(Object_.Handle.withId(id));\n\t}\n\n\tstatic async new(...args: Array<Unresolved<Symlink.Arg>>): Promise<Symlink> {\n\t\t// Get the artifact and path.\n\t\tlet { artifact, path } = flatten(\n\t\t\tawait Promise.all(\n\t\t\t\targs.map(async function map(unresolvedArg): Promise<\n\t\t\t\t\tMaybeNestedArray<{ artifact?: Artifact; path?: Relpath }>\n\t\t\t\t> {\n\t\t\t\t\tlet arg = await resolve(unresolvedArg);\n\t\t\t\t\tif (typeof arg === \"string\") {\n\t\t\t\t\t\treturn { path: relpath(arg) };\n\t\t\t\t\t} else if (Artifact.is(arg)) {\n\t\t\t\t\t\treturn { artifact: arg };\n\t\t\t\t\t} else if (Template.is(arg)) {\n\t\t\t\t\t\tassert_(arg.components.length <= 2);\n\t\t\t\t\t\tlet [firstComponent, secondComponent] = arg.components;\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\ttypeof firstComponent === \"string\" &&\n\t\t\t\t\t\t\tsecondComponent === undefined\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\treturn { path: relpath(firstComponent) };\n\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\tArtifact.is(firstComponent) &&\n\t\t\t\t\t\t\tsecondComponent === undefined\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\treturn { artifact: firstComponent };\n\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\tArtifact.is(firstComponent) &&\n\t\t\t\t\t\t\ttypeof secondComponent === \"string\"\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tassert_(secondComponent.startsWith(\"/\"));\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tartifact: firstComponent,\n\t\t\t\t\t\t\t\tpath: relpath(secondComponent.slice(1)),\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthrow new Error(\"Invalid template.\");\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (Symlink.is(arg)) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tartifact: await arg.artifact(),\n\t\t\t\t\t\t\tpath: await arg.path(),\n\t\t\t\t\t\t};\n\t\t\t\t\t} else if (arg instanceof Array) {\n\t\t\t\t\t\treturn await Promise.all(arg.map(map));\n\t\t\t\t\t} else if (typeof arg === \"object\") {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tartifact: arg.artifact,\n\t\t\t\t\t\t\tpath: relpath(arg.path),\n\t\t\t\t\t\t};\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn unreachable();\n\t\t\t\t\t}\n\t\t\t\t}),\n\t\t\t),\n\t\t).reduce<{ artifact: Artifact | undefined; path: Relpath }>(\n\t\t\t(value, { artifact, path }) => {\n\t\t\t\tif (artifact !== undefined) {\n\t\t\t\t\tvalue.artifact = artifact;\n\t\t\t\t\tvalue.path = path ?? relpath();\n\t\t\t\t} else {\n\t\t\t\t\tvalue.path = value.path.join(path);\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t},\n\t\t\t{ artifact: undefined, path: relpath() },\n\t\t);\n\n\t\t// Create the target.\n\t\tlet target;\n\t\tif (artifact !== undefined && !path.isEmpty()) {\n\t\t\ttarget = await t`${artifact}/${path.toString()}`;\n\t\t} else if (artifact !== undefined) {\n\t\t\ttarget = await t`${artifact}`;\n\t\t} else if (!path.isEmpty()) {\n\t\t\ttarget = await t`${path.toString()}`;\n\t\t} else {\n\t\t\tthrow new Error(\"Invalid symlink.\");\n\t\t}\n\n\t\treturn new Symlink(\n\t\t\tObject_.Handle.withObject({ kind: \"symlink\", value: { target } }),\n\t\t);\n\t}\n\n\tstatic is(value: unknown): value is Symlink {\n\t\treturn value instanceof Symlink;\n\t}\n\n\tstatic expect(value: unknown): Symlink {\n\t\tassert_(Symlink.is(value));\n\t\treturn value;\n\t}\n\n\tstatic assert(value: unknown): asserts value is Symlink {\n\t\tassert_(Symlink.is(value));\n\t}\n\n\tasync id(): Promise<Symlink.Id> {\n\t\treturn (await this.#handle.id()) as Symlink.Id;\n\t}\n\n\tasync object(): Promise<Symlink.Object_> {\n\t\tlet object = await this.#handle.object();\n\t\tassert_(object.kind === \"symlink\");\n\t\treturn object.value;\n\t}\n\n\tget handle(): Object_.Handle {\n\t\treturn this.#handle;\n\t}\n\n\tasync target(): Promise<Template> {\n\t\treturn (await this.object()).target;\n\t}\n\n\tasync artifact(): Promise<Artifact | undefined> {\n\t\tlet target = await this.target();\n\t\tlet firstComponent = target.components.at(0);\n\t\tif (Artifact.is(firstComponent)) {\n\t\t\treturn firstComponent;\n\t\t} else {\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\tasync path(): Promise<Relpath> {\n\t\tlet target = await this.target();\n\t\tlet [firstComponent, secondComponent] = target.components;\n\t\tif (typeof firstComponent === \"string\" && secondComponent === undefined) {\n\t\t\treturn relpath(firstComponent);\n\t\t} else if (Artifact.is(firstComponent) && secondComponent === undefined) {\n\t\t\treturn relpath();\n\t\t} else if (\n\t\t\tArtifact.is(firstComponent) &&\n\t\t\ttypeof secondComponent === \"string\"\n\t\t) {\n\t\t\treturn relpath(secondComponent.slice(1));\n\t\t} else {\n\t\t\tthrow new Error(\"Invalid template.\");\n\t\t}\n\t}\n\n\tasync resolve(\n\t\tfrom?: Unresolved<Symlink.Arg>,\n\t): Promise<Directory | File | undefined> {\n\t\tfrom = from ? await symlink(from) : undefined;\n\t\tlet fromArtifact = await from?.artifact();\n\t\tif (Symlink.is(fromArtifact)) {\n\t\t\tfromArtifact = await fromArtifact.resolve();\n\t\t}\n\t\tlet fromPath = from?.path();\n\t\tlet artifact = await this.artifact();\n\t\tif (Symlink.is(artifact)) {\n\t\t\tartifact = await artifact.resolve();\n\t\t}\n\t\tlet path = await this.path();\n\t\tif (artifact !== undefined && path.isEmpty()) {\n\t\t\treturn artifact;\n\t\t} else if (artifact === undefined && !path.isEmpty()) {\n\t\t\tif (!Directory.is(fromArtifact)) {\n\t\t\t\tthrow new Error(\"Expected a directory.\");\n\t\t\t}\n\t\t\treturn await fromArtifact.tryGet(\n\t\t\t\t(await (fromPath ?? relpath()))\n\t\t\t\t\t.parent()\n\t\t\t\t\t.join(path)\n\t\t\t\t\t.toSubpath()\n\t\t\t\t\t.toString(),\n\t\t\t);\n\t\t} else if (artifact !== undefined && !path.isEmpty()) {\n\t\t\tif (!Directory.is(artifact)) {\n\t\t\t\tthrow new Error(\"Expected a directory.\");\n\t\t\t}\n\t\t\treturn await artifact.tryGet(path.toSubpath().toString());\n\t\t} else {\n\t\t\tthrow new Error(\"Invalid symlink.\");\n\t\t}\n\t}\n}\n\nexport namespace Symlink {\n\texport type Arg =\n\t\t| string\n\t\t| Artifact\n\t\t| Template\n\t\t| Symlink\n\t\t| Array<Arg>\n\t\t| ArgObject;\n\n\texport type ArgObject = {\n\t\tartifact?: Artifact;\n\t\tpath?: string;\n\t};\n\n\texport type Id = string;\n\n\texport type Object_ = { target: Template };\n}\n", "import { assert } from \"./assert.ts\";\nimport { encoding } from \"./syscall.ts\";\n\nexport type Module =\n\t| { kind: \"document\"; value: Document }\n\t| { kind: \"library\"; value: Library }\n\t| { kind: \"normal\"; value: Normal };\n\nexport type Document = {\n\tpackagePath: string;\n\tpath: string;\n};\n\nexport type Library = {\n\tpath: string;\n};\n\nexport type Normal = {\n\tpackageId: string;\n\tpath: string;\n};\n\nexport namespace Module {\n\texport let toUrl = (module: Module): string => {\n\t\tlet data = encoding.hex.encode(\n\t\t\tencoding.utf8.encode(encoding.json.encode(module)),\n\t\t);\n\t\treturn `tangram://${data}/${module.value.path}`;\n\t};\n\n\texport let fromUrl = (url: string): Module => {\n\t\tlet match = url.match(/^tangram:\\/\\/(.*)\\/(.*)$/);\n\t\tassert(match);\n\t\tlet [_, data, _path] = match;\n\t\tassert(data !== undefined);\n\t\treturn encoding.json.decode(\n\t\t\tencoding.utf8.decode(encoding.hex.decode(data)),\n\t\t) as Module;\n\t};\n}\n", "import { assert as assert_, unreachable } from \"./assert.ts\";\nimport { Checksum } from \"./checksum.ts\";\nimport * as encoding from \"./encoding.ts\";\nimport { Module } from \"./module.ts\";\nimport { Object_ } from \"./object.ts\";\nimport { Package } from \"./package.ts\";\nimport { MaybePromise, Unresolved, resolve } from \"./resolve.ts\";\nimport * as syscall from \"./syscall.ts\";\nimport { System } from \"./system.ts\";\nimport { Template, template } from \"./template.ts\";\nimport { MaybeNestedArray, flatten } from \"./util.ts\";\nimport { Value } from \"./value.ts\";\n\nexport let current: Target;\n\nexport let setCurrent = (target: Target) => {\n\tcurrent = target;\n};\n\nexport let functions: Record<string, Function> = {};\n\ntype FunctionArg<\n\tA extends Array<Value> = Array<Value>,\n\tR extends Value = Value,\n> = {\n\turl: string;\n\tname: string;\n\tfunction: (...args: A) => MaybePromise<R | void>;\n};\n\nexport function target<\n\tA extends Array<Value> = Array<Value>,\n\tR extends Value = Value,\n>(args: FunctionArg): Target<A, R>;\nexport function target<\n\tA extends Array<Value> = Array<Value>,\n\tR extends Value = Value,\n>(...args: Array<Unresolved<Target.Arg>>): Promise<Target<A, R>>;\nexport function target<\n\tA extends Array<Value> = Array<Value>,\n\tR extends Value = Value,\n>(\n\t...args: [FunctionArg<A, R>] | Array<Unresolved<Target.Arg>>\n): MaybePromise<Target<A, R>> {\n\tif (\n\t\targs.length === 1 &&\n\t\ttypeof args[0] === \"object\" &&\n\t\t\"function\" in args[0]\n\t) {\n\t\t// Register the function.\n\t\tlet arg = args[0];\n\t\tlet { url, name } = arg;\n\t\tlet key = encoding.json.encode({ url, name });\n\t\tassert_(functions[key] === undefined);\n\t\tfunctions[key] = arg.function;\n\n\t\t// Get the package.\n\t\tlet module_ = Module.fromUrl(arg.url);\n\t\tassert_(module_.kind === \"normal\");\n\t\tlet package_ = Package.withId(module_.value.packageId);\n\n\t\t// Create the target.\n\t\treturn new Target(\n\t\t\tObject_.Handle.withObject({\n\t\t\t\tkind: \"target\",\n\t\t\t\tvalue: {\n\t\t\t\t\thost: \"js-js\",\n\t\t\t\t\texecutable: new Template([module_.value.path]),\n\t\t\t\t\tpackage: package_,\n\t\t\t\t\tname: arg.name,\n\t\t\t\t\targs: [],\n\t\t\t\t\tenv: {},\n\t\t\t\t\tchecksum: undefined,\n\t\t\t\t\tunsafe: false,\n\t\t\t\t},\n\t\t\t}),\n\t\t);\n\t} else {\n\t\treturn Target.new(...args);\n\t}\n}\n\nexport let build = async (\n\t...args: Array<Unresolved<Target.Arg>>\n): Promise<Value> => {\n\treturn await (await target(...args)).build();\n};\n\nexport interface Target<\n\tA extends Array<Value> = Array<Value>,\n\tR extends Value = Value,\n> extends globalThis.Function {\n\t(...args: { [K in keyof A]: Unresolved<A[K]> }): Promise<R>;\n}\n\nexport class Target<\n\tA extends Array<Value> = Array<Value>,\n\tR extends Value = Value,\n> extends globalThis.Function {\n\t#handle: Object_.Handle;\n\n\tconstructor(handle: Object_.Handle) {\n\t\tsuper();\n\t\tthis.#handle = handle;\n\t\tlet this_ = this as any;\n\t\treturn new Proxy(this_, {\n\t\t\tget(_target, prop, _receiver) {\n\t\t\t\tif (typeof this_[prop] === \"function\") {\n\t\t\t\t\treturn this_[prop].bind(this_);\n\t\t\t\t} else {\n\t\t\t\t\treturn this_[prop];\n\t\t\t\t}\n\t\t\t},\n\t\t\tapply: async (_target, _, args) => {\n\t\t\t\tlet target = await Target.new(this_ as any, {\n\t\t\t\t\targs: args as Array<Value>,\n\t\t\t\t});\n\t\t\t\treturn await target.build();\n\t\t\t},\n\t\t\tgetPrototypeOf: (_target) => {\n\t\t\t\treturn Object.getPrototypeOf(this_);\n\t\t\t},\n\t\t});\n\t}\n\n\tstatic withId(id: Target.Id): Target {\n\t\treturn new Target(Object_.Handle.withId(id));\n\t}\n\n\tstatic async new<\n\t\tA extends Array<Value> = Array<Value>,\n\t\tR extends Value = Value,\n\t>(...args: Array<Unresolved<Target.Arg>>): Promise<Target<A, R>> {\n\t\tlet { host, executable, package_, name, env, args_, checksum, unsafe_ } =\n\t\t\tflatten(\n\t\t\t\tawait Promise.all(\n\t\t\t\t\targs.map(async function map(\n\t\t\t\t\t\tunresolvedArg: Unresolved<Target.Arg>,\n\t\t\t\t\t): Promise<\n\t\t\t\t\t\tMaybeNestedArray<{\n\t\t\t\t\t\t\thost?: System;\n\t\t\t\t\t\t\texecutable?: Template;\n\t\t\t\t\t\t\tpackage_?: Package;\n\t\t\t\t\t\t\tname?: string;\n\t\t\t\t\t\t\tenv?: Record<string, Value>;\n\t\t\t\t\t\t\targs_?: Array<Value>;\n\t\t\t\t\t\t\tchecksum?: Checksum;\n\t\t\t\t\t\t\tunsafe_?: boolean;\n\t\t\t\t\t\t}>\n\t\t\t\t\t> {\n\t\t\t\t\t\tlet arg = await resolve(unresolvedArg);\n\t\t\t\t\t\tif (Template.Arg.is(arg)) {\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\thost: (await current.env())[\"TANGRAM_HOST\"] as System,\n\t\t\t\t\t\t\t\texecutable: await template(\"/bin/sh\"),\n\t\t\t\t\t\t\t\targs_: [\"-c\", await template(arg)],\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t} else if (Target.is(arg)) {\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\thost: await arg.host(),\n\t\t\t\t\t\t\t\texecutable: await arg.executable(),\n\t\t\t\t\t\t\t\tpackage_: await arg.package(),\n\t\t\t\t\t\t\t\tname: await arg.name_(),\n\t\t\t\t\t\t\t\tenv: await arg.env(),\n\t\t\t\t\t\t\t\targs_: await arg.args(),\n\t\t\t\t\t\t\t\tchecksum: await arg.checksum(),\n\t\t\t\t\t\t\t\tunsafe_: await arg.unsafe(),\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t} else if (arg instanceof Array) {\n\t\t\t\t\t\t\treturn await Promise.all(arg.map(map));\n\t\t\t\t\t\t} else if (typeof arg === \"object\") {\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\thost: arg.host,\n\t\t\t\t\t\t\t\texecutable: arg.executable\n\t\t\t\t\t\t\t\t\t? await template(arg.executable)\n\t\t\t\t\t\t\t\t\t: undefined,\n\t\t\t\t\t\t\t\tpackage_: arg.package,\n\t\t\t\t\t\t\t\tname: arg.name,\n\t\t\t\t\t\t\t\tenv: arg.env,\n\t\t\t\t\t\t\t\targs_: arg.args,\n\t\t\t\t\t\t\t\tchecksum: arg.checksum,\n\t\t\t\t\t\t\t\tunsafe_: arg.unsafe,\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn unreachable();\n\t\t\t\t\t\t}\n\t\t\t\t\t}),\n\t\t\t\t),\n\t\t\t).reduce<{\n\t\t\t\thost?: System;\n\t\t\t\texecutable?: Template;\n\t\t\t\tpackage_?: Package;\n\t\t\t\tname?: string;\n\t\t\t\tenv?: Record<string, Value>;\n\t\t\t\targs_?: Array<Value>;\n\t\t\t\tchecksum?: Checksum;\n\t\t\t\tunsafe_?: boolean;\n\t\t\t}>((a, b) => {\n\t\t\t\treturn {\n\t\t\t\t\thost: a.host ?? b.host,\n\t\t\t\t\texecutable: a.executable ?? b.executable,\n\t\t\t\t\tpackage_: a.package_ ?? b.package_,\n\t\t\t\t\tname: a.name ?? b.name,\n\t\t\t\t\tenv: { ...(a.env ?? {}), ...(b.env ?? {}) },\n\t\t\t\t\targs_: [...(a.args_ ?? []), ...(b.args_ ?? [])],\n\t\t\t\t\tchecksum: a.checksum ?? b.checksum,\n\t\t\t\t\tunsafe_: a.unsafe_ ?? b.unsafe_,\n\t\t\t\t};\n\t\t\t}, {});\n\t\tif (!host) {\n\t\t\tthrow new Error(\"Cannot create a target without a host.\");\n\t\t}\n\t\tif (!executable) {\n\t\t\tthrow new Error(\"Cannot create a target without an executable.\");\n\t\t}\n\t\tenv ??= {};\n\t\targs_ ??= [];\n\t\tunsafe_ ??= false;\n\t\treturn new Target(\n\t\t\tObject_.Handle.withObject({\n\t\t\t\tkind: \"target\",\n\t\t\t\tvalue: {\n\t\t\t\t\thost,\n\t\t\t\t\texecutable,\n\t\t\t\t\tpackage: package_,\n\t\t\t\t\tname,\n\t\t\t\t\tenv,\n\t\t\t\t\targs: args_,\n\t\t\t\t\tchecksum,\n\t\t\t\t\tunsafe: unsafe_,\n\t\t\t\t},\n\t\t\t}),\n\t\t);\n\t}\n\n\tstatic is(value: unknown): value is Target {\n\t\treturn value instanceof Target;\n\t}\n\n\tstatic expect(value: unknown): Target {\n\t\tassert_(Target.is(value));\n\t\treturn value;\n\t}\n\n\tstatic assert(value: unknown): asserts value is Target {\n\t\tassert_(Target.is(value));\n\t}\n\n\tasync id(): Promise<Target.Id> {\n\t\treturn (await this.#handle.id()) as Target.Id;\n\t}\n\n\tasync object(): Promise<Target.Object_> {\n\t\tlet object = await this.#handle.object();\n\t\tassert_(object.kind === \"target\");\n\t\treturn object.value;\n\t}\n\n\tget handle(): Object_.Handle {\n\t\treturn this.#handle;\n\t}\n\n\tasync host(): Promise<System> {\n\t\treturn (await this.object()).host;\n\t}\n\n\tasync executable(): Promise<Template> {\n\t\treturn (await this.object()).executable;\n\t}\n\n\tasync package(): Promise<Package | undefined> {\n\t\treturn (await this.object()).package;\n\t}\n\n\tasync name_(): Promise<string | undefined> {\n\t\treturn (await this.object()).name;\n\t}\n\n\tasync env(): Promise<Record<string, Value>> {\n\t\treturn (await this.object()).env;\n\t}\n\n\tasync args(): Promise<Array<Value>> {\n\t\treturn (await this.object()).args;\n\t}\n\n\tasync checksum(): Promise<Checksum | undefined> {\n\t\treturn (await this.object()).checksum;\n\t}\n\n\tasync unsafe(): Promise<boolean> {\n\t\treturn (await this.object()).unsafe;\n\t}\n\n\tasync build(...args: A): Promise<Value> {\n\t\treturn await syscall.build(\n\t\t\tawait Target.new<[], R>(this as Target, { args }),\n\t\t);\n\t}\n}\n\nexport namespace Target {\n\texport type Arg = Template.Arg | Target | Array<Arg> | ArgObject;\n\n\texport type ArgObject = {\n\t\thost?: System;\n\t\texecutable?: Template.Arg;\n\t\tpackage?: Package;\n\t\tname?: string;\n\t\tenv?: Record<string, Value>;\n\t\targs?: Array<Value>;\n\t\tchecksum?: Checksum;\n\t\tunsafe?: boolean;\n\t};\n\n\texport type Id = string;\n\n\texport type Object_ = {\n\t\thost: System;\n\t\texecutable: Template;\n\t\tpackage: Package | undefined;\n\t\tname: string | undefined;\n\t\tenv: Record<string, Value>;\n\t\targs: Array<Value>;\n\t\tchecksum: Checksum | undefined;\n\t\tunsafe: boolean;\n\t};\n}\n", "import { Blob } from \"./blob.ts\";\nimport { Directory } from \"./directory.ts\";\nimport { File } from \"./file.ts\";\nimport { Package } from \"./package.ts\";\nimport { Symlink } from \"./symlink.ts\";\nimport { Target } from \"./target.ts\";\nimport { Template } from \"./template.ts\";\nimport { Value } from \"./value.ts\";\n\nexport type Unresolved<T extends Value> = MaybePromise<\n\tT extends\n\t\t| undefined\n\t\t| boolean\n\t\t| number\n\t\t| string\n\t\t| Uint8Array\n\t\t| Blob\n\t\t| Directory\n\t\t| File\n\t\t| Symlink\n\t\t| Template\n\t\t| Package\n\t\t| Target\n\t\t? T\n\t\t: T extends Array<infer U extends Value>\n\t\t? Array<Unresolved<U>>\n\t\t: T extends { [key: string]: Value }\n\t\t? { [K in keyof T]: Unresolved<T[K]> }\n\t\t: never\n>;\n\nexport type Resolved<T extends Unresolved<Value>> = T extends\n\t| undefined\n\t| boolean\n\t| number\n\t| string\n\t| Uint8Array\n\t| Blob\n\t| Directory\n\t| File\n\t| Symlink\n\t| Template\n\t| Package\n\t| Target\n\t? T\n\t: T extends Promise<infer U extends Unresolved<Value>>\n\t? Resolved<U>\n\t: T extends Array<infer U extends Unresolved<Value>>\n\t? Array<Resolved<U>>\n\t: T extends { [key: string]: Unresolved<Value> }\n\t? { [K in keyof T]: Resolved<T[K]> }\n\t: never;\n\nexport type MaybePromise<T> = T | Promise<T>;\n\nexport let resolve = async <T extends Unresolved<Value>>(\n\tvalue: T,\n): Promise<Resolved<T>> => {\n\tvalue = await value;\n\tif (\n\t\tvalue === undefined ||\n\t\ttypeof value === \"boolean\" ||\n\t\ttypeof value === \"number\" ||\n\t\ttypeof value === \"string\" ||\n\t\tvalue instanceof Uint8Array ||\n\t\tvalue instanceof Blob ||\n\t\tvalue instanceof Directory ||\n\t\tvalue instanceof File ||\n\t\tvalue instanceof Symlink ||\n\t\tvalue instanceof Template ||\n\t\tvalue instanceof Package ||\n\t\tvalue instanceof Target\n\t) {\n\t\treturn value as unknown as Resolved<T>;\n\t} else if (value instanceof Array) {\n\t\treturn (await Promise.all(\n\t\t\tvalue.map((value) => resolve(value)),\n\t\t)) as Resolved<T>;\n\t} else if (typeof value === \"object\") {\n\t\treturn Object.fromEntries(\n\t\t\tawait Promise.all(\n\t\t\t\tObject.entries(value).map(async ([key, value]) => [\n\t\t\t\t\tkey,\n\t\t\t\t\tawait resolve(value),\n\t\t\t\t]),\n\t\t\t),\n\t\t) as Resolved<T>;\n\t} else {\n\t\tthrow new Error(\"Invalid value to resolve.\");\n\t}\n};\n", "import { Artifact } from \"./artifact.ts\";\nimport { assert as assert_, unreachable } from \"./assert.ts\";\nimport { Checksum } from \"./checksum.ts\";\nimport * as encoding from \"./encoding.ts\";\nimport { Object_ } from \"./object.ts\";\nimport { Unresolved, resolve } from \"./resolve.ts\";\nimport * as syscall from \"./syscall.ts\";\nimport { MaybeNestedArray, flatten } from \"./util.ts\";\n\nexport let blob = async (...args: Array<Unresolved<Blob.Arg>>) => {\n\treturn await Blob.new(...args);\n};\n\nexport let download = async (\n\turl: string,\n\tchecksum: Checksum,\n): Promise<Blob> => {\n\treturn await Blob.download(url, checksum);\n};\n\nexport class Blob {\n\t#handle: Object_.Handle;\n\n\tconstructor(handle: Object_.Handle) {\n\t\tthis.#handle = handle;\n\t}\n\n\tstatic withId(id: Blob.Id): Blob {\n\t\treturn new Blob(Object_.Handle.withId(id));\n\t}\n\n\tstatic async new(...args: Array<Unresolved<Blob.Arg>>): Promise<Blob> {\n\t\tlet children = flatten(\n\t\t\tawait Promise.all(\n\t\t\t\targs.map(async function map(\n\t\t\t\t\tunresolvedArg: Unresolved<Blob.Arg>,\n\t\t\t\t): Promise<MaybeNestedArray<Blob>> {\n\t\t\t\t\tlet arg = await resolve(unresolvedArg);\n\t\t\t\t\tif (arg === undefined) {\n\t\t\t\t\t\treturn [];\n\t\t\t\t\t} else if (typeof arg === \"string\") {\n\t\t\t\t\t\treturn new Blob(\n\t\t\t\t\t\t\tObject_.Handle.withObject({\n\t\t\t\t\t\t\t\tkind: \"blob\",\n\t\t\t\t\t\t\t\tvalue: encoding.utf8.encode(arg),\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t);\n\t\t\t\t\t} else if (arg instanceof Uint8Array) {\n\t\t\t\t\t\treturn new Blob(\n\t\t\t\t\t\t\tObject_.Handle.withObject({ kind: \"blob\", value: arg }),\n\t\t\t\t\t\t);\n\t\t\t\t\t} else if (Blob.is(arg)) {\n\t\t\t\t\t\treturn arg;\n\t\t\t\t\t} else if (arg instanceof Array) {\n\t\t\t\t\t\treturn await Promise.all(arg.map(map));\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn unreachable();\n\t\t\t\t\t}\n\t\t\t\t}),\n\t\t\t),\n\t\t);\n\t\tif (children.length === 0) {\n\t\t\treturn new Blob(\n\t\t\t\tObject_.Handle.withObject({ kind: \"blob\", value: new Uint8Array() }),\n\t\t\t);\n\t\t} else if (children.length === 1) {\n\t\t\treturn children[0]!;\n\t\t} else {\n\t\t\treturn new Blob(\n\t\t\t\tObject_.Handle.withObject({\n\t\t\t\t\tkind: \"blob\",\n\t\t\t\t\tvalue: await Promise.all(\n\t\t\t\t\t\tchildren.map<Promise<[Blob, number]>>(async (child) => {\n\t\t\t\t\t\t\treturn [child, await child.size()];\n\t\t\t\t\t\t}),\n\t\t\t\t\t),\n\t\t\t\t}),\n\t\t\t);\n\t\t}\n\t}\n\n\tstatic async download(url: string, checksum: Checksum): Promise<Blob> {\n\t\treturn await syscall.download(url, checksum);\n\t}\n\n\tstatic is(value: unknown): value is Blob {\n\t\treturn value instanceof Blob;\n\t}\n\n\tstatic expect(value: unknown): Blob {\n\t\tassert_(Blob.is(value));\n\t\treturn value;\n\t}\n\n\tstatic assert(value: unknown): asserts value is Blob {\n\t\tassert_(Blob.is(value));\n\t}\n\n\tasync id(): Promise<Blob.Id> {\n\t\treturn (await this.#handle.id()) as Blob.Id;\n\t}\n\n\tasync object(): Promise<Blob.Object_> {\n\t\tlet object = await this.#handle.object();\n\t\tassert_(object.kind === \"blob\");\n\t\treturn object.value;\n\t}\n\n\tget handle(): Object_.Handle {\n\t\treturn this.#handle;\n\t}\n\n\tasync size(): Promise<number> {\n\t\tlet object = await this.object();\n\t\tif (object instanceof Array) {\n\t\t\treturn object.map(([_, size]) => size).reduce((a, b) => a + b, 0);\n\t\t} else {\n\t\t\treturn object.byteLength;\n\t\t}\n\t}\n\n\tasync bytes(): Promise<Uint8Array> {\n\t\treturn await syscall.read(this);\n\t}\n\n\tasync text(): Promise<string> {\n\t\treturn encoding.utf8.decode(await syscall.read(this));\n\t}\n\n\tasync decompress(format: Blob.CompressionFormat): Promise<Blob> {\n\t\treturn await syscall.decompress(this, format);\n\t}\n\n\tasync extract(format: Blob.ArchiveFormat): Promise<Artifact> {\n\t\treturn await syscall.extract(this, format);\n\t}\n}\n\nexport namespace Blob {\n\texport type Arg = undefined | string | Uint8Array | Blob | Array<Arg>;\n\n\texport namespace Arg {\n\t\texport let is = (value: unknown): value is Arg => {\n\t\t\treturn (\n\t\t\t\tvalue === undefined ||\n\t\t\t\ttypeof value === \"string\" ||\n\t\t\t\tvalue instanceof Uint8Array ||\n\t\t\t\tBlob.is(value) ||\n\t\t\t\t(value instanceof Array && value.every(Arg.is))\n\t\t\t);\n\t\t};\n\n\t\texport let expect = (value: unknown): Arg => {\n\t\t\tassert_(is(value));\n\t\t\treturn value;\n\t\t};\n\n\t\texport let assert = (value: unknown): asserts value is Arg => {\n\t\t\tassert_(is(value));\n\t\t};\n\t}\n\n\texport type Id = string;\n\n\texport type Object_ = Array<[Blob, number]> | Uint8Array;\n\n\texport type ArchiveFormat = \".tar\" | \".zip\";\n\n\texport type CompressionFormat = \".bz2\" | \".gz\" | \".lz\" | \".xz\" | \".zstd\";\n}\n", "import { Artifact } from \"./artifact.ts\";\nimport { assert as assert_, unreachable } from \"./assert.ts\";\nimport { Blob } from \"./blob.ts\";\nimport { File, file } from \"./file.ts\";\nimport { Object_ } from \"./object.ts\";\nimport { Subpath, subpath } from \"./path.ts\";\nimport { Unresolved, resolve } from \"./resolve.ts\";\nimport { Symlink } from \"./symlink.ts\";\nimport * as syscall from \"./syscall.ts\";\n\nexport let directory = async (...args: Array<Unresolved<Directory.Arg>>) => {\n\treturn await Directory.new(...args);\n};\n\nexport class Directory {\n\t#handle: Object_.Handle;\n\n\tconstructor(handle: Object_.Handle) {\n\t\tthis.#handle = handle;\n\t}\n\n\tstatic withId(id: Directory.Id): Directory {\n\t\treturn new Directory(Object_.Handle.withId(id));\n\t}\n\n\tstatic async new(\n\t\t...args: Array<Unresolved<Directory.Arg>>\n\t): Promise<Directory> {\n\t\tlet entries = await (\n\t\t\tawait Promise.all(args.map(resolve))\n\t\t).reduce<Promise<Record<string, Artifact>>>(async function reduce(\n\t\t\tpromiseEntries,\n\t\t\targ,\n\t\t) {\n\t\t\tlet entries = await promiseEntries;\n\t\t\tif (arg === undefined) {\n\t\t\t\t// If the arg is undefined, then continue.\n\t\t\t} else if (Directory.is(arg)) {\n\t\t\t\t// If the arg is a directory, then apply each entry.\n\t\t\t\tfor (let [name, entry] of Object.entries(await arg.entries())) {\n\t\t\t\t\t// Get an existing entry.\n\t\t\t\t\tlet existingEntry = entries[name];\n\n\t\t\t\t\t// Merge the existing entry with the entry if they are both directories.\n\t\t\t\t\tif (Directory.is(existingEntry) && Directory.is(entry)) {\n\t\t\t\t\t\tentry = await Directory.new(existingEntry, entry);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Set the entry.\n\t\t\t\t\tentries[name] = entry;\n\t\t\t\t}\n\t\t\t} else if (arg instanceof Array) {\n\t\t\t\tfor (let argEntry of arg) {\n\t\t\t\t\tentries = await reduce(Promise.resolve(entries), argEntry);\n\t\t\t\t}\n\t\t\t} else if (typeof arg === \"object\") {\n\t\t\t\t// If the arg is an object, then apply each entry.\n\t\t\t\tfor (let [key, value] of Object.entries(arg)) {\n\t\t\t\t\t// Separate the first path component from the trailing path components.\n\t\t\t\t\tlet [firstComponent, ...trailingComponents] =\n\t\t\t\t\t\tsubpath(key).components();\n\t\t\t\t\tif (firstComponent === undefined) {\n\t\t\t\t\t\tthrow new Error(\"The path must have at least one component.\");\n\t\t\t\t\t}\n\t\t\t\t\tlet name = firstComponent;\n\n\t\t\t\t\t// Get an existing entry.\n\t\t\t\t\tlet existingEntry = entries[name];\n\n\t\t\t\t\t// Remove the entry if it is not a directory.\n\t\t\t\t\tif (!Directory.is(existingEntry)) {\n\t\t\t\t\t\texistingEntry = undefined;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (trailingComponents.length > 0) {\n\t\t\t\t\t\t// If there are trailing path components, then recurse.\n\t\t\t\t\t\tlet trailingPath = subpath(trailingComponents).toString();\n\n\t\t\t\t\t\t// Merge the entry with the trailing path.\n\t\t\t\t\t\tlet newEntry = await Directory.new(existingEntry, {\n\t\t\t\t\t\t\t[trailingPath]: value,\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\t// Add the entry.\n\t\t\t\t\t\tentries[name] = newEntry;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// If there are no trailing path components, then create the artifact specified by the value.\n\t\t\t\t\t\tif (value === undefined) {\n\t\t\t\t\t\t\tdelete entries[name];\n\t\t\t\t\t\t} else if (Blob.Arg.is(value)) {\n\t\t\t\t\t\t\tlet newEntry = await file(value);\n\t\t\t\t\t\t\tentries[name] = newEntry;\n\t\t\t\t\t\t} else if (File.is(value) || Symlink.is(value)) {\n\t\t\t\t\t\t\tentries[name] = value;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlet newEntry = await Directory.new(existingEntry, value);\n\t\t\t\t\t\t\tentries[name] = newEntry;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn unreachable();\n\t\t\t}\n\t\t\treturn entries;\n\t\t}, Promise.resolve({}));\n\t\treturn new Directory(\n\t\t\tObject_.Handle.withObject({ kind: \"directory\", value: { entries } }),\n\t\t);\n\t}\n\n\tstatic is(value: unknown): value is Directory {\n\t\treturn value instanceof Directory;\n\t}\n\n\tstatic expect(value: unknown): Directory {\n\t\tassert_(Directory.is(value));\n\t\treturn value;\n\t}\n\n\tstatic assert(value: unknown): asserts value is Directory {\n\t\tassert_(Directory.is(value));\n\t}\n\n\tasync id(): Promise<Directory.Id> {\n\t\treturn (await this.#handle.id()) as Directory.Id;\n\t}\n\n\tasync object(): Promise<Directory.Object_> {\n\t\tlet object = await this.#handle.object();\n\t\tassert_(object.kind === \"directory\");\n\t\treturn object.value;\n\t}\n\n\tget handle(): Object_.Handle {\n\t\treturn this.#handle;\n\t}\n\n\tasync get(arg: string): Promise<Directory | File> {\n\t\tlet artifact = await this.tryGet(arg);\n\t\tassert_(artifact, `Failed to get the directory entry \"${arg}\".`);\n\t\treturn artifact;\n\t}\n\n\tasync tryGet(arg: string): Promise<Directory | File | undefined> {\n\t\tlet artifact: Directory | File = this;\n\t\tlet currentSubpath = subpath();\n\t\tfor (let component of subpath(arg).components()) {\n\t\t\tif (!Directory.is(artifact)) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\tcurrentSubpath.push(component);\n\t\t\tlet entry: Artifact | undefined = (await artifact.entries())[component];\n\t\t\tif (entry === undefined) {\n\t\t\t\treturn undefined;\n\t\t\t} else if (Symlink.is(entry)) {\n\t\t\t\tlet resolved = await entry.resolve({\n\t\t\t\t\tartifact: this,\n\t\t\t\t\tpath: currentSubpath.toString(),\n\t\t\t\t});\n\t\t\t\tif (resolved === undefined) {\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\t\t\t\tartifact = resolved;\n\t\t\t} else {\n\t\t\t\tartifact = entry;\n\t\t\t}\n\t\t}\n\t\treturn artifact;\n\t}\n\n\tasync entries(): Promise<Record<string, Artifact>> {\n\t\tlet entries: Record<string, Artifact> = {};\n\t\tfor await (let [name, artifact] of this) {\n\t\t\tentries[name] = artifact;\n\t\t}\n\t\treturn entries;\n\t}\n\n\tasync bundle(): Promise<Directory> {\n\t\treturn await syscall.bundle(this);\n\t}\n\n\tasync *walk(): AsyncIterableIterator<[Subpath, Artifact]> {\n\t\tfor await (let [name, artifact] of this) {\n\t\t\tyield [subpath(name), artifact];\n\t\t\tif (Directory.is(artifact)) {\n\t\t\t\tfor await (let [entryName, entryArtifact] of artifact.walk()) {\n\t\t\t\t\tyield [subpath(name).join(entryName), entryArtifact];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tasync *[Symbol.asyncIterator](): AsyncIterator<[string, Artifact]> {\n\t\tlet object = await this.object();\n\t\tfor (let [name, artifact] of Object.entries(object.entries)) {\n\t\t\tyield [name, artifact];\n\t\t}\n\t}\n}\n\nexport namespace Directory {\n\texport type Arg = undefined | Directory | Array<Arg> | ArgObject;\n\n\ttype ArgObject = {\n\t\t[name: string]: undefined | Blob.Arg | Artifact | ArgObject;\n\t};\n\n\texport type Id = string;\n\n\texport type Object_ = {\n\t\tentries: Record<string, Artifact>;\n\t};\n}\n", "import { assert as assert_ } from \"./assert.ts\";\nimport { Directory } from \"./directory.ts\";\nimport { File } from \"./file.ts\";\nimport { Symlink } from \"./symlink.ts\";\n\nexport type Artifact = Directory | File | Symlink;\n\nexport namespace Artifact {\n\texport type Id = string;\n\n\texport let is = (value: unknown): value is Artifact => {\n\t\treturn Directory.is(value) || File.is(value) || Symlink.is(value);\n\t};\n\n\texport let expect = (value: unknown): Artifact => {\n\t\tassert_(is(value));\n\t\treturn value;\n\t};\n\n\texport let assert = (value: unknown): asserts value is Artifact => {\n\t\tassert_(is(value));\n\t};\n}\n", "export class Error {\n\tmessage: string;\n\tlocation: Location | undefined;\n\tstack: Array<Location> | undefined;\n\tsource: Error | undefined;\n\n\tconstructor(\n\t\tmessage: string,\n\t\tlocation?: Location,\n\t\tstack?: Array<Location>,\n\t\tsource?: Error,\n\t) {\n\t\tthis.message = message;\n\t\tthis.location = location;\n\t\tthis.stack = stack;\n\t\tthis.source = source;\n\t}\n}\n\ntype Location = { file: string; line: number; column: number };\n\nexport let prepareStackTrace = (\n\t_error: unknown,\n\tstructuredStackTrace: Array<CallSite>,\n) => {\n\tlet callSites = structuredStackTrace.map((callSite) => {\n\t\treturn {\n\t\t\ttypeName: callSite.getTypeName(),\n\t\t\tfunctionName: callSite.getFunctionName(),\n\t\t\tmethodName: callSite.getMethodName(),\n\t\t\tfileName: callSite.getFileName(),\n\t\t\tlineNumber: callSite.getLineNumber(),\n\t\t\tcolumnNumber: callSite.getColumnNumber(),\n\t\t\tisEval: callSite.isEval(),\n\t\t\tisNative: callSite.isNative(),\n\t\t\tisConstructor: callSite.isConstructor(),\n\t\t\tisAsync: callSite.isAsync(),\n\t\t\tisPromiseAll: callSite.isPromiseAll(),\n\t\t\t// isPromiseAny: callSite.isPromiseAny(),\n\t\t\tpromiseIndex: callSite.getPromiseIndex(),\n\t\t};\n\t});\n\treturn { callSites };\n};\n\n/** This type is derived from <https://v8.dev/docs/stack-trace-api#customizing-stack-traces>. */\ntype CallSite = {\n\t/** Returns the type of this as a string. This is the name of the function stored in the constructor field of this, if available, otherwise the object\u2019s [[Class]] internal property. **/\n\tgetTypeName(): string;\n\n\t/** Returns the name of the current function, typically its name property. If a name property is not available an attempt is made to infer a name from the function\u2019s context. **/\n\tgetFunctionName(): string;\n\n\t/** Returns the name of the property of this or one of its prototypes that holds the current function. **/\n\tgetMethodName(): string;\n\n\t/** If this function was defined in a script returns the name of the script. **/\n\tgetFileName(): string | undefined;\n\n\t/** If this function was defined in a script returns the current line number. **/\n\tgetLineNumber(): number | undefined;\n\n\t/** If this function was defined in a script returns the current column number. **/\n\tgetColumnNumber(): number | undefined;\n\n\t/** If this function was created using a call to eval returns a string representing the location where eval was called. **/\n\tgetEvalOrigin(): unknown | undefined;\n\n\t/** does this call take place in code defined by a call to eval? **/\n\tisEval(): boolean;\n\n\t/** is this call in native V8 code? **/\n\tisNative(): boolean;\n\n\t/** is this a constructor call? **/\n\tisConstructor(): boolean;\n\n\t/** Is this an async call (i.e. await, Promise.all(), or Promise.any())? **/\n\tisAsync(): boolean;\n\n\t/** Is this an async call to Promise.all()? **/\n\tisPromiseAll(): boolean;\n\n\t// /** Is this an async call to Promise.any()? **/\n\t// isPromiseAny(): boolean;\n\n\t/** Returns the index of the promise element that was followed in Promise.all() or Promise.any() for async stack traces, or null if the CallSite is not an async Promise.all() or Promise.any() call. **/\n\tgetPromiseIndex(): number | null;\n};\n", "import { Artifact } from \"./artifact.ts\";\nimport { assert } from \"./assert.ts\";\nimport { Directory } from \"./directory.ts\";\nimport { Module } from \"./module.ts\";\nimport { Package } from \"./package.ts\";\nimport { Relpath, subpath } from \"./path.ts\";\n\ntype Arg = {\n\turl: string;\n\tpath: Relpath.Arg;\n};\n\nexport let include = async (arg: Arg): Promise<Artifact> => {\n\tlet module_ = Module.fromUrl(arg.url);\n\tassert(module_.kind === \"normal\");\n\tlet package_ = Package.withId(module_.value.packageId);\n\tlet artifact = await package_.artifact();\n\tDirectory.assert(artifact);\n\tlet path = subpath(module_.value.path)\n\t\t.toRelpath()\n\t\t.parent()\n\t\t.join(arg.path)\n\t\t.toSubpath()\n\t\t.toString();\n\tlet includedArtifact = await artifact.get(path);\n\treturn includedArtifact;\n};\n", "import { unreachable } from \"./assert.ts\";\nimport { Blob } from \"./blob.ts\";\nimport { Directory } from \"./directory.ts\";\nimport { File } from \"./file.ts\";\nimport { Object_ } from \"./object.ts\";\nimport { Package } from \"./package.ts\";\nimport { Symlink } from \"./symlink.ts\";\nimport * as syscall from \"./syscall.ts\";\nimport { Target } from \"./target.ts\";\nimport { Template } from \"./template.ts\";\n\nexport let log = (...args: Array<unknown>) => {\n\tlet string = args.map((arg) => stringify(arg)).join(\" \");\n\tsyscall.log(string);\n};\n\nlet stringify = (value: unknown): string => {\n\treturn stringifyInner(value, new WeakSet());\n};\n\nlet stringifyInner = (value: unknown, visited: WeakSet<object>): string => {\n\tswitch (typeof value) {\n\t\tcase \"string\": {\n\t\t\treturn `\"${value}\"`;\n\t\t}\n\t\tcase \"number\": {\n\t\t\treturn value.toString();\n\t\t}\n\t\tcase \"boolean\": {\n\t\t\treturn value ? \"true\" : \"false\";\n\t\t}\n\t\tcase \"undefined\": {\n\t\t\treturn \"undefined\";\n\t\t}\n\t\tcase \"object\": {\n\t\t\tif (value === null) {\n\t\t\t\treturn \"null\";\n\t\t\t} else {\n\t\t\t\treturn stringifyObject(value, visited);\n\t\t\t}\n\t\t}\n\t\tcase \"function\": {\n\t\t\treturn `(function \"${value.name ?? \"(anonymous)\"}\")`;\n\t\t}\n\t\tcase \"symbol\": {\n\t\t\treturn \"(symbol)\";\n\t\t}\n\t\tcase \"bigint\": {\n\t\t\treturn value.toString();\n\t\t}\n\t}\n};\n\nlet stringifyObject = (value: object, visited: WeakSet<object>): string => {\n\tif (visited.has(value)) {\n\t\treturn \"(circular)\";\n\t}\n\tvisited.add(value);\n\tif (value instanceof Array) {\n\t\treturn `[${value\n\t\t\t.map((value) => stringifyInner(value, visited))\n\t\t\t.join(\", \")}]`;\n\t} else if (value instanceof Error) {\n\t\treturn value.message;\n\t} else if (value instanceof Promise) {\n\t\treturn \"(promise)\";\n\t} else if (Blob.is(value)) {\n\t\tlet handle = stringifyHandle(value.handle, visited);\n\t\treturn `(tg.blob ${handle})`;\n\t} else if (Directory.is(value)) {\n\t\tlet handle = stringifyHandle(value.handle, visited);\n\t\treturn `(tg.directory ${handle})`;\n\t} else if (File.is(value)) {\n\t\tlet handle = stringifyHandle(value.handle, visited);\n\t\treturn `(tg.file ${handle})`;\n\t} else if (Symlink.is(value)) {\n\t\tlet handle = stringifyHandle(value.handle, visited);\n\t\treturn `(tg.symlink ${handle})`;\n\t} else if (Template.is(value)) {\n\t\tlet string = value.components\n\t\t\t.map((component) => {\n\t\t\t\tif (typeof component === \"string\") {\n\t\t\t\t\treturn component;\n\t\t\t\t} else {\n\t\t\t\t\treturn `\\${${stringifyInner(component, visited)}}`;\n\t\t\t\t}\n\t\t\t})\n\t\t\t.join(\"\");\n\t\treturn `(tg.template \"${string}\")`;\n\t} else if (Package.is(value)) {\n\t\tlet handle = stringifyHandle(value.handle, visited);\n\t\treturn `(tg.package \"${handle}\")`;\n\t} else if (Target.is(value)) {\n\t\tlet handle = stringifyHandle(value.handle, visited);\n\t\treturn `(tg.target \"${handle}\")`;\n\t} else {\n\t\tlet constructorName = \"\";\n\t\tif (\n\t\t\tvalue.constructor !== undefined &&\n\t\t\tvalue.constructor.name !== \"Object\"\n\t\t) {\n\t\t\tconstructorName = `${value.constructor.name} `;\n\t\t}\n\t\tlet entries = Object.entries(value).map(\n\t\t\t([key, value]) => `${key}: ${stringifyInner(value, visited)}`,\n\t\t);\n\t\treturn `${constructorName}{ ${entries.join(\", \")} }`;\n\t}\n};\n\nlet stringifyHandle = (\n\thandle: Object_.Handle,\n\tvisited: WeakSet<object>,\n): string => {\n\tlet { id, object } = handle.state;\n\tif (id !== undefined) {\n\t\treturn id;\n\t}\n\tif (object !== undefined) {\n\t\treturn stringifyObject(object, visited);\n\t}\n\treturn unreachable();\n};\n", "import { assert } from \"./assert.ts\";\nimport * as encoding from \"./encoding.ts\";\nimport { Module } from \"./module.ts\";\nimport { Target, functions, setCurrent } from \"./target.ts\";\nimport { Value } from \"./value.ts\";\n\nexport let main = async (target: Target): Promise<Value> => {\n\t// Load the executable.\n\tlet package_ = await target.package();\n\tassert(package_);\n\tlet packageId = await package_.id();\n\tlet executable = await target.executable();\n\tlet path = executable.components[0];\n\tassert(typeof path === \"string\");\n\tlet module_ = {\n\t\tkind: \"normal\" as const,\n\t\tvalue: { packageId, path },\n\t};\n\tlet url = Module.toUrl(module_);\n\tawait import(url);\n\n\t// Get the target.\n\tlet name = await target.name_();\n\tif (!name) {\n\t\tthrow new Error(\"The target must have a name.\");\n\t}\n\n\t// Get the function.\n\tlet key = encoding.json.encode({ url, name });\n\tlet function_ = functions[key];\n\tif (!function_) {\n\t\tthrow new Error(\"Failed to find the function.\");\n\t}\n\n\t// Set the current target.\n\tsetCurrent(target);\n\n\t// Get the args.\n\tlet args = await target.args();\n\n\t// Call the function.\n\tlet output = await function_(...args);\n\n\treturn output;\n};\n", "export let system = (arg: System.Arg): System => {\n\tif (typeof arg === \"string\") {\n\t\treturn arg;\n\t} else {\n\t\tlet { arch, os } = arg;\n\t\treturn `${arch}-${os}` as System;\n\t}\n};\n\nexport type System =\n\t| \"aarch64-darwin\"\n\t| \"aarch64-linux\"\n\t| \"js-js\"\n\t| \"x86_64-darwin\"\n\t| \"x86_64-linux\";\n\nexport namespace System {\n\texport type Arg = System | ArgObject;\n\n\texport type ArgObject = {\n\t\tarch: Arch;\n\t\tos: Os;\n\t};\n\n\texport type Arch = \"aarch64\" | \"js\" | \"x86_64\";\n\n\texport type Os = \"darwin\" | \"js\" | \"linux\";\n\n\texport let is = (value: unknown): value is System => {\n\t\treturn (\n\t\t\tvalue === \"aarch64-darwin\" ||\n\t\t\tvalue === \"aarch64-linux\" ||\n\t\t\tvalue === \"js-js\" ||\n\t\t\tvalue === \"x86_64-darwin\" ||\n\t\t\tvalue === \"x86_64-linux\"\n\t\t);\n\t};\n\n\texport let arch = (system: System): Arch => {\n\t\tswitch (system) {\n\t\t\tcase \"aarch64-darwin\":\n\t\t\tcase \"aarch64-linux\": {\n\t\t\t\treturn \"aarch64\";\n\t\t\t}\n\t\t\tcase \"js-js\": {\n\t\t\t\treturn \"js\";\n\t\t\t}\n\t\t\tcase \"x86_64-linux\":\n\t\t\tcase \"x86_64-darwin\": {\n\t\t\t\treturn \"x86_64\";\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\tthrow new Error(\"Invalid system.\");\n\t\t\t}\n\t\t}\n\t};\n\n\texport let os = (system: System): Os => {\n\t\tswitch (system) {\n\t\t\tcase \"aarch64-darwin\":\n\t\t\tcase \"x86_64-darwin\": {\n\t\t\t\treturn \"darwin\";\n\t\t\t}\n\t\t\tcase \"js-js\": {\n\t\t\t\treturn \"js\";\n\t\t\t}\n\t\t\tcase \"x86_64-linux\":\n\t\t\tcase \"aarch64-linux\": {\n\t\t\t\treturn \"linux\";\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\tthrow new Error(\"Invalid system.\");\n\t\t\t}\n\t\t}\n\t};\n}\n", "import { assert as assert_ } from \"./assert.ts\";\nimport { Blob } from \"./blob.ts\";\nimport { Directory } from \"./directory.ts\";\nimport { File } from \"./file.ts\";\nimport { Package } from \"./package.ts\";\nimport { Symlink } from \"./symlink.ts\";\nimport { Target } from \"./target.ts\";\nimport { Template } from \"./template.ts\";\n\nexport type Value =\n\t| undefined\n\t| boolean\n\t| number\n\t| string\n\t| Uint8Array\n\t| Blob\n\t| Directory\n\t| File\n\t| Symlink\n\t| Template\n\t| Package\n\t| Target\n\t| Array<Value>\n\t| { [key: string]: Value };\n\nexport namespace Value {\n\texport let is = (value: unknown): value is Value => {\n\t\treturn (\n\t\t\tvalue === undefined ||\n\t\t\ttypeof value === \"boolean\" ||\n\t\t\ttypeof value === \"number\" ||\n\t\t\ttypeof value === \"string\" ||\n\t\t\tvalue instanceof Uint8Array ||\n\t\t\tvalue instanceof Blob ||\n\t\t\tvalue instanceof Directory ||\n\t\t\tvalue instanceof File ||\n\t\t\tvalue instanceof Symlink ||\n\t\t\tvalue instanceof Template ||\n\t\t\tvalue instanceof Package ||\n\t\t\tvalue instanceof Target ||\n\t\t\tvalue instanceof Array ||\n\t\t\ttypeof value === \"object\"\n\t\t);\n\t};\n\n\texport let expect = (value: unknown): Value => {\n\t\tassert_(is(value));\n\t\treturn value;\n\t};\n\n\texport let assert = (value: unknown): asserts value is Value => {\n\t\tassert_(is(value));\n\t};\n}\n", "import { Artifact } from \"./artifact.ts\";\nimport { assert, unimplemented, unreachable } from \"./assert.ts\";\nimport { Blob, blob, download } from \"./blob.ts\";\nimport { Directory, directory } from \"./directory.ts\";\nimport * as encoding from \"./encoding.ts\";\nimport { Error as Error_, prepareStackTrace } from \"./error.ts\";\nimport { File, file } from \"./file.ts\";\nimport { include } from \"./include.ts\";\nimport { log } from \"./log.ts\";\nimport { main } from \"./main.ts\";\nimport { Object_ } from \"./object.ts\";\nimport { Package } from \"./package.ts\";\nimport { resolve } from \"./resolve.ts\";\nimport { Symlink, symlink } from \"./symlink.ts\";\nimport { System, system } from \"./system.ts\";\nimport { Target, build, target } from \"./target.ts\";\nimport { Template, t, template } from \"./template.ts\";\nimport { Value } from \"./value.ts\";\n\n// Set `Error.prepareStackTrace`.\nObject.defineProperties(Error, {\n\tprepareStackTrace: { value: prepareStackTrace },\n});\n\n// Create the console global.\nlet console = {\n\tlog,\n};\nObject.defineProperties(globalThis, {\n\tconsole: { value: console },\n});\n\n// Create the tg global.\nlet tg = {\n\tArtifact,\n\tBlob,\n\tDirectory,\n\tError: Error_,\n\tFile,\n\tObject_,\n\tPackage,\n\tSymlink,\n\tSystem,\n\tTarget,\n\tTemplate,\n\tValue,\n\tassert,\n\tblob,\n\tbuild,\n\tdirectory,\n\tdownload,\n\tencoding,\n\tfile,\n\tinclude,\n\tlog,\n\tmain,\n\tresolve,\n\tsymlink,\n\tsystem,\n\ttarget,\n\ttemplate,\n\tunimplemented,\n\tunreachable,\n};\nObject.defineProperties(globalThis, {\n\ttg: { value: tg },\n\tt: { value: t },\n});\n"],
  "mappings": "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",
  "names": ["assert", "condition", "message", "unimplemented", "unreachable", "encoding_exports", "__export", "base64", "hex", "json", "toml", "utf8", "yaml", "build", "target", "cause", "bundle", "artifact", "decompress", "blob", "format", "cause", "download", "url", "checksum", "encoding", "value", "extract", "log", "read", "blob", "cause", "base64", "value", "encoding", "hex", "json", "toml", "utf8", "yaml", "Object_", "Handle", "#state", "state", "id", "object", "flatten", "value", "file", "args", "File", "_File", "#handle", "handle", "id", "Object_", "contentsArgs", "executable", "references", "flatten", "map", "unresolvedArg", "arg", "resolve", "Blob", "unreachable", "value", "contents", "blob", "assert", "object", "Package", "_Package", "#handle", "handle", "id", "Object_", "value", "assert", "object", "relpath", "args", "Relpath", "subpath", "Subpath", "_Relpath", "#parents", "#subpath", "arg", "reduce", "path", "component", "i", "unreachable", "other", "string", "Arg", "value", "assert", "#components", "components", "t", "strings", "placeholders", "components", "i", "string", "placeholder", "template", "args", "Template", "_Template", "#components", "flatten", "map", "arg", "resolve", "unreachable", "component", "lastComponent", "value", "assert", "separator", "separatorTemplate", "argTemplates", "templates", "argTemplate", "Arg", "Component", "Artifact", "symlink", "args", "Symlink", "_Symlink", "#handle", "handle", "id", "Object_", "artifact", "path", "flatten", "map", "unresolvedArg", "arg", "resolve", "relpath", "Artifact", "Template", "assert", "firstComponent", "secondComponent", "unreachable", "value", "target", "t", "object", "from", "fromArtifact", "fromPath", "Directory", "Module", "module", "encoding", "url", "match", "assert", "_", "data", "_path", "current", "setCurrent", "target", "functions", "args", "arg", "url", "name", "key", "json", "assert", "module_", "Module", "package_", "Package", "Target", "Object_", "Template", "build", "_Target", "#handle", "handle", "this_", "_target", "prop", "_receiver", "_", "id", "host", "executable", "env", "args_", "checksum", "unsafe_", "flatten", "map", "unresolvedArg", "resolve", "template", "unreachable", "a", "b", "value", "object", "resolve", "value", "Blob", "Directory", "File", "Symlink", "Template", "Package", "Target", "key", "blob", "args", "Blob", "download", "url", "checksum", "_Blob", "#handle", "handle", "id", "Object_", "children", "flatten", "map", "unresolvedArg", "arg", "resolve", "utf8", "unreachable", "child", "value", "assert", "object", "_", "size", "a", "b", "read", "format", "decompress", "extract", "Arg", "directory", "args", "Directory", "_Directory", "#handle", "handle", "id", "Object_", "entries", "resolve", "reduce", "promiseEntries", "arg", "name", "entry", "existingEntry", "argEntry", "key", "value", "firstComponent", "trailingComponents", "subpath", "trailingPath", "newEntry", "Blob", "file", "File", "Symlink", "unreachable", "assert", "object", "artifact", "currentSubpath", "component", "resolved", "bundle", "entryName", "entryArtifact", "Artifact", "value", "Directory", "File", "Symlink", "assert", "Error", "message", "location", "stack", "source", "prepareStackTrace", "_error", "structuredStackTrace", "callSite", "include", "arg", "module_", "Module", "assert", "artifact", "Package", "Directory", "path", "subpath", "log", "args", "string", "arg", "stringify", "value", "stringifyInner", "visited", "stringifyObject", "Blob", "stringifyHandle", "Directory", "File", "Symlink", "Template", "component", "Package", "Target", "constructorName", "entries", "key", "handle", "id", "object", "unreachable", "main", "target", "package_", "assert", "packageId", "path", "module_", "url", "Module", "name", "key", "json", "function_", "functions", "setCurrent", "args", "system", "arg", "arch", "os", "System", "value", "Value", "value", "Blob", "Directory", "File", "Symlink", "Template", "Package", "Target", "assert", "prepareStackTrace", "console", "log", "tg", "Artifact", "Blob", "Directory", "Error", "File", "Object_", "Package", "Symlink", "System", "Target", "Template", "Value", "assert", "blob", "build", "directory", "download", "encoding_exports", "file", "include", "main", "resolve", "symlink", "system", "target", "template", "unimplemented", "unreachable", "t"]
}
