{
  "version": 3,
  "sources": ["assert.ts", "encoding.ts", "syscall.ts", "object.ts", "file.ts", "package.ts", "path.ts", "template.ts", "symlink.ts", "module.ts", "target.ts", "resolve.ts", "mutation.ts", "blob.ts", "directory.ts", "artifact.ts", "error.ts", "include.ts", "log.ts", "main.ts", "sleep.ts", "system.ts", "value.ts", "runtime.ts"],
  "sourcesContent": ["export let assert: (\n\tcondition: unknown,\n\tmessage?: string,\n) => asserts condition = (condition, message) => {\n\tif (!condition) {\n\t\tthrow new Error(message ?? \"Failed assertion.\");\n\t}\n};\n\nexport let unimplemented = (message?: string): never => {\n\tthrow new Error(message ?? \"Reached unimplemented code.\");\n};\n\nexport let unreachable = (message?: string): never => {\n\tthrow new Error(message ?? \"Reached unreachable code.\");\n};\n\nexport let todo = (): never => {\n\tthrow new Error(\"Reached todo.\");\n};\n", "import * as syscall from \"./syscall.ts\";\n\nexport namespace base64 {\n\texport let decode = (value: string): Uint8Array => {\n\t\treturn syscall.encoding.base64.decode(value);\n\t};\n\n\texport let encode = (value: Uint8Array): string => {\n\t\treturn syscall.encoding.base64.encode(value);\n\t};\n}\n\nexport namespace hex {\n\texport let decode = (value: string): Uint8Array => {\n\t\treturn syscall.encoding.hex.decode(value);\n\t};\n\n\texport let encode = (value: Uint8Array): string => {\n\t\treturn syscall.encoding.hex.encode(value);\n\t};\n}\n\nexport namespace json {\n\texport let decode = (value: string): unknown => {\n\t\treturn syscall.encoding.json.decode(value);\n\t};\n\n\texport let encode = (value: any): string => {\n\t\treturn syscall.encoding.json.encode(value);\n\t};\n}\n\nexport namespace toml {\n\texport let decode = (value: string): unknown => {\n\t\treturn syscall.encoding.toml.decode(value);\n\t};\n\n\texport let encode = (value: any): string => {\n\t\treturn syscall.encoding.toml.encode(value);\n\t};\n}\n\nexport namespace utf8 {\n\texport let decode = (value: Uint8Array): string => {\n\t\treturn syscall.encoding.utf8.decode(value);\n\t};\n\n\texport let encode = (value: string): Uint8Array => {\n\t\treturn syscall.encoding.utf8.encode(value);\n\t};\n}\n\nexport namespace yaml {\n\texport let decode = (value: string): unknown => {\n\t\treturn syscall.encoding.yaml.decode(value);\n\t};\n\n\texport let encode = (value: any): string => {\n\t\treturn syscall.encoding.yaml.encode(value);\n\t};\n}\n", "import { Artifact } from \"./artifact.ts\";\nimport { Blob } from \"./blob.ts\";\nimport { Checksum } from \"./checksum.ts\";\nimport { Directory } from \"./directory.ts\";\nimport { Object_ } from \"./object.ts\";\nimport { Target } from \"./target.ts\";\nimport { Value } from \"./value.ts\";\n\ndeclare global {\n\tfunction syscall(syscall: \"build\", target: Target): Promise<Value>;\n\n\tfunction syscall(syscall: \"bundle\", artifact: Artifact): Promise<Directory>;\n\n\tfunction syscall(\n\t\tsyscall: \"checksum\",\n\t\talgorithm: Checksum.Algorithm,\n\t\tbytes: string | Uint8Array,\n\t): Checksum;\n\n\tfunction syscall(\n\t\tsyscall: \"decompress\",\n\t\tblob: Blob,\n\t\tformat: Blob.CompressionFormat,\n\t): Promise<Blob>;\n\n\tfunction syscall(\n\t\tsyscall: \"download\",\n\t\turl: string,\n\t\tchecksum: Checksum,\n\t): Promise<Blob>;\n\n\tfunction syscall(\n\t\tsyscall: \"encoding_base64_decode\",\n\t\tvalue: string,\n\t): Uint8Array;\n\n\tfunction syscall(\n\t\tsyscall: \"encoding_base64_encode\",\n\t\tvalue: Uint8Array,\n\t): string;\n\n\tfunction syscall(syscall: \"encoding_hex_decode\", value: string): Uint8Array;\n\n\tfunction syscall(syscall: \"encoding_hex_encode\", value: Uint8Array): string;\n\n\tfunction syscall(syscall: \"encoding_json_decode\", value: string): unknown;\n\n\tfunction syscall(syscall: \"encoding_json_encode\", value: any): string;\n\n\tfunction syscall(syscall: \"encoding_toml_decode\", value: string): unknown;\n\n\tfunction syscall(syscall: \"encoding_toml_encode\", value: any): string;\n\n\tfunction syscall(syscall: \"encoding_utf8_decode\", value: Uint8Array): string;\n\n\tfunction syscall(syscall: \"encoding_utf8_encode\", value: string): Uint8Array;\n\n\tfunction syscall(syscall: \"encoding_yaml_decode\", value: string): unknown;\n\n\tfunction syscall(syscall: \"encoding_yaml_encode\", value: any): string;\n\n\tfunction syscall(\n\t\tsyscall: \"extract\",\n\t\tblob: Blob,\n\t\tformat: Blob.ArchiveFormat,\n\t): Promise<Artifact>;\n\n\tfunction syscall(syscall: \"load\", id: Object_.Id): Promise<Object_>;\n\n\tfunction syscall(syscall: \"log\", value: string): void;\n\n\tfunction syscall(syscall: \"read\", blob: Blob): Promise<Uint8Array>;\n\n\tfunction syscall(syscall: \"store\", object: Object_): Promise<Object_.Id>;\n\n\tfunction syscall(syscall: \"sleep\", duration: number): Promise<void>;\n}\n\nexport let build = async (target: Target): Promise<Value> => {\n\ttry {\n\t\treturn await syscall(\"build\", target);\n\t} catch (cause) {\n\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t}\n};\n\nexport let bundle = async (artifact: Artifact): Promise<Directory> => {\n\ttry {\n\t\treturn await syscall(\"bundle\", artifact);\n\t} catch (cause) {\n\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t}\n};\n\nexport let checksum = (\n\talgorithm: Checksum.Algorithm,\n\tbytes: string | Uint8Array,\n): Checksum => {\n\ttry {\n\t\treturn syscall(\"checksum\", algorithm, bytes);\n\t} catch (cause) {\n\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t}\n};\n\nexport let decompress = async (\n\tblob: Blob,\n\tformat: Blob.CompressionFormat,\n): Promise<Blob> => {\n\ttry {\n\t\treturn await syscall(\"decompress\", blob, format);\n\t} catch (cause) {\n\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t}\n};\n\nexport let download = async (\n\turl: string,\n\tchecksum: Checksum,\n): Promise<Blob> => {\n\ttry {\n\t\treturn await syscall(\"download\", url, checksum);\n\t} catch (cause) {\n\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t}\n};\n\nexport let encoding = {\n\tbase64: {\n\t\tdecode: (value: string): Uint8Array => {\n\t\t\ttry {\n\t\t\t\treturn syscall(\"encoding_base64_decode\", value);\n\t\t\t} catch (cause) {\n\t\t\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t\t\t}\n\t\t},\n\n\t\tencode: (value: Uint8Array): string => {\n\t\t\ttry {\n\t\t\t\treturn syscall(\"encoding_base64_encode\", value);\n\t\t\t} catch (cause) {\n\t\t\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t\t\t}\n\t\t},\n\t},\n\n\thex: {\n\t\tdecode: (value: string): Uint8Array => {\n\t\t\ttry {\n\t\t\t\treturn syscall(\"encoding_hex_decode\", value);\n\t\t\t} catch (cause) {\n\t\t\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t\t\t}\n\t\t},\n\n\t\tencode: (value: Uint8Array): string => {\n\t\t\ttry {\n\t\t\t\treturn syscall(\"encoding_hex_encode\", value);\n\t\t\t} catch (cause) {\n\t\t\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t\t\t}\n\t\t},\n\t},\n\n\tjson: {\n\t\tdecode: (value: string): unknown => {\n\t\t\ttry {\n\t\t\t\treturn syscall(\"encoding_json_decode\", value);\n\t\t\t} catch (cause) {\n\t\t\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t\t\t}\n\t\t},\n\n\t\tencode: (value: any): string => {\n\t\t\ttry {\n\t\t\t\treturn syscall(\"encoding_json_encode\", value);\n\t\t\t} catch (cause) {\n\t\t\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t\t\t}\n\t\t},\n\t},\n\n\ttoml: {\n\t\tdecode: (value: string): unknown => {\n\t\t\ttry {\n\t\t\t\treturn syscall(\"encoding_toml_decode\", value);\n\t\t\t} catch (cause) {\n\t\t\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t\t\t}\n\t\t},\n\n\t\tencode: (value: any): string => {\n\t\t\ttry {\n\t\t\t\treturn syscall(\"encoding_toml_encode\", value);\n\t\t\t} catch (cause) {\n\t\t\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t\t\t}\n\t\t},\n\t},\n\n\tutf8: {\n\t\tdecode: (value: Uint8Array): string => {\n\t\t\ttry {\n\t\t\t\treturn syscall(\"encoding_utf8_decode\", value);\n\t\t\t} catch (cause) {\n\t\t\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t\t\t}\n\t\t},\n\n\t\tencode: (value: string): Uint8Array => {\n\t\t\ttry {\n\t\t\t\treturn syscall(\"encoding_utf8_encode\", value);\n\t\t\t} catch (cause) {\n\t\t\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t\t\t}\n\t\t},\n\t},\n\n\tyaml: {\n\t\tdecode: (value: string): unknown => {\n\t\t\ttry {\n\t\t\t\treturn syscall(\"encoding_yaml_decode\", value);\n\t\t\t} catch (cause) {\n\t\t\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t\t\t}\n\t\t},\n\n\t\tencode: (value: any): string => {\n\t\t\ttry {\n\t\t\t\treturn syscall(\"encoding_yaml_encode\", value);\n\t\t\t} catch (cause) {\n\t\t\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t\t\t}\n\t\t},\n\t},\n};\n\nexport let extract = async (\n\tblob: Blob,\n\tformat: Blob.ArchiveFormat,\n): Promise<Artifact> => {\n\ttry {\n\t\treturn await syscall(\"extract\", blob, format);\n\t} catch (cause) {\n\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t}\n};\n\nexport let log = (value: string) => {\n\ttry {\n\t\treturn syscall(\"log\", value);\n\t} catch (cause) {\n\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t}\n};\n\nexport let load = async (id: Object_.Id): Promise<Object_> => {\n\ttry {\n\t\treturn await syscall(\"load\", id);\n\t} catch (cause) {\n\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t}\n};\n\nexport let read = async (blob: Blob): Promise<Uint8Array> => {\n\ttry {\n\t\treturn await syscall(\"read\", blob);\n\t} catch (cause) {\n\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t}\n};\n\nexport let store = async (object: Object_): Promise<Object_.Id> => {\n\ttry {\n\t\treturn await syscall(\"store\", object);\n\t} catch (cause) {\n\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t}\n};\n\nexport let sleep = async (duration: number): Promise<void> => {\n\ttry {\n\t\treturn await syscall(\"sleep\", duration);\n\t} catch (cause) {\n\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t}\n};\n", "import { Blob } from \"./blob.ts\";\nimport { Directory } from \"./directory.ts\";\nimport { File } from \"./file.ts\";\nimport { Package } from \"./package.ts\";\nimport { Symlink } from \"./symlink.ts\";\nimport { Target } from \"./target.ts\";\n\nexport type Object_ =\n\t| { kind: \"blob\"; value: Blob.Object_ }\n\t| { kind: \"directory\"; value: Directory.Object_ }\n\t| { kind: \"file\"; value: File.Object_ }\n\t| { kind: \"symlink\"; value: Symlink.Object_ }\n\t| { kind: \"package\"; value: Package.Object_ }\n\t| { kind: \"target\"; value: Target.Object_ };\n\nexport namespace Object_ {\n\texport type Id = string;\n\n\texport class Handle {\n\t\t#state: State;\n\n\t\tconstructor(state: State) {\n\t\t\tthis.#state = state;\n\t\t}\n\n\t\tget state(): State {\n\t\t\treturn this.#state;\n\t\t}\n\n\t\tstatic withId(id: Id): Handle {\n\t\t\treturn new Handle({ id, object: undefined });\n\t\t}\n\n\t\tstatic withObject(object: Object_): Handle {\n\t\t\treturn new Handle({ id: undefined, object });\n\t\t}\n\n\t\texpectId(): Id {\n\t\t\tif (this.#state.id === undefined) {\n\t\t\t\tthrow new Error();\n\t\t\t}\n\t\t\treturn this.#state.id;\n\t\t}\n\n\t\texpectObject(): Object_ {\n\t\t\tif (this.#state.object === undefined) {\n\t\t\t\tthrow new Error();\n\t\t\t}\n\t\t\treturn this.#state.object;\n\t\t}\n\n\t\tasync id(): Promise<Id> {\n\t\t\tawait this.store();\n\t\t\treturn this.#state.id!;\n\t\t}\n\n\t\tasync object(): Promise<Object_> {\n\t\t\tawait this.load();\n\t\t\treturn this.#state.object!;\n\t\t}\n\n\t\tasync load() {\n\t\t\tif (this.#state.object === undefined) {\n\t\t\t\tthis.#state.object = await syscall(\"load\", this.#state.id!);\n\t\t\t}\n\t\t}\n\n\t\tasync store() {\n\t\t\tif (this.#state.id === undefined) {\n\t\t\t\tthis.#state.id = await syscall(\"store\", this.#state.object!);\n\t\t\t}\n\t\t}\n\t}\n\n\texport type State = {\n\t\tid: Id | undefined;\n\t\tobject: Object_ | undefined;\n\t};\n}\n", "import { Artifact } from \"./artifact.ts\";\nimport { assert as assert_, unreachable } from \"./assert.ts\";\nimport { Blob, blob } from \"./blob.ts\";\nimport { Args, apply, mutation } from \"./mutation.ts\";\nimport { Object_ } from \"./object.ts\";\n\nexport let file = async (...args: Args<File.Arg>) => {\n\treturn await File.new(...args);\n};\n\nexport class File {\n\t#handle: Object_.Handle;\n\n\tconstructor(handle: Object_.Handle) {\n\t\tthis.#handle = handle;\n\t}\n\n\tstatic withId(id: File.Id): File {\n\t\treturn new File(Object_.Handle.withId(id));\n\t}\n\n\tstatic async new(...args: Args<File.Arg>): Promise<File> {\n\t\ttype Apply = {\n\t\t\tcontents?: Array<Blob.Arg>;\n\t\t\texecutable?: Array<boolean>;\n\t\t\treferences?: Array<Artifact>;\n\t\t};\n\t\tlet {\n\t\t\tcontents: contents_,\n\t\t\texecutable: executable_,\n\t\t\treferences: references_,\n\t\t} = await apply<File.Arg, Apply>(args, async (arg) => {\n\t\t\tif (arg === undefined) {\n\t\t\t\treturn {};\n\t\t\t} else if (\n\t\t\t\ttypeof arg === \"string\" ||\n\t\t\t\targ instanceof Uint8Array ||\n\t\t\t\targ instanceof Blob\n\t\t\t) {\n\t\t\t\treturn {\n\t\t\t\t\tcontents: await mutation({ kind: \"array_append\", value: [arg] }),\n\t\t\t\t};\n\t\t\t} else if (File.is(arg)) {\n\t\t\t\treturn {\n\t\t\t\t\tcontents: await mutation({\n\t\t\t\t\t\tkind: \"array_append\",\n\t\t\t\t\t\tvalue: [await arg.contents()],\n\t\t\t\t\t}),\n\t\t\t\t\texecutable: await mutation({\n\t\t\t\t\t\tkind: \"array_append\",\n\t\t\t\t\t\tvalue: [await arg.executable()],\n\t\t\t\t\t}),\n\t\t\t\t\treferences: await mutation({\n\t\t\t\t\t\tkind: \"array_append\",\n\t\t\t\t\t\tvalue: [await arg.references()],\n\t\t\t\t\t}),\n\t\t\t\t};\n\t\t\t} else if (typeof arg === \"object\") {\n\t\t\t\treturn {\n\t\t\t\t\tcontents: await mutation({\n\t\t\t\t\t\tkind: \"array_append\",\n\t\t\t\t\t\tvalue: [arg.contents],\n\t\t\t\t\t}),\n\t\t\t\t\texecutable: await mutation({\n\t\t\t\t\t\tkind: \"array_append\",\n\t\t\t\t\t\tvalue: [arg.executable],\n\t\t\t\t\t}),\n\t\t\t\t\treferences: await mutation({\n\t\t\t\t\t\tkind: \"array_append\",\n\t\t\t\t\t\tvalue: [arg.references],\n\t\t\t\t\t}),\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\treturn unreachable();\n\t\t\t}\n\t\t});\n\t\tlet contents = await blob(contents_);\n\t\tlet executable = (executable_ ?? []).some((executable) => executable);\n\t\tlet references = references_ ?? [];\n\t\treturn new File(\n\t\t\tObject_.Handle.withObject({\n\t\t\t\tkind: \"file\",\n\t\t\t\tvalue: { contents, executable, references },\n\t\t\t}),\n\t\t);\n\t}\n\n\tstatic is(value: unknown): value is File {\n\t\treturn value instanceof File;\n\t}\n\n\tstatic expect(value: unknown): File {\n\t\tassert_(File.is(value));\n\t\treturn value;\n\t}\n\n\tstatic assert(value: unknown): asserts value is File {\n\t\tassert_(File.is(value));\n\t}\n\n\tasync id(): Promise<File.Id> {\n\t\treturn (await this.#handle.id()) as File.Id;\n\t}\n\n\tasync object(): Promise<File.Object_> {\n\t\tlet object = await this.#handle.object();\n\t\tassert_(object.kind === \"file\");\n\t\treturn object.value;\n\t}\n\n\tget handle(): Object_.Handle {\n\t\treturn this.#handle;\n\t}\n\n\tasync contents(): Promise<Blob> {\n\t\treturn (await this.object()).contents;\n\t}\n\n\tasync executable(): Promise<boolean> {\n\t\treturn (await this.object()).executable;\n\t}\n\n\tasync references(): Promise<Array<Artifact>> {\n\t\treturn (await this.object()).references;\n\t}\n\n\tasync size(): Promise<number> {\n\t\treturn (await this.contents()).size();\n\t}\n\n\tasync bytes(): Promise<Uint8Array> {\n\t\treturn (await this.contents()).bytes();\n\t}\n\n\tasync text(): Promise<string> {\n\t\treturn (await this.contents()).text();\n\t}\n}\n\nexport namespace File {\n\texport type Arg =\n\t\t| undefined\n\t\t| string\n\t\t| Uint8Array\n\t\t| Blob\n\t\t| File\n\t\t| ArgObject\n\t\t| Array<Arg>;\n\n\texport type ArgObject = {\n\t\tcontents?: Blob.Arg;\n\t\texecutable?: boolean;\n\t\treferences?: Array<Artifact>;\n\t};\n\n\texport type Id = string;\n\n\texport type Object_ = {\n\t\tcontents: Blob;\n\t\texecutable: boolean;\n\t\treferences: Array<Artifact>;\n\t};\n}\n", "import { Artifact } from \"./artifact.ts\";\nimport { assert as assert_ } from \"./assert.ts\";\nimport { Object_ } from \"./object.ts\";\n\nexport class Package {\n\t#handle: Object_.Handle;\n\n\tconstructor(handle: Object_.Handle) {\n\t\tthis.#handle = handle;\n\t}\n\n\tstatic withId(id: Package.Id): Package {\n\t\treturn new Package(Object_.Handle.withId(id));\n\t}\n\n\tstatic is(value: unknown): value is Package {\n\t\treturn value instanceof Package;\n\t}\n\n\tstatic expect(value: unknown): Package {\n\t\tassert_(Package.is(value));\n\t\treturn value;\n\t}\n\n\tstatic assert(value: unknown): asserts value is Package {\n\t\tassert_(Package.is(value));\n\t}\n\n\tasync id(): Promise<Package.Id> {\n\t\treturn (await this.#handle.id()) as Package.Id;\n\t}\n\n\tasync object(): Promise<Package.Object_> {\n\t\tlet object = await this.#handle.object();\n\t\tassert_(object.kind === \"package\");\n\t\treturn object.value;\n\t}\n\n\tget handle(): Object_.Handle {\n\t\treturn this.#handle;\n\t}\n\n\tasync artifact(): Promise<Artifact> {\n\t\treturn (await this.object()).artifact;\n\t}\n\n\tasync dependencies(): Promise<{ [dependency: string]: Package }> {\n\t\treturn (await this.object()).dependencies;\n\t}\n}\n\nexport namespace Package {\n\texport type Arg = Package | Array<Arg> | ArgObject;\n\n\texport type ArgObject = {\n\t\tartifact: Artifact;\n\t\tdependencies?: { [dependency: string]: Package.Arg };\n\t};\n\n\texport type Id = string;\n\n\texport type Object_ = {\n\t\tartifact: Artifact;\n\t\tdependencies: { [dependency: string]: Package };\n\t};\n}\n", "import { assert as assert_, unreachable } from \"./assert.ts\";\n\nexport let relpath = (...args: Array<Relpath.Arg>): Relpath => {\n\treturn Relpath.new(...args);\n};\n\nexport let subpath = (...args: Array<Subpath.Arg>): Subpath => {\n\treturn Subpath.new(...args);\n};\n\ntype RelpathConstructorArg = {\n\tparents?: number;\n\tsubpath?: Subpath;\n};\n\nexport class Relpath {\n\t#parents: number;\n\t#subpath: Subpath;\n\n\tconstructor(arg?: RelpathConstructorArg) {\n\t\tthis.#parents = arg?.parents ?? 0;\n\t\tthis.#subpath = arg?.subpath ?? new Subpath();\n\t}\n\n\tstatic new(...args: Array<Relpath.Arg>): Relpath {\n\t\treturn args.reduce(function reduce(path: Relpath, arg: Relpath.Arg) {\n\t\t\tif (typeof arg === \"string\") {\n\t\t\t\tfor (let component of arg.split(\"/\")) {\n\t\t\t\t\tif (component === \"\" || component === \".\") {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else if (component === \"..\") {\n\t\t\t\t\t\tpath = path.parent();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpath.#subpath.push(component);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (arg instanceof Relpath) {\n\t\t\t\tfor (let i = 0; i < arg.#parents; i++) {\n\t\t\t\t\tpath.parent();\n\t\t\t\t}\n\t\t\t\tpath.#subpath.join(arg.#subpath);\n\t\t\t} else if (arg instanceof Subpath) {\n\t\t\t\tpath.#subpath.join(arg);\n\t\t\t} else if (arg instanceof Array) {\n\t\t\t\targ.forEach((arg) => reduce(path, arg));\n\t\t\t} else {\n\t\t\t\treturn unreachable();\n\t\t\t}\n\t\t\treturn path;\n\t\t}, new Relpath());\n\t}\n\n\tisEmpty(): boolean {\n\t\treturn this.#parents == 0 && this.#subpath.isEmpty();\n\t}\n\n\tparents(): number {\n\t\treturn this.#parents;\n\t}\n\n\tsubpath(): Subpath {\n\t\treturn this.#subpath;\n\t}\n\n\tparent(): Relpath {\n\t\tif (this.#subpath.isEmpty()) {\n\t\t\tthis.#parents += 1;\n\t\t} else {\n\t\t\tthis.#subpath.pop();\n\t\t}\n\t\treturn this;\n\t}\n\n\tjoin(other: Relpath.Arg): Relpath {\n\t\tother = Relpath.new(other);\n\t\tfor (let i = 0; i < other.#parents; i++) {\n\t\t\tthis.parent();\n\t\t}\n\t\tthis.#subpath.join(other.#subpath);\n\t\treturn this;\n\t}\n\n\textension(): string | undefined {\n\t\treturn this.#subpath.extension();\n\t}\n\n\ttoSubpath(): Subpath {\n\t\tif (this.#parents > 0) {\n\t\t\tthrow new Error(\"Cannot convert to subpath.\");\n\t\t}\n\t\treturn this.#subpath;\n\t}\n\n\ttoString(): string {\n\t\tlet string = \"\";\n\t\tfor (let i = 0; i < this.#parents; i++) {\n\t\t\tstring += \"../\";\n\t\t}\n\t\tstring += this.#subpath.toString();\n\t\treturn string;\n\t}\n}\n\nexport namespace Relpath {\n\texport type Arg = Subpath.Arg | Relpath | Array<Arg>;\n\n\texport namespace Arg {\n\t\texport let is = (value: unknown): value is Relpath.Arg => {\n\t\t\treturn (\n\t\t\t\tSubpath.Arg.is(value) ||\n\t\t\t\tvalue instanceof Relpath ||\n\t\t\t\t(value instanceof Array && value.every(Relpath.Arg.is))\n\t\t\t);\n\t\t};\n\n\t\texport let expect = (value: unknown): Relpath.Arg => {\n\t\t\tassert_(is(value));\n\t\t\treturn value;\n\t\t};\n\n\t\texport let assert = (value: unknown): asserts value is Relpath.Arg => {\n\t\t\tassert_(is(value));\n\t\t};\n\t}\n}\n\nexport class Subpath {\n\t#components: Array<string>;\n\n\tconstructor(components?: Array<string>) {\n\t\tthis.#components = components ?? [];\n\t}\n\n\tstatic new(...args: Array<Subpath.Arg>): Subpath {\n\t\treturn Relpath.new(...args).toSubpath();\n\t}\n\n\tcomponents(): Array<string> {\n\t\treturn [...this.#components];\n\t}\n\n\tisEmpty(): boolean {\n\t\treturn this.#components.length == 0;\n\t}\n\n\tjoin(other: Subpath): Subpath {\n\t\tthis.#components.push(...other.#components);\n\t\treturn this;\n\t}\n\n\tpush(component: string) {\n\t\tthis.#components.push(component);\n\t}\n\n\tpop() {\n\t\tthis.#components.pop();\n\t}\n\n\textension(): string | undefined {\n\t\treturn this.#components.at(-1)?.split(\".\").at(-1);\n\t}\n\n\ttoRelpath(): Relpath {\n\t\treturn Relpath.new(this);\n\t}\n\n\ttoString(): string {\n\t\treturn this.#components.join(\"/\");\n\t}\n}\n\nexport namespace Subpath {\n\texport type Arg = undefined | string | Subpath | Array<Arg>;\n\n\texport namespace Arg {\n\t\texport let is = (value: unknown): value is Subpath.Arg => {\n\t\t\treturn (\n\t\t\t\tvalue === undefined ||\n\t\t\t\ttypeof value === \"string\" ||\n\t\t\t\tvalue instanceof Subpath ||\n\t\t\t\t(value instanceof Array && value.every(Subpath.Arg.is))\n\t\t\t);\n\t\t};\n\n\t\texport let expect = (value: unknown): Subpath.Arg => {\n\t\t\tassert_(is(value));\n\t\t\treturn value;\n\t\t};\n\n\t\texport let assert = (value: unknown): asserts value is Subpath.Arg => {\n\t\t\tassert_(is(value));\n\t\t};\n\t}\n}\n", "import { Artifact } from \"./artifact.ts\";\nimport { assert as assert_, unreachable } from \"./assert.ts\";\nimport { Args, apply, mutation } from \"./mutation.ts\";\nimport { Unresolved } from \"./resolve.ts\";\n\nexport let template = (...args: Args<Template.Arg>): Promise<Template> => {\n\treturn Template.new(...args);\n};\n\nexport class Template {\n\t#components: Array<Template.Component>;\n\n\tconstructor(components: Array<Template.Component>) {\n\t\tthis.#components = components;\n\t}\n\n\tstatic async new(...args: Args<Template.Arg>): Promise<Template> {\n\t\ttype Apply = {\n\t\t\tcomponents: Array<Template.Component>;\n\t\t};\n\t\tlet { components } = await apply<Template.Arg, Apply>(args, async (arg) => {\n\t\t\tif (arg === undefined) {\n\t\t\t\treturn {};\n\t\t\t} else if (typeof arg === \"string\" || Artifact.is(arg)) {\n\t\t\t\treturn {\n\t\t\t\t\tcomponents: await mutation({\n\t\t\t\t\t\tkind: \"array_append\",\n\t\t\t\t\t\tvalue: [arg],\n\t\t\t\t\t}),\n\t\t\t\t};\n\t\t\t} else if (Template.is(arg)) {\n\t\t\t\treturn {\n\t\t\t\t\tcomponents: await mutation({\n\t\t\t\t\t\tkind: \"array_append\",\n\t\t\t\t\t\tvalue: arg.components,\n\t\t\t\t\t}),\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\treturn unreachable();\n\t\t\t}\n\t\t});\n\n\t\t// Normalize the components.\n\t\tcomponents = (components ?? []).reduce<Array<Template.Component>>(\n\t\t\t(components, component) => {\n\t\t\t\tlet lastComponent = components.at(-1);\n\t\t\t\tif (component === \"\") {\n\t\t\t\t\t// Ignore empty string components.\n\t\t\t\t} else if (\n\t\t\t\t\ttypeof lastComponent === \"string\" &&\n\t\t\t\t\ttypeof component === \"string\"\n\t\t\t\t) {\n\t\t\t\t\t// Merge adjacent string components.\n\t\t\t\t\tcomponents.splice(-1, 1, lastComponent + component);\n\t\t\t\t} else {\n\t\t\t\t\tcomponents.push(component);\n\t\t\t\t}\n\t\t\t\treturn components;\n\t\t\t},\n\t\t\t[],\n\t\t);\n\n\t\treturn new Template(components);\n\t}\n\n\tstatic is(value: unknown): value is Template {\n\t\treturn value instanceof Template;\n\t}\n\n\tstatic expect(value: unknown): Template {\n\t\tassert_(Template.is(value));\n\t\treturn value;\n\t}\n\n\tstatic assert(value: unknown): asserts value is Template {\n\t\tassert_(Template.is(value));\n\t}\n\n\t/** Join an array of templates with a separator. */\n\tstatic async join(\n\t\tseparator: Unresolved<Template.Arg>,\n\t\t...args: Array<Unresolved<Template.Arg>>\n\t): Promise<Template> {\n\t\tlet separatorTemplate = await template(separator);\n\t\tlet argTemplates = await Promise.all(args.map((arg) => template(arg)));\n\t\targTemplates = argTemplates.filter((arg) => arg.components.length > 0);\n\t\tlet templates = [];\n\t\tfor (let i = 0; i < argTemplates.length; i++) {\n\t\t\tif (i > 0) {\n\t\t\t\ttemplates.push(separatorTemplate);\n\t\t\t}\n\t\t\tlet argTemplate = argTemplates[i];\n\t\t\tassert_(argTemplate);\n\t\t\ttemplates.push(argTemplate);\n\t\t}\n\t\treturn template(...templates);\n\t}\n\n\tget components(): Array<Template.Component> {\n\t\treturn this.#components;\n\t}\n}\n\nexport namespace Template {\n\texport type Arg = undefined | Component | Template;\n\n\texport type Component = string | Artifact;\n}\n", "import { Artifact } from \"./artifact.ts\";\nimport { assert as assert_, unreachable } from \"./assert.ts\";\nimport { Directory } from \"./directory.ts\";\nimport { File } from \"./file.ts\";\nimport { Args, apply, mutation } from \"./mutation.ts\";\nimport { Object_ } from \"./object.ts\";\nimport { Relpath, relpath } from \"./path.ts\";\nimport { Unresolved } from \"./resolve.ts\";\nimport { Template, template } from \"./template.ts\";\n\nexport let symlink = async (...args: Args<Symlink.Arg>): Promise<Symlink> => {\n\treturn await Symlink.new(...args);\n};\n\nexport class Symlink {\n\t#handle: Object_.Handle;\n\n\tconstructor(handle: Object_.Handle) {\n\t\tthis.#handle = handle;\n\t}\n\n\tstatic withId(id: Symlink.Id): Symlink {\n\t\treturn new Symlink(Object_.Handle.withId(id));\n\t}\n\n\tstatic async new(...args: Args<Symlink.Arg>): Promise<Symlink> {\n\t\ttype Apply = {\n\t\t\tartifact?: Artifact | undefined;\n\t\t\tpath?: string | undefined;\n\t\t};\n\t\tlet { artifact, path: path_ } = await apply<Symlink.Arg, Apply>(\n\t\t\targs,\n\t\t\tasync (arg) => {\n\t\t\t\tif (arg === undefined) {\n\t\t\t\t\treturn {};\n\t\t\t\t} else if (typeof arg === \"string\") {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tpath: await mutation({ kind: \"template_append\", value: arg }),\n\t\t\t\t\t};\n\t\t\t\t} else if (Artifact.is(arg)) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tartifact: arg,\n\t\t\t\t\t\tpath: await mutation({ kind: \"unset\" as const }),\n\t\t\t\t\t};\n\t\t\t\t} else if (Template.is(arg)) {\n\t\t\t\t\tassert_(arg.components.length <= 2);\n\t\t\t\t\tlet [firstComponent, secondComponent] = arg.components;\n\t\t\t\t\tif (\n\t\t\t\t\t\ttypeof firstComponent === \"string\" &&\n\t\t\t\t\t\tsecondComponent === undefined\n\t\t\t\t\t) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tpath: await mutation({\n\t\t\t\t\t\t\t\tkind: \"template_append\" as const,\n\t\t\t\t\t\t\t\tvalue: firstComponent,\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t};\n\t\t\t\t\t} else if (\n\t\t\t\t\t\tArtifact.is(firstComponent) &&\n\t\t\t\t\t\tsecondComponent === undefined\n\t\t\t\t\t) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tartifact: firstComponent,\n\t\t\t\t\t\t\tpath: await mutation({ kind: \"unset\" as const }),\n\t\t\t\t\t\t};\n\t\t\t\t\t} else if (\n\t\t\t\t\t\tArtifact.is(firstComponent) &&\n\t\t\t\t\t\ttypeof secondComponent === \"string\"\n\t\t\t\t\t) {\n\t\t\t\t\t\tassert_(secondComponent.startsWith(\"/\"));\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tartifact: firstComponent,\n\t\t\t\t\t\t\tpath: secondComponent.slice(1),\n\t\t\t\t\t\t};\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new Error(\"Invalid template.\");\n\t\t\t\t\t}\n\t\t\t\t} else if (Symlink.is(arg)) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tartifact: await arg.artifact(),\n\t\t\t\t\t\tpath: (await arg.path()).toString(),\n\t\t\t\t\t};\n\t\t\t\t} else if (Template.is(arg)) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tpath: await mutation({ kind: \"template_append\", value: arg }),\n\t\t\t\t\t};\n\t\t\t\t} else if (typeof arg === \"object\") {\n\t\t\t\t\treturn arg;\n\t\t\t\t} else {\n\t\t\t\t\treturn unreachable();\n\t\t\t\t}\n\t\t\t},\n\t\t);\n\n\t\t// Create the target.\n\t\tlet path = relpath(path_ ?? \"\");\n\t\tlet target;\n\t\tif (artifact !== undefined && !path.isEmpty()) {\n\t\t\ttarget = await template(artifact, \"/\", path.toString());\n\t\t} else if (artifact !== undefined) {\n\t\t\ttarget = await template(artifact);\n\t\t} else if (!path.isEmpty()) {\n\t\t\ttarget = await template(path.toString());\n\t\t} else {\n\t\t\tthrow new Error(\"Invalid symlink.\");\n\t\t}\n\n\t\treturn new Symlink(\n\t\t\tObject_.Handle.withObject({ kind: \"symlink\", value: { target } }),\n\t\t);\n\t}\n\n\tstatic is(value: unknown): value is Symlink {\n\t\treturn value instanceof Symlink;\n\t}\n\n\tstatic expect(value: unknown): Symlink {\n\t\tassert_(Symlink.is(value));\n\t\treturn value;\n\t}\n\n\tstatic assert(value: unknown): asserts value is Symlink {\n\t\tassert_(Symlink.is(value));\n\t}\n\n\tasync id(): Promise<Symlink.Id> {\n\t\treturn (await this.#handle.id()) as Symlink.Id;\n\t}\n\n\tasync object(): Promise<Symlink.Object_> {\n\t\tlet object = await this.#handle.object();\n\t\tassert_(object.kind === \"symlink\");\n\t\treturn object.value;\n\t}\n\n\tget handle(): Object_.Handle {\n\t\treturn this.#handle;\n\t}\n\n\tasync target(): Promise<Template> {\n\t\treturn (await this.object()).target;\n\t}\n\n\tasync artifact(): Promise<Artifact | undefined> {\n\t\tlet target = await this.target();\n\t\tlet firstComponent = target.components.at(0);\n\t\tif (Artifact.is(firstComponent)) {\n\t\t\treturn firstComponent;\n\t\t} else {\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\tasync path(): Promise<Relpath> {\n\t\tlet target = await this.target();\n\t\tlet [firstComponent, secondComponent] = target.components;\n\t\tif (typeof firstComponent === \"string\" && secondComponent === undefined) {\n\t\t\treturn relpath(firstComponent);\n\t\t} else if (Artifact.is(firstComponent) && secondComponent === undefined) {\n\t\t\treturn relpath();\n\t\t} else if (\n\t\t\tArtifact.is(firstComponent) &&\n\t\t\ttypeof secondComponent === \"string\"\n\t\t) {\n\t\t\treturn relpath(secondComponent.slice(1));\n\t\t} else {\n\t\t\tthrow new Error(\"Invalid template.\");\n\t\t}\n\t}\n\n\tasync resolve(\n\t\tfrom?: Unresolved<Symlink.Arg>,\n\t): Promise<Directory | File | undefined> {\n\t\tfrom = from ? await symlink(from) : undefined;\n\t\tlet fromArtifact = await from?.artifact();\n\t\tif (Symlink.is(fromArtifact)) {\n\t\t\tfromArtifact = await fromArtifact.resolve();\n\t\t}\n\t\tlet fromPath = from?.path();\n\t\tlet artifact = await this.artifact();\n\t\tif (Symlink.is(artifact)) {\n\t\t\tartifact = await artifact.resolve();\n\t\t}\n\t\tlet path = await this.path();\n\t\tif (artifact !== undefined && path.isEmpty()) {\n\t\t\treturn artifact;\n\t\t} else if (artifact === undefined && !path.isEmpty()) {\n\t\t\tif (!Directory.is(fromArtifact)) {\n\t\t\t\tthrow new Error(\"Expected a directory.\");\n\t\t\t}\n\t\t\treturn await fromArtifact.tryGet(\n\t\t\t\t(await (fromPath ?? relpath()))\n\t\t\t\t\t.parent()\n\t\t\t\t\t.join(path)\n\t\t\t\t\t.toSubpath()\n\t\t\t\t\t.toString(),\n\t\t\t);\n\t\t} else if (artifact !== undefined && !path.isEmpty()) {\n\t\t\tif (!Directory.is(artifact)) {\n\t\t\t\tthrow new Error(\"Expected a directory.\");\n\t\t\t}\n\t\t\treturn await artifact.tryGet(path.toSubpath().toString());\n\t\t} else {\n\t\t\tthrow new Error(\"Invalid symlink.\");\n\t\t}\n\t}\n}\n\nexport namespace Symlink {\n\texport type Arg =\n\t\t| undefined\n\t\t| string\n\t\t| Artifact\n\t\t| Template\n\t\t| Symlink\n\t\t| ArgObject\n\t\t| Array<Arg>;\n\n\texport type ArgObject = {\n\t\tartifact?: Artifact;\n\t\tpath?: string;\n\t};\n\n\texport type Id = string;\n\n\texport type Object_ = { target: Template };\n}\n", "import { assert } from \"./assert.ts\";\nimport { encoding } from \"./syscall.ts\";\n\nexport type Module =\n\t| { kind: \"document\"; value: Document }\n\t| { kind: \"library\"; value: Library }\n\t| { kind: \"normal\"; value: Normal };\n\nexport type Document = {\n\tpackagePath: string;\n\tpath: string;\n};\n\nexport type Library = {\n\tpath: string;\n};\n\nexport type Normal = {\n\tpackageId: string;\n\tpath: string;\n};\n\nexport namespace Module {\n\texport let toUrl = (module: Module): string => {\n\t\tlet data = encoding.hex.encode(\n\t\t\tencoding.utf8.encode(encoding.json.encode(module)),\n\t\t);\n\t\treturn `tangram://${data}/${module.value.path}`;\n\t};\n\n\texport let fromUrl = (url: string): Module => {\n\t\tlet match = url.match(/^tangram:\\/\\/([0-9a-f]+)/);\n\t\tassert(match);\n\t\tlet [_, data] = match;\n\t\tassert(data !== undefined);\n\t\treturn encoding.json.decode(\n\t\t\tencoding.utf8.decode(encoding.hex.decode(data)),\n\t\t) as Module;\n\t};\n}\n", "import { Artifact } from \"./artifact.ts\";\nimport { assert as assert_, unreachable } from \"./assert.ts\";\nimport { Checksum } from \"./checksum.ts\";\nimport * as encoding from \"./encoding.ts\";\nimport { Module } from \"./module.ts\";\nimport {\n\tArgs,\n\tMaybeNestedArray,\n\tMutationMap,\n\tapply,\n\tflatten,\n\tmutation,\n} from \"./mutation.ts\";\nimport { Object_ } from \"./object.ts\";\nimport { Package } from \"./package.ts\";\nimport { MaybePromise, Unresolved, resolve } from \"./resolve.ts\";\nimport * as syscall from \"./syscall.ts\";\nimport { System } from \"./system.ts\";\nimport { Template, template } from \"./template.ts\";\nimport { Value } from \"./value.ts\";\n\nlet current: Target;\nexport let getCurrent = (): Target => {\n\treturn current;\n};\nexport let setCurrent = (target: Target) => {\n\tcurrent = target;\n};\n\nexport let functions: Record<string, Function> = {};\n\ntype FunctionArg<\n\tA extends Array<Value> = Array<Value>,\n\tR extends Value = Value,\n> = {\n\turl: string;\n\tname: string;\n\tfunction: (...args: A) => MaybePromise<R | void>;\n};\n\nexport function target<\n\tA extends Array<Value> = Array<Value>,\n\tR extends Value = Value,\n>(args: FunctionArg): Target<A, R>;\nexport function target<\n\tA extends Array<Value> = Array<Value>,\n\tR extends Value = Value,\n>(...args: Args<Target.Arg>): Promise<Target<A, R>>;\nexport function target<\n\tA extends Array<Value> = Array<Value>,\n\tR extends Value = Value,\n>(...args: [FunctionArg<A, R>] | Args<Target.Arg>): MaybePromise<Target<A, R>> {\n\tif (\n\t\targs.length === 1 &&\n\t\ttypeof args[0] === \"object\" &&\n\t\t\"function\" in args[0]\n\t) {\n\t\t// Register the function.\n\t\tlet arg = args[0];\n\t\tlet { url, name } = arg;\n\t\tlet key = encoding.json.encode({ url, name });\n\t\tassert_(functions[key] === undefined);\n\t\tfunctions[key] = arg.function;\n\n\t\t// Get the package.\n\t\tlet module_ = Module.fromUrl(arg.url);\n\t\tassert_(module_.kind === \"normal\");\n\t\tlet package_ = Package.withId(module_.value.packageId);\n\n\t\t// Create the target.\n\t\treturn new Target(\n\t\t\tObject_.Handle.withObject({\n\t\t\t\tkind: \"target\",\n\t\t\t\tvalue: {\n\t\t\t\t\thost: \"js-js\",\n\t\t\t\t\texecutable: new Template([module_.value.path]),\n\t\t\t\t\tpackage: package_,\n\t\t\t\t\tname: arg.name,\n\t\t\t\t\targs: [],\n\t\t\t\t\tenv: {},\n\t\t\t\t\tchecksum: undefined,\n\t\t\t\t\tunsafe: false,\n\t\t\t\t},\n\t\t\t}),\n\t\t);\n\t} else {\n\t\treturn Target.new(...args);\n\t}\n}\n\nexport let build = async (\n\t...args: Array<Unresolved<Target.Arg>>\n): Promise<Value> => {\n\treturn await (await target(...args)).build();\n};\n\nexport interface Target<\n\tA extends Array<Value> = Array<Value>,\n\tR extends Value = Value,\n> extends globalThis.Function {\n\t(...args: { [K in keyof A]: Unresolved<A[K]> }): Promise<R>;\n}\n\nexport class Target<\n\tA extends Array<Value> = Array<Value>,\n\tR extends Value = Value,\n> extends globalThis.Function {\n\t#handle: Object_.Handle;\n\n\tconstructor(handle: Object_.Handle) {\n\t\tsuper();\n\t\tthis.#handle = handle;\n\t\tlet this_ = this as any;\n\t\treturn new Proxy(this_, {\n\t\t\tget(_target, prop, _receiver) {\n\t\t\t\tif (typeof this_[prop] === \"function\") {\n\t\t\t\t\treturn this_[prop].bind(this_);\n\t\t\t\t} else {\n\t\t\t\t\treturn this_[prop];\n\t\t\t\t}\n\t\t\t},\n\t\t\tapply: async (_target, _, args) => {\n\t\t\t\tlet target = await Target.new(this_ as any, {\n\t\t\t\t\targs: (await resolve(args)) as Array<Value>,\n\t\t\t\t});\n\t\t\t\treturn await target.build();\n\t\t\t},\n\t\t\tgetPrototypeOf: (_target) => {\n\t\t\t\treturn Object.getPrototypeOf(this_);\n\t\t\t},\n\t\t});\n\t}\n\n\tstatic withId(id: Target.Id): Target {\n\t\treturn new Target(Object_.Handle.withId(id));\n\t}\n\n\tstatic async new<\n\t\tA extends Array<Value> = Array<Value>,\n\t\tR extends Value = Value,\n\t>(...args: Args<Target.Arg>): Promise<Target<A, R>> {\n\t\ttype Apply = {\n\t\t\thost?: System;\n\t\t\texecutable?: Template.Arg;\n\t\t\tpackage?: Package | undefined;\n\t\t\tname?: string | undefined;\n\t\t\tenv?: MaybeNestedArray<MutationMap>;\n\t\t\targs?: Array<Value>;\n\t\t\tchecksum?: Checksum | undefined;\n\t\t\tunsafe?: boolean;\n\t\t};\n\t\tlet {\n\t\t\thost,\n\t\t\texecutable: executable_,\n\t\t\tpackage: package_,\n\t\t\tname,\n\t\t\tenv: env_,\n\t\t\targs: args_,\n\t\t\tchecksum,\n\t\t\tunsafe: unsafe_,\n\t\t} = await apply<Target.Arg, Apply>(args, async (arg) => {\n\t\t\tif (\n\t\t\t\ttypeof arg === \"string\" ||\n\t\t\t\tArtifact.is(arg) ||\n\t\t\t\targ instanceof Template\n\t\t\t) {\n\t\t\t\treturn {\n\t\t\t\t\thost: (await getCurrent().env())[\"TANGRAM_HOST\"] as System,\n\t\t\t\t\texecutable: \"/bin/sh\",\n\t\t\t\t\targs: [\"-c\", arg],\n\t\t\t\t};\n\t\t\t} else if (Target.is(arg)) {\n\t\t\t\treturn await arg.object();\n\t\t\t} else if (typeof arg === \"object\") {\n\t\t\t\treturn {\n\t\t\t\t\t...arg,\n\t\t\t\t\tenv: await mutation({ kind: \"array_append\", value: [arg.env] }),\n\t\t\t\t\targs: await mutation({ kind: \"array_append\", value: [arg.args] }),\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\treturn unreachable();\n\t\t\t}\n\t\t});\n\t\tif (!host) {\n\t\t\tthrow new Error(\"Cannot create a target without a host.\");\n\t\t}\n\t\tif (!executable_) {\n\t\t\tthrow new Error(\"Cannot create a target without an executable.\");\n\t\t}\n\t\tlet executable = await template(executable_);\n\t\tlet env = await apply(flatten(env_ ?? []), async (arg) => arg);\n\t\targs_ ??= [];\n\t\tunsafe_ ??= false;\n\t\treturn new Target(\n\t\t\tObject_.Handle.withObject({\n\t\t\t\tkind: \"target\",\n\t\t\t\tvalue: {\n\t\t\t\t\thost,\n\t\t\t\t\texecutable,\n\t\t\t\t\tpackage: package_,\n\t\t\t\t\tname,\n\t\t\t\t\tenv,\n\t\t\t\t\targs: args_,\n\t\t\t\t\tchecksum,\n\t\t\t\t\tunsafe: unsafe_,\n\t\t\t\t},\n\t\t\t}),\n\t\t);\n\t}\n\n\tstatic is(value: unknown): value is Target {\n\t\treturn value instanceof Target;\n\t}\n\n\tstatic expect(value: unknown): Target {\n\t\tassert_(Target.is(value));\n\t\treturn value;\n\t}\n\n\tstatic assert(value: unknown): asserts value is Target {\n\t\tassert_(Target.is(value));\n\t}\n\n\tasync id(): Promise<Target.Id> {\n\t\treturn (await this.#handle.id()) as Target.Id;\n\t}\n\n\tasync object(): Promise<Target.Object_> {\n\t\tlet object = await this.#handle.object();\n\t\tassert_(object.kind === \"target\");\n\t\treturn object.value;\n\t}\n\n\tget handle(): Object_.Handle {\n\t\treturn this.#handle;\n\t}\n\n\tasync host(): Promise<System> {\n\t\treturn (await this.object()).host;\n\t}\n\n\tasync executable(): Promise<Template> {\n\t\treturn (await this.object()).executable;\n\t}\n\n\tasync package(): Promise<Package | undefined> {\n\t\treturn (await this.object()).package;\n\t}\n\n\tasync name_(): Promise<string | undefined> {\n\t\treturn (await this.object()).name;\n\t}\n\n\tasync env(): Promise<Record<string, Value>> {\n\t\treturn (await this.object()).env;\n\t}\n\n\tasync args(): Promise<Array<Value>> {\n\t\treturn (await this.object()).args;\n\t}\n\n\tasync checksum(): Promise<Checksum | undefined> {\n\t\treturn (await this.object()).checksum;\n\t}\n\n\tasync unsafe(): Promise<boolean> {\n\t\treturn (await this.object()).unsafe;\n\t}\n\n\tasync build(...args: A): Promise<Value> {\n\t\treturn await syscall.build(\n\t\t\tawait Target.new<[], R>(this as Target, { args }),\n\t\t);\n\t}\n}\n\nexport namespace Target {\n\texport type Arg =\n\t\t| undefined\n\t\t| string\n\t\t| Artifact\n\t\t| Template\n\t\t| Target\n\t\t| ArgObject\n\t\t| Array<Arg>;\n\n\texport type ArgObject = {\n\t\thost?: System;\n\t\texecutable?: Template.Arg;\n\t\tpackage?: Package | undefined;\n\t\tname?: string | undefined;\n\t\tenv?: MutationMap;\n\t\targs?: Array<Value>;\n\t\tchecksum?: Checksum | undefined;\n\t\tunsafe?: boolean;\n\t};\n\n\texport type Id = string;\n\n\texport type Object_ = {\n\t\thost: System;\n\t\texecutable: Template;\n\t\tpackage: Package | undefined;\n\t\tname: string | undefined;\n\t\tenv: Record<string, Value>;\n\t\targs: Array<Value>;\n\t\tchecksum: Checksum | undefined;\n\t\tunsafe: boolean;\n\t};\n}\n", "import { Blob } from \"./blob.ts\";\nimport { Directory } from \"./directory.ts\";\nimport { File } from \"./file.ts\";\nimport { Mutation } from \"./mutation.ts\";\nimport { Package } from \"./package.ts\";\nimport { Symlink } from \"./symlink.ts\";\nimport { Target } from \"./target.ts\";\nimport { Template } from \"./template.ts\";\nimport { Value } from \"./value.ts\";\n\nexport type Unresolved<T extends Value> = MaybePromise<\n\tT extends\n\t\t| undefined\n\t\t| boolean\n\t\t| number\n\t\t| string\n\t\t| Uint8Array\n\t\t| Blob\n\t\t| Directory\n\t\t| File\n\t\t| Symlink\n\t\t| Template\n\t\t| Mutation\n\t\t| Package\n\t\t| Target\n\t\t? T\n\t\t: T extends Array<infer U extends Value>\n\t\t? Array<Unresolved<U>>\n\t\t: T extends { [key: string]: Value }\n\t\t? { [K in keyof T]: Unresolved<T[K]> }\n\t\t: never\n>;\n\nexport type Resolved<T extends Unresolved<Value>> = T extends\n\t| undefined\n\t| boolean\n\t| number\n\t| string\n\t| Uint8Array\n\t| Blob\n\t| Directory\n\t| File\n\t| Symlink\n\t| Template\n\t| Mutation\n\t| Package\n\t| Target\n\t? T\n\t: T extends Promise<infer U extends Unresolved<Value>>\n\t? Resolved<U>\n\t: T extends Array<infer U extends Unresolved<Value>>\n\t? Array<Resolved<U>>\n\t: T extends { [key: string]: Unresolved<Value> }\n\t? { [K in keyof T]: Resolved<T[K]> }\n\t: never;\n\nexport type MaybePromise<T> = T | Promise<T>;\n\nexport let resolve = async <T extends Unresolved<Value>>(\n\tvalue: T,\n): Promise<Resolved<T>> => {\n\tvalue = await value;\n\tif (\n\t\tvalue === undefined ||\n\t\ttypeof value === \"boolean\" ||\n\t\ttypeof value === \"number\" ||\n\t\ttypeof value === \"string\" ||\n\t\tvalue instanceof Uint8Array ||\n\t\tvalue instanceof Blob ||\n\t\tvalue instanceof Directory ||\n\t\tvalue instanceof File ||\n\t\tvalue instanceof Symlink ||\n\t\tvalue instanceof Template ||\n\t\tvalue instanceof Mutation ||\n\t\tvalue instanceof Package ||\n\t\tvalue instanceof Target\n\t) {\n\t\treturn value as unknown as Resolved<T>;\n\t} else if (value instanceof Array) {\n\t\treturn (await Promise.all(\n\t\t\tvalue.map((value) => resolve(value)),\n\t\t)) as Resolved<T>;\n\t} else if (typeof value === \"object\") {\n\t\treturn Object.fromEntries(\n\t\t\tawait Promise.all(\n\t\t\t\tObject.entries(value).map(async ([key, value]) => [\n\t\t\t\t\tkey,\n\t\t\t\t\tawait resolve(value),\n\t\t\t\t]),\n\t\t\t),\n\t\t) as Resolved<T>;\n\t} else {\n\t\tthrow new Error(\"Invalid value to resolve.\");\n\t}\n};\n", "import { Artifact } from \"./artifact.ts\";\nimport { assert, assert as assert_ } from \"./assert.ts\";\nimport { Blob } from \"./blob.ts\";\nimport { Directory } from \"./directory.ts\";\nimport { File } from \"./file.ts\";\nimport { Package } from \"./package.ts\";\nimport { Unresolved, resolve } from \"./resolve.ts\";\nimport { Symlink } from \"./symlink.ts\";\nimport { Target } from \"./target.ts\";\nimport { Template, template } from \"./template.ts\";\nimport { Value } from \"./value.ts\";\n\nexport type Args<T extends Value = Value> = Array<\n\tUnresolved<MaybeNestedArray<MaybeMutationMap<T>>>\n>;\n\nexport type MaybeMutationMap<T extends Value = Value> = T extends\n\t| undefined\n\t| boolean\n\t| number\n\t| string\n\t| Uint8Array\n\t| Blob\n\t| Directory\n\t| File\n\t| Symlink\n\t| Template\n\t| Mutation\n\t| Package\n\t| Target\n\t| Array<infer _U extends Value>\n\t? T\n\t: T extends { [key: string]: Value }\n\t? MutationMap<T>\n\t: never;\n\nexport type MutationMap<\n\tT extends { [key: string]: Value } = { [key: string]: Value },\n> = {\n\t[K in keyof T]?: MaybeMutation<T[K]>;\n};\n\nexport type MaybeMutation<T extends Value = Value> = T | Mutation<T>;\n\nexport type MaybeNestedArray<T> = T | Array<MaybeNestedArray<T>>;\n\nexport let apply = async <\n\tA extends Value = Value,\n\tR extends { [key: string]: Value } = { [key: string]: Value },\n>(\n\targs: Args<A>,\n\tmap: (\n\t\targ: Exclude<A, Array<Value>>,\n\t) => Promise<MaybeNestedArray<MutationMap<R>>>,\n): Promise<Partial<R>> => {\n\treturn flatten(\n\t\tawait Promise.all(\n\t\t\tflatten(await Promise.all(args.map(resolve))).map((arg) =>\n\t\t\t\tmap(arg as unknown as Exclude<A, Array<Value>>),\n\t\t\t),\n\t\t),\n\t).reduce(async (object, mutations) => {\n\t\tfor (let [key, mutation] of Object.entries(mutations)) {\n\t\t\tawait mutate(await object, key, mutation);\n\t\t}\n\t\treturn object;\n\t}, Promise.resolve({}));\n};\n\n/** Create a mutation. */\nexport async function mutation<T extends Value = Value>(\n\targ: Unresolved<Mutation.Arg<T>>,\n): Promise<Mutation<T>> {\n\treturn await Mutation.new(arg);\n}\n\nexport class Mutation<T extends Value = Value> {\n\t#inner: Mutation.Inner;\n\n\tconstructor(inner: Mutation.Inner) {\n\t\tthis.#inner = inner;\n\t}\n\n\tstatic async new<T extends Value = Value>(\n\t\tunresolvedArg: Unresolved<Mutation.Arg<T>>,\n\t): Promise<Mutation<T>> {\n\t\tlet arg = await resolve(unresolvedArg);\n\t\tif (arg.kind === \"array_prepend\" || arg.kind === \"array_append\") {\n\t\t\treturn new Mutation({ kind: arg.kind, value: flatten(arg.value) });\n\t\t} else if (\n\t\t\targ.kind === \"template_prepend\" ||\n\t\t\targ.kind === \"template_append\"\n\t\t) {\n\t\t\treturn new Mutation({\n\t\t\t\tkind: arg.kind,\n\t\t\t\tvalue: await template(arg.value),\n\t\t\t\tseparator: await template(arg.separator),\n\t\t\t});\n\t\t} else if (arg.kind === \"unset\") {\n\t\t\treturn new Mutation({ kind: \"unset\" });\n\t\t} else {\n\t\t\treturn new Mutation({ kind: arg.kind, value: arg.value });\n\t\t}\n\t}\n\n\t/** Check if a value is a `tg.Mutation`. */\n\tstatic is(value: unknown): value is Mutation {\n\t\treturn value instanceof Mutation;\n\t}\n\n\t/** Expect that a value is a `tg.Mutation`. */\n\tstatic expect(value: unknown): Mutation {\n\t\tassert_(Mutation.is(value));\n\t\treturn value;\n\t}\n\n\t/** Assert that a value is a `tg.Mutation`. */\n\tstatic assert(value: unknown): asserts value is Mutation {\n\t\tassert_(Mutation.is(value));\n\t}\n\n\tget inner() {\n\t\treturn this.#inner;\n\t}\n}\n\nexport namespace Mutation {\n\texport type Arg<T extends Value = Value> =\n\t\t| { kind: \"unset\" }\n\t\t| { kind: \"set\"; value: T }\n\t\t| { kind: \"set_if_unset\"; value: T }\n\t\t| {\n\t\t\t\tkind: \"array_prepend\";\n\t\t\t\tvalue: T extends Array<infer U> ? MaybeNestedArray<U> : never;\n\t\t  }\n\t\t| {\n\t\t\t\tkind: \"array_append\";\n\t\t\t\tvalue: T extends Array<infer U> ? MaybeNestedArray<U> : never;\n\t\t  }\n\t\t| {\n\t\t\t\tkind: \"template_prepend\";\n\t\t\t\tvalue: T extends Template.Arg ? Template.Arg : never;\n\t\t\t\tseparator?: Template.Arg;\n\t\t  }\n\t\t| {\n\t\t\t\tkind: \"template_append\";\n\t\t\t\tvalue: T extends Template.Arg ? Template.Arg : never;\n\t\t\t\tseparator?: Template.Arg;\n\t\t  };\n\n\texport type Inner =\n\t\t| { kind: \"unset\" }\n\t\t| { kind: \"set\"; value: Value }\n\t\t| { kind: \"set_if_unset\"; value: Value }\n\t\t| {\n\t\t\t\tkind: \"array_prepend\";\n\t\t\t\tvalue: Array<Value>;\n\t\t  }\n\t\t| {\n\t\t\t\tkind: \"array_append\";\n\t\t\t\tvalue: Array<Value>;\n\t\t  }\n\t\t| {\n\t\t\t\tkind: \"template_prepend\";\n\t\t\t\tvalue: Template;\n\t\t\t\tseparator: Template;\n\t\t  }\n\t\t| {\n\t\t\t\tkind: \"template_append\";\n\t\t\t\tvalue: Template;\n\t\t\t\tseparator: Template;\n\t\t  };\n}\n\nexport let flatten = <T>(value: MaybeNestedArray<T>): Array<T> => {\n\t// @ts-ignore\n\treturn value instanceof Array ? value.flat(Infinity) : [value];\n};\n\nlet mutate = async (\n\tobject: { [key: string]: Value },\n\tkey: string,\n\tmutation: MaybeMutation,\n) => {\n\tif (!(mutation instanceof Mutation)) {\n\t\tobject[key] = mutation;\n\t} else if (mutation.inner.kind === \"unset\") {\n\t\tdelete object[key];\n\t} else if (mutation.inner.kind === \"set\") {\n\t\tobject[key] = mutation.inner.value;\n\t} else if (mutation.inner.kind === \"set_if_unset\") {\n\t\tif (!(key in object)) {\n\t\t\tobject[key] = mutation.inner.value;\n\t\t}\n\t} else if (mutation.inner.kind === \"array_prepend\") {\n\t\tif (!(key in object)) {\n\t\t\tobject[key] = [];\n\t\t}\n\t\tlet array = object[key];\n\t\tassert(array instanceof Array);\n\t\tarray.unshift(...flatten(mutation.inner.value));\n\t} else if (mutation.inner.kind === \"array_append\") {\n\t\tif (!(key in object)) {\n\t\t\tobject[key] = [];\n\t\t}\n\t\tlet array = object[key];\n\t\tassert(array instanceof Array);\n\t\tarray.push(...flatten(mutation.inner.value));\n\t} else if (mutation.inner.kind === \"template_prepend\") {\n\t\tif (!(key in object)) {\n\t\t\tobject[key] = await template();\n\t\t}\n\t\tlet value = object[key];\n\t\tassert(\n\t\t\tvalue === undefined ||\n\t\t\t\ttypeof value === \"string\" ||\n\t\t\t\tArtifact.is(value) ||\n\t\t\t\tvalue instanceof Template,\n\t\t);\n\t\tobject[key] = await Template.join(\n\t\t\tmutation.inner.separator,\n\t\t\tmutation.inner.value,\n\t\t\tvalue,\n\t\t);\n\t} else if (mutation.inner.kind === \"template_append\") {\n\t\tif (!(key in object)) {\n\t\t\tobject[key] = await template();\n\t\t}\n\t\tlet value = object[key];\n\t\tassert(\n\t\t\tvalue === undefined ||\n\t\t\t\ttypeof value === \"string\" ||\n\t\t\t\tArtifact.is(value) ||\n\t\t\t\tvalue instanceof Template,\n\t\t);\n\t\tobject[key] = await Template.join(\n\t\t\tmutation.inner.separator,\n\t\t\tvalue,\n\t\t\tmutation.inner.value,\n\t\t);\n\t}\n};\n", "import { Artifact } from \"./artifact.ts\";\nimport { assert as assert_, unreachable } from \"./assert.ts\";\nimport { Checksum } from \"./checksum.ts\";\nimport * as encoding from \"./encoding.ts\";\nimport { Args, apply, mutation } from \"./mutation.ts\";\nimport { Object_ } from \"./object.ts\";\nimport * as syscall from \"./syscall.ts\";\n\nexport let blob = async (...args: Args<Blob.Arg>) => {\n\treturn await Blob.new(...args);\n};\n\nexport let download = async (\n\turl: string,\n\tchecksum: Checksum,\n): Promise<Blob> => {\n\treturn await Blob.download(url, checksum);\n};\n\nexport class Blob {\n\t#handle: Object_.Handle;\n\n\tconstructor(handle: Object_.Handle) {\n\t\tthis.#handle = handle;\n\t}\n\n\tstatic withId(id: Blob.Id): Blob {\n\t\treturn new Blob(Object_.Handle.withId(id));\n\t}\n\n\tstatic async new(...args: Args<Blob.Arg>): Promise<Blob> {\n\t\ttype Apply = { children: Array<Blob> };\n\t\tlet { children } = await apply<Blob.Arg, Apply>(args, async (arg) => {\n\t\t\tif (arg === undefined) {\n\t\t\t\treturn {};\n\t\t\t} else if (typeof arg === \"string\") {\n\t\t\t\tlet blob = new Blob(\n\t\t\t\t\tObject_.Handle.withObject({\n\t\t\t\t\t\tkind: \"blob\",\n\t\t\t\t\t\tvalue: encoding.utf8.encode(arg),\n\t\t\t\t\t}),\n\t\t\t\t);\n\t\t\t\treturn {\n\t\t\t\t\tchildren: await mutation({\n\t\t\t\t\t\tkind: \"array_append\" as const,\n\t\t\t\t\t\tvalue: [blob],\n\t\t\t\t\t}),\n\t\t\t\t};\n\t\t\t} else if (arg instanceof Uint8Array) {\n\t\t\t\tlet blob = new Blob(\n\t\t\t\t\tObject_.Handle.withObject({ kind: \"blob\", value: arg }),\n\t\t\t\t);\n\t\t\t\treturn {\n\t\t\t\t\tchildren: await mutation({\n\t\t\t\t\t\tkind: \"array_append\" as const,\n\t\t\t\t\t\tvalue: [blob],\n\t\t\t\t\t}),\n\t\t\t\t};\n\t\t\t} else if (Blob.is(arg)) {\n\t\t\t\treturn {\n\t\t\t\t\tchildren: await mutation({\n\t\t\t\t\t\tkind: \"array_append\" as const,\n\t\t\t\t\t\tvalue: [arg],\n\t\t\t\t\t}),\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\treturn unreachable();\n\t\t\t}\n\t\t});\n\t\tif (!children || children.length === 0) {\n\t\t\tlet blob = new Blob(\n\t\t\t\tObject_.Handle.withObject({ kind: \"blob\", value: new Uint8Array() }),\n\t\t\t);\n\t\t\tchildren = [blob];\n\t\t}\n\t\treturn new Blob(\n\t\t\tObject_.Handle.withObject({\n\t\t\t\tkind: \"blob\",\n\t\t\t\tvalue: await Promise.all(\n\t\t\t\t\tchildren.map<Promise<[Blob, number]>>(async (child) => {\n\t\t\t\t\t\treturn [child, await child.size()];\n\t\t\t\t\t}),\n\t\t\t\t),\n\t\t\t}),\n\t\t);\n\t}\n\n\tstatic async download(url: string, checksum: Checksum): Promise<Blob> {\n\t\treturn await syscall.download(url, checksum);\n\t}\n\n\tstatic is(value: unknown): value is Blob {\n\t\treturn value instanceof Blob;\n\t}\n\n\tstatic expect(value: unknown): Blob {\n\t\tassert_(Blob.is(value));\n\t\treturn value;\n\t}\n\n\tstatic assert(value: unknown): asserts value is Blob {\n\t\tassert_(Blob.is(value));\n\t}\n\n\tasync id(): Promise<Blob.Id> {\n\t\treturn (await this.#handle.id()) as Blob.Id;\n\t}\n\n\tasync object(): Promise<Blob.Object_> {\n\t\tlet object = await this.#handle.object();\n\t\tassert_(object.kind === \"blob\");\n\t\treturn object.value;\n\t}\n\n\tget handle(): Object_.Handle {\n\t\treturn this.#handle;\n\t}\n\n\tasync size(): Promise<number> {\n\t\tlet object = await this.object();\n\t\tif (object instanceof Array) {\n\t\t\treturn object.map(([_, size]) => size).reduce((a, b) => a + b, 0);\n\t\t} else {\n\t\t\treturn object.byteLength;\n\t\t}\n\t}\n\n\tasync bytes(): Promise<Uint8Array> {\n\t\treturn await syscall.read(this);\n\t}\n\n\tasync text(): Promise<string> {\n\t\treturn encoding.utf8.decode(await syscall.read(this));\n\t}\n\n\tasync decompress(format: Blob.CompressionFormat): Promise<Blob> {\n\t\treturn await syscall.decompress(this, format);\n\t}\n\n\tasync extract(format: Blob.ArchiveFormat): Promise<Artifact> {\n\t\treturn await syscall.extract(this, format);\n\t}\n}\n\nexport namespace Blob {\n\texport type Arg = undefined | string | Uint8Array | Blob | Array<Arg>;\n\n\texport type Id = string;\n\n\texport type Object_ = Array<[Blob, number]> | Uint8Array;\n\n\texport type ArchiveFormat = \".tar\" | \".zip\";\n\n\texport type CompressionFormat =\n\t\t| \".bz2\"\n\t\t| \".gz\"\n\t\t| \".lz\"\n\t\t| \".xz\"\n\t\t| \".zstd\"\n\t\t| \".zst\";\n}\n", "import { Artifact } from \"./artifact.ts\";\nimport { assert as assert_, unreachable } from \"./assert.ts\";\nimport { Blob } from \"./blob.ts\";\nimport { File, file } from \"./file.ts\";\nimport { Object_ } from \"./object.ts\";\nimport { Subpath, subpath } from \"./path.ts\";\nimport { Unresolved, resolve } from \"./resolve.ts\";\nimport { Symlink } from \"./symlink.ts\";\nimport * as syscall from \"./syscall.ts\";\n\nexport let directory = async (...args: Array<Unresolved<Directory.Arg>>) => {\n\treturn await Directory.new(...args);\n};\n\nexport class Directory {\n\t#handle: Object_.Handle;\n\n\tconstructor(handle: Object_.Handle) {\n\t\tthis.#handle = handle;\n\t}\n\n\tstatic withId(id: Directory.Id): Directory {\n\t\treturn new Directory(Object_.Handle.withId(id));\n\t}\n\n\tstatic async new(\n\t\t...args: Array<Unresolved<Directory.Arg>>\n\t): Promise<Directory> {\n\t\tlet entries = await (\n\t\t\tawait Promise.all(args.map(resolve))\n\t\t).reduce<Promise<Record<string, Artifact>>>(async function reduce(\n\t\t\tpromiseEntries,\n\t\t\targ,\n\t\t) {\n\t\t\tlet entries = await promiseEntries;\n\t\t\tif (arg === undefined) {\n\t\t\t\t// If the arg is undefined, then continue.\n\t\t\t} else if (Directory.is(arg)) {\n\t\t\t\t// If the arg is a directory, then apply each entry.\n\t\t\t\tfor (let [name, entry] of Object.entries(await arg.entries())) {\n\t\t\t\t\t// Get an existing entry.\n\t\t\t\t\tlet existingEntry = entries[name];\n\n\t\t\t\t\t// Merge the existing entry with the entry if they are both directories.\n\t\t\t\t\tif (Directory.is(existingEntry) && Directory.is(entry)) {\n\t\t\t\t\t\tentry = await Directory.new(existingEntry, entry);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Set the entry.\n\t\t\t\t\tentries[name] = entry;\n\t\t\t\t}\n\t\t\t} else if (arg instanceof Array) {\n\t\t\t\tfor (let argEntry of arg) {\n\t\t\t\t\tentries = await reduce(Promise.resolve(entries), argEntry);\n\t\t\t\t}\n\t\t\t} else if (typeof arg === \"object\") {\n\t\t\t\t// If the arg is an object, then apply each entry.\n\t\t\t\tfor (let [key, value] of Object.entries(arg)) {\n\t\t\t\t\t// Separate the first path component from the trailing path components.\n\t\t\t\t\tlet [firstComponent, ...trailingComponents] =\n\t\t\t\t\t\tsubpath(key).components();\n\t\t\t\t\tif (firstComponent === undefined) {\n\t\t\t\t\t\tthrow new Error(\"The path must have at least one component.\");\n\t\t\t\t\t}\n\t\t\t\t\tlet name = firstComponent;\n\n\t\t\t\t\t// Get an existing entry.\n\t\t\t\t\tlet existingEntry = entries[name];\n\n\t\t\t\t\t// Remove the entry if it is not a directory.\n\t\t\t\t\tif (!Directory.is(existingEntry)) {\n\t\t\t\t\t\texistingEntry = undefined;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (trailingComponents.length > 0) {\n\t\t\t\t\t\t// If there are trailing path components, then recurse.\n\t\t\t\t\t\tlet trailingPath = subpath(trailingComponents).toString();\n\n\t\t\t\t\t\t// Merge the entry with the trailing path.\n\t\t\t\t\t\tlet newEntry = await Directory.new(existingEntry, {\n\t\t\t\t\t\t\t[trailingPath]: value,\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\t// Add the entry.\n\t\t\t\t\t\tentries[name] = newEntry;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// If there are no trailing path components, then create the artifact specified by the value.\n\t\t\t\t\t\tif (value === undefined) {\n\t\t\t\t\t\t\tdelete entries[name];\n\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\ttypeof value === \"string\" ||\n\t\t\t\t\t\t\tvalue instanceof Uint8Array ||\n\t\t\t\t\t\t\tvalue instanceof Blob\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tlet newEntry = await file(value);\n\t\t\t\t\t\t\tentries[name] = newEntry;\n\t\t\t\t\t\t} else if (File.is(value) || Symlink.is(value)) {\n\t\t\t\t\t\t\tentries[name] = value;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tentries[name] = await Directory.new(existingEntry, value);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn unreachable();\n\t\t\t}\n\t\t\treturn entries;\n\t\t}, Promise.resolve({}));\n\t\treturn new Directory(\n\t\t\tObject_.Handle.withObject({ kind: \"directory\", value: { entries } }),\n\t\t);\n\t}\n\n\tstatic is(value: unknown): value is Directory {\n\t\treturn value instanceof Directory;\n\t}\n\n\tstatic expect(value: unknown): Directory {\n\t\tassert_(Directory.is(value));\n\t\treturn value;\n\t}\n\n\tstatic assert(value: unknown): asserts value is Directory {\n\t\tassert_(Directory.is(value));\n\t}\n\n\tasync id(): Promise<Directory.Id> {\n\t\treturn (await this.#handle.id()) as Directory.Id;\n\t}\n\n\tasync object(): Promise<Directory.Object_> {\n\t\tlet object = await this.#handle.object();\n\t\tassert_(object.kind === \"directory\");\n\t\treturn object.value;\n\t}\n\n\tget handle(): Object_.Handle {\n\t\treturn this.#handle;\n\t}\n\n\tasync get(arg: string): Promise<Directory | File> {\n\t\tlet artifact = await this.tryGet(arg);\n\t\tassert_(artifact, `Failed to get the directory entry \"${arg}\".`);\n\t\treturn artifact;\n\t}\n\n\tasync tryGet(arg: string): Promise<Directory | File | undefined> {\n\t\tlet artifact: Directory | File = this;\n\t\tlet currentSubpath = subpath();\n\t\tfor (let component of subpath(arg).components()) {\n\t\t\tif (!Directory.is(artifact)) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\tcurrentSubpath.push(component);\n\t\t\tlet entry: Artifact | undefined = (await artifact.entries())[component];\n\t\t\tif (entry === undefined) {\n\t\t\t\treturn undefined;\n\t\t\t} else if (Symlink.is(entry)) {\n\t\t\t\tlet resolved = await entry.resolve({\n\t\t\t\t\tartifact: this,\n\t\t\t\t\tpath: currentSubpath.toString(),\n\t\t\t\t});\n\t\t\t\tif (resolved === undefined) {\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\t\t\t\tartifact = resolved;\n\t\t\t} else {\n\t\t\t\tartifact = entry;\n\t\t\t}\n\t\t}\n\t\treturn artifact;\n\t}\n\n\tasync entries(): Promise<Record<string, Artifact>> {\n\t\tlet entries: Record<string, Artifact> = {};\n\t\tfor await (let [name, artifact] of this) {\n\t\t\tentries[name] = artifact;\n\t\t}\n\t\treturn entries;\n\t}\n\n\tasync bundle(): Promise<Directory> {\n\t\treturn await syscall.bundle(this);\n\t}\n\n\tasync *walk(): AsyncIterableIterator<[Subpath, Artifact]> {\n\t\tfor await (let [name, artifact] of this) {\n\t\t\tyield [subpath(name), artifact];\n\t\t\tif (Directory.is(artifact)) {\n\t\t\t\tfor await (let [entryName, entryArtifact] of artifact.walk()) {\n\t\t\t\t\tyield [subpath(name).join(entryName), entryArtifact];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tasync *[Symbol.asyncIterator](): AsyncIterator<[string, Artifact]> {\n\t\tlet object = await this.object();\n\t\tfor (let [name, artifact] of Object.entries(object.entries)) {\n\t\t\tyield [name, artifact];\n\t\t}\n\t}\n}\n\nexport namespace Directory {\n\texport type Arg = undefined | Directory | ArgObject | Array<Arg>;\n\n\ttype ArgObject = {\n\t\t[name: string]:\n\t\t\t| undefined\n\t\t\t| string\n\t\t\t| Uint8Array\n\t\t\t| Blob\n\t\t\t| Artifact\n\t\t\t| ArgObject;\n\t};\n\n\texport type Id = string;\n\n\texport type Object_ = {\n\t\tentries: Record<string, Artifact>;\n\t};\n}\n", "import { assert as assert_ } from \"./assert.ts\";\nimport { Directory } from \"./directory.ts\";\nimport { File } from \"./file.ts\";\nimport { Symlink } from \"./symlink.ts\";\n\nexport type Artifact = Directory | File | Symlink;\n\nexport namespace Artifact {\n\texport type Id = string;\n\n\texport let is = (value: unknown): value is Artifact => {\n\t\treturn Directory.is(value) || File.is(value) || Symlink.is(value);\n\t};\n\n\texport let expect = (value: unknown): Artifact => {\n\t\tassert_(is(value));\n\t\treturn value;\n\t};\n\n\texport let assert = (value: unknown): asserts value is Artifact => {\n\t\tassert_(is(value));\n\t};\n}\n", "export class Error {\n\tmessage: string;\n\tlocation: Location | undefined;\n\tstack: Array<Location> | undefined;\n\tsource: Error | undefined;\n\n\tconstructor(\n\t\tmessage: string,\n\t\tlocation?: Location,\n\t\tstack?: Array<Location>,\n\t\tsource?: Error,\n\t) {\n\t\tthis.message = message;\n\t\tthis.location = location;\n\t\tthis.stack = stack;\n\t\tthis.source = source;\n\t}\n}\n\ntype Location = { source: string; line: number; column: number };\n\n/** This type is derived from <https://v8.dev/docs/stack-trace-api#customizing-stack-traces>. */\ntype CallSite = {\n\tgetTypeName(): string;\n\tgetFunctionName(): string;\n\tgetMethodName(): string;\n\tgetFileName(): string | undefined;\n\tgetLineNumber(): number | undefined;\n\tgetColumnNumber(): number | undefined;\n\tgetEvalOrigin(): unknown | undefined;\n\tisEval(): boolean;\n\tisNative(): boolean;\n\tisConstructor(): boolean;\n\tisAsync(): boolean;\n\tisPromiseAll(): boolean;\n\t// isPromiseAny(): boolean;\n\tgetPromiseIndex(): number | null;\n};\n\nexport let prepareStackTrace = (\n\t_error: unknown,\n\tstructuredStackTrace: Array<CallSite>,\n) => {\n\tlet callSites = structuredStackTrace.map((callSite) => {\n\t\treturn {\n\t\t\ttypeName: callSite.getTypeName(),\n\t\t\tfunctionName: callSite.getFunctionName(),\n\t\t\tmethodName: callSite.getMethodName(),\n\t\t\tfileName: callSite.getFileName(),\n\t\t\tlineNumber: callSite.getLineNumber(),\n\t\t\tcolumnNumber: callSite.getColumnNumber(),\n\t\t\tisEval: callSite.isEval(),\n\t\t\tisNative: callSite.isNative(),\n\t\t\tisConstructor: callSite.isConstructor(),\n\t\t\tisAsync: callSite.isAsync(),\n\t\t\tisPromiseAll: callSite.isPromiseAll(),\n\t\t\t// isPromiseAny: callSite.isPromiseAny(),\n\t\t\tpromiseIndex: callSite.getPromiseIndex(),\n\t\t};\n\t});\n\treturn { callSites };\n};\n", "import { Artifact } from \"./artifact.ts\";\nimport { assert } from \"./assert.ts\";\nimport { Directory } from \"./directory.ts\";\nimport { Module } from \"./module.ts\";\nimport { Package } from \"./package.ts\";\nimport { Relpath, subpath } from \"./path.ts\";\n\ntype Arg = {\n\turl: string;\n\tpath: Relpath.Arg;\n};\n\nexport let include = async (arg: Arg): Promise<Artifact> => {\n\tlet module_ = Module.fromUrl(arg.url);\n\tassert(module_.kind === \"normal\");\n\tlet package_ = Package.withId(module_.value.packageId);\n\tlet artifact = await package_.artifact();\n\tDirectory.assert(artifact);\n\tlet path = subpath(module_.value.path)\n\t\t.toRelpath()\n\t\t.parent()\n\t\t.join(arg.path)\n\t\t.toSubpath()\n\t\t.toString();\n\tlet includedArtifact = await artifact.get(path);\n\treturn includedArtifact;\n};\n", "import { unreachable } from \"./assert.ts\";\nimport { Blob } from \"./blob.ts\";\nimport { Directory } from \"./directory.ts\";\nimport * as encoding from \"./encoding.ts\";\nimport { File } from \"./file.ts\";\nimport { Mutation } from \"./mutation.ts\";\nimport { Object_ } from \"./object.ts\";\nimport { Package } from \"./package.ts\";\nimport { Symlink } from \"./symlink.ts\";\nimport * as syscall from \"./syscall.ts\";\nimport { Target } from \"./target.ts\";\nimport { Template } from \"./template.ts\";\n\nexport let log = (...args: Array<unknown>) => {\n\tlet string = args.map((arg) => stringify(arg)).join(\" \") + \"\\n\";\n\tsyscall.log(string);\n};\n\nlet stringify = (value: unknown): string => {\n\treturn stringifyInner(value, new WeakSet());\n};\n\nlet stringifyInner = (value: unknown, visited: WeakSet<object>): string => {\n\tswitch (typeof value) {\n\t\tcase \"string\": {\n\t\t\treturn `\"${value}\"`;\n\t\t}\n\t\tcase \"number\": {\n\t\t\treturn value.toString();\n\t\t}\n\t\tcase \"boolean\": {\n\t\t\treturn value ? \"true\" : \"false\";\n\t\t}\n\t\tcase \"undefined\": {\n\t\t\treturn \"undefined\";\n\t\t}\n\t\tcase \"object\": {\n\t\t\tif (value === null) {\n\t\t\t\treturn \"null\";\n\t\t\t} else {\n\t\t\t\treturn stringifyObject(value, visited);\n\t\t\t}\n\t\t}\n\t\tcase \"function\": {\n\t\t\tif (Target.is(value)) {\n\t\t\t\treturn stringifyObject(value, visited);\n\t\t\t} else {\n\t\t\t\treturn `(function \"${value.name ?? \"(anonymous)\"}\")`;\n\t\t\t}\n\t\t}\n\t\tcase \"symbol\": {\n\t\t\treturn \"(symbol)\";\n\t\t}\n\t\tcase \"bigint\": {\n\t\t\treturn value.toString();\n\t\t}\n\t}\n};\n\nlet stringifyObject = (value: object, visited: WeakSet<object>): string => {\n\tif (visited.has(value)) {\n\t\treturn \"(circular)\";\n\t}\n\tvisited.add(value);\n\tif (value instanceof Array) {\n\t\treturn `[${value\n\t\t\t.map((value) => stringifyInner(value, visited))\n\t\t\t.join(\", \")}]`;\n\t} else if (value instanceof Uint8Array) {\n\t\tlet bytes = encoding.hex.encode(value);\n\t\treturn `(tg.bytes ${bytes})`;\n\t} else if (value instanceof Error) {\n\t\treturn value.message;\n\t} else if (value instanceof Promise) {\n\t\treturn \"(promise)\";\n\t} else if (Blob.is(value)) {\n\t\tlet handle = stringifyHandle(value.handle, visited);\n\t\treturn `(tg.blob ${handle})`;\n\t} else if (Directory.is(value)) {\n\t\tlet handle = stringifyHandle(value.handle, visited);\n\t\treturn `(tg.directory ${handle})`;\n\t} else if (File.is(value)) {\n\t\tlet handle = stringifyHandle(value.handle, visited);\n\t\treturn `(tg.file ${handle})`;\n\t} else if (Symlink.is(value)) {\n\t\tlet handle = stringifyHandle(value.handle, visited);\n\t\treturn `(tg.symlink ${handle})`;\n\t} else if (Template.is(value)) {\n\t\tlet string = value.components\n\t\t\t.map((component) => {\n\t\t\t\tif (typeof component === \"string\") {\n\t\t\t\t\treturn component;\n\t\t\t\t} else {\n\t\t\t\t\treturn `\\${${stringifyInner(component, visited)}}`;\n\t\t\t\t}\n\t\t\t})\n\t\t\t.join(\"\");\n\t\treturn `\\`${string}\\``;\n\t} else if (Mutation.is(value)) {\n\t\treturn `(tg.mutation ${stringifyObject(value.inner, visited)})`;\n\t} else if (Package.is(value)) {\n\t\tlet handle = stringifyHandle(value.handle, visited);\n\t\treturn `(tg.package ${handle})`;\n\t} else if (Target.is(value)) {\n\t\tlet handle = stringifyHandle(value.handle, visited);\n\t\treturn `(tg.target ${handle})`;\n\t} else {\n\t\tlet constructorName = \"\";\n\t\tif (\n\t\t\tvalue.constructor !== undefined &&\n\t\t\tvalue.constructor.name !== \"Object\"\n\t\t) {\n\t\t\tconstructorName = `${value.constructor.name} `;\n\t\t}\n\t\tlet entries = Object.entries(value).map(\n\t\t\t([key, value]) => `${key}: ${stringifyInner(value, visited)}`,\n\t\t);\n\t\tlet space = entries.length > 0 ? \" \" : \"\";\n\t\treturn `${constructorName}{${space}${entries.join(\", \")}${space}}`;\n\t}\n};\n\nlet stringifyHandle = (\n\thandle: Object_.Handle,\n\tvisited: WeakSet<object>,\n): string => {\n\tlet { id, object } = handle.state;\n\tif (id !== undefined) {\n\t\treturn id;\n\t}\n\tif (object !== undefined) {\n\t\treturn stringifyObject(object.value, visited);\n\t}\n\treturn unreachable();\n};\n", "import { assert } from \"./assert.ts\";\nimport * as encoding from \"./encoding.ts\";\nimport { Module } from \"./module.ts\";\nimport { Target, functions, setCurrent } from \"./target.ts\";\nimport { Value } from \"./value.ts\";\n\nexport let main = async (target: Target): Promise<Value> => {\n\t// Load the executable.\n\tlet package_ = await target.package();\n\tassert(package_);\n\tlet packageId = await package_.id();\n\tlet executable = await target.executable();\n\tlet path = executable.components[0];\n\tassert(typeof path === \"string\");\n\tlet module_ = {\n\t\tkind: \"normal\" as const,\n\t\tvalue: { packageId, path },\n\t};\n\tlet url = Module.toUrl(module_);\n\tawait import(url);\n\n\t// Get the target.\n\tlet name = await target.name_();\n\tif (!name) {\n\t\tthrow new Error(\"The target must have a name.\");\n\t}\n\n\t// Get the function.\n\tlet key = encoding.json.encode({ url, name });\n\tlet function_ = functions[key];\n\tif (!function_) {\n\t\tthrow new Error(\"Failed to find the function.\");\n\t}\n\n\t// Set the current target.\n\tsetCurrent(target);\n\n\t// Get the args.\n\tlet args = await target.args();\n\n\t// Call the function.\n\tlet output = await function_(...args);\n\n\treturn output;\n};\n", "import * as syscall from \"./syscall.ts\";\n\nexport let sleep = async (duration: number) => {\n\treturn await syscall.sleep(duration);\n};\n", "import { assert as assert_ } from \"./assert.ts\";\n\nexport let system = (arg: System.Arg): System => {\n\tif (typeof arg === \"string\") {\n\t\treturn arg;\n\t} else {\n\t\tlet { arch, os } = arg;\n\t\treturn `${arch}-${os}` as System;\n\t}\n};\n\nexport type System =\n\t| \"aarch64-darwin\"\n\t| \"aarch64-linux\"\n\t| \"js-js\"\n\t| \"x86_64-darwin\"\n\t| \"x86_64-linux\";\n\nexport declare namespace System {\n\tlet new_: (arg: System.Arg) => System;\n\texport { new_ as new };\n}\n\nexport namespace System {\n\texport type Arg = System | ArgObject;\n\n\texport type ArgObject = {\n\t\tarch: Arch;\n\t\tos: Os;\n\t};\n\n\texport type Arch = \"aarch64\" | \"js\" | \"x86_64\";\n\n\texport type Os = \"darwin\" | \"js\" | \"linux\";\n\texport let new_ = (arg: System.Arg): System => {\n\t\treturn system(arg);\n\t};\n\tSystem.new = new_;\n\n\texport let is = (value: unknown): value is System => {\n\t\treturn (\n\t\t\tvalue === \"aarch64-darwin\" ||\n\t\t\tvalue === \"aarch64-linux\" ||\n\t\t\tvalue === \"js-js\" ||\n\t\t\tvalue === \"x86_64-darwin\" ||\n\t\t\tvalue === \"x86_64-linux\"\n\t\t);\n\t};\n\n\texport let expect = (value: unknown): System => {\n\t\tassert_(System.is(value));\n\t\treturn value;\n\t};\n\n\texport let assert = (value: unknown): asserts value is System => {\n\t\tassert_(System.is(value));\n\t};\n\n\texport let arch = (system: System): Arch => {\n\t\tswitch (system) {\n\t\t\tcase \"aarch64-darwin\":\n\t\t\tcase \"aarch64-linux\": {\n\t\t\t\treturn \"aarch64\";\n\t\t\t}\n\t\t\tcase \"js-js\": {\n\t\t\t\treturn \"js\";\n\t\t\t}\n\t\t\tcase \"x86_64-linux\":\n\t\t\tcase \"x86_64-darwin\": {\n\t\t\t\treturn \"x86_64\";\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\tthrow new Error(\"Invalid system.\");\n\t\t\t}\n\t\t}\n\t};\n\n\texport let os = (system: System): Os => {\n\t\tswitch (system) {\n\t\t\tcase \"aarch64-darwin\":\n\t\t\tcase \"x86_64-darwin\": {\n\t\t\t\treturn \"darwin\";\n\t\t\t}\n\t\t\tcase \"js-js\": {\n\t\t\t\treturn \"js\";\n\t\t\t}\n\t\t\tcase \"x86_64-linux\":\n\t\t\tcase \"aarch64-linux\": {\n\t\t\t\treturn \"linux\";\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\tthrow new Error(\"Invalid system.\");\n\t\t\t}\n\t\t}\n\t};\n}\n", "import { assert as assert_ } from \"./assert.ts\";\nimport { Blob } from \"./blob.ts\";\nimport { Directory } from \"./directory.ts\";\nimport { File } from \"./file.ts\";\nimport { Mutation } from \"./mutation.ts\";\nimport { Package } from \"./package.ts\";\nimport { Symlink } from \"./symlink.ts\";\nimport { Target } from \"./target.ts\";\nimport { Template } from \"./template.ts\";\n\nexport type Value =\n\t| undefined\n\t| boolean\n\t| number\n\t| string\n\t| Uint8Array\n\t| Blob\n\t| Directory\n\t| File\n\t| Symlink\n\t| Template\n\t| Mutation\n\t| Package\n\t| Target\n\t| Array<Value>\n\t| { [key: string]: Value };\n\nexport namespace Value {\n\texport let is = (value: unknown): value is Value => {\n\t\treturn (\n\t\t\tvalue === undefined ||\n\t\t\ttypeof value === \"boolean\" ||\n\t\t\ttypeof value === \"number\" ||\n\t\t\ttypeof value === \"string\" ||\n\t\t\tvalue instanceof Uint8Array ||\n\t\t\tvalue instanceof Blob ||\n\t\t\tvalue instanceof Directory ||\n\t\t\tvalue instanceof File ||\n\t\t\tvalue instanceof Symlink ||\n\t\t\tvalue instanceof Template ||\n\t\t\tvalue instanceof Package ||\n\t\t\tvalue instanceof Target ||\n\t\t\tvalue instanceof Array ||\n\t\t\ttypeof value === \"object\"\n\t\t);\n\t};\n\n\texport let expect = (value: unknown): Value => {\n\t\tassert_(is(value));\n\t\treturn value;\n\t};\n\n\texport let assert = (value: unknown): asserts value is Value => {\n\t\tassert_(is(value));\n\t};\n}\n", "import { Artifact } from \"./artifact.ts\";\nimport { assert, unimplemented, unreachable } from \"./assert.ts\";\nimport { Blob, blob, download } from \"./blob.ts\";\nimport { Directory, directory } from \"./directory.ts\";\nimport * as encoding from \"./encoding.ts\";\nimport { Error as Error_, prepareStackTrace } from \"./error.ts\";\nimport { File, file } from \"./file.ts\";\nimport { include } from \"./include.ts\";\nimport { log } from \"./log.ts\";\nimport { main } from \"./main.ts\";\nimport { Args, Mutation, apply, mutation } from \"./mutation.ts\";\nimport { Object_ } from \"./object.ts\";\nimport { Package } from \"./package.ts\";\nimport { resolve } from \"./resolve.ts\";\nimport { sleep } from \"./sleep.ts\";\nimport { Symlink, symlink } from \"./symlink.ts\";\nimport { System, system } from \"./system.ts\";\nimport { Target, build, getCurrent, target } from \"./target.ts\";\nimport { Template, template } from \"./template.ts\";\nimport { Value } from \"./value.ts\";\n\nObject.defineProperties(Error, {\n\tprepareStackTrace: { value: prepareStackTrace },\n});\n\nObject.defineProperties(globalThis, {\n\tconsole: { value: { log } },\n});\n\nasync function tg(\n\tstrings: TemplateStringsArray,\n\t...placeholders: Args<Template.Arg>\n): Promise<Template> {\n\tlet components: Args<Template.Arg> = [];\n\tfor (let i = 0; i < strings.length - 1; i++) {\n\t\tlet string = strings[i]!;\n\t\tcomponents.push(string);\n\t\tlet placeholder = placeholders[i]!;\n\t\tcomponents.push(placeholder);\n\t}\n\tcomponents.push(strings[strings.length - 1]!);\n\treturn await template(...components);\n}\n\nObject.assign(tg, {\n\tArtifact,\n\tBlob,\n\tDirectory,\n\tError: Error_,\n\tFile,\n\tMutation,\n\tObject_,\n\tPackage,\n\tSymlink,\n\tSystem,\n\tTarget,\n\tTemplate,\n\tValue,\n\tapply,\n\tassert,\n\tblob,\n\tbuild,\n\tdirectory,\n\tdownload,\n\tencoding,\n\tfile,\n\tinclude,\n\tlog,\n\tmain,\n\tmutation,\n\tresolve,\n\tsleep,\n\tsymlink,\n\tsystem,\n\ttarget,\n\ttemplate,\n\tunimplemented,\n\tunreachable,\n});\n\nObject.defineProperties(tg, {\n\tcurrent: { get: getCurrent },\n});\n\nObject.defineProperties(globalThis, {\n\ttg: { value: tg },\n});\n"],
  "mappings": "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",
  "names": ["assert", "condition", "message", "unimplemented", "unreachable", "encoding_exports", "__export", "base64", "hex", "json", "toml", "utf8", "yaml", "build", "target", "cause", "bundle", "artifact", "decompress", "blob", "format", "cause", "download", "url", "checksum", "encoding", "value", "extract", "log", "read", "blob", "cause", "sleep", "duration", "cause", "base64", "value", "encoding", "hex", "json", "toml", "utf8", "yaml", "Object_", "Handle", "#state", "state", "id", "object", "file", "args", "File", "_File", "#handle", "handle", "id", "Object_", "contents_", "executable_", "references_", "apply", "arg", "Blob", "mutation", "unreachable", "contents", "blob", "executable", "references", "value", "assert", "object", "Package", "_Package", "#handle", "handle", "id", "Object_", "value", "assert", "object", "relpath", "args", "Relpath", "subpath", "Subpath", "_Relpath", "#parents", "#subpath", "arg", "reduce", "path", "component", "i", "unreachable", "other", "string", "Arg", "value", "assert", "#components", "components", "template", "args", "Template", "_Template", "#components", "components", "apply", "arg", "Artifact", "mutation", "unreachable", "component", "lastComponent", "value", "assert", "separator", "separatorTemplate", "argTemplates", "templates", "argTemplate", "symlink", "args", "Symlink", "_Symlink", "#handle", "handle", "id", "Object_", "artifact", "path_", "apply", "arg", "mutation", "Artifact", "Template", "assert", "firstComponent", "secondComponent", "unreachable", "path", "relpath", "target", "template", "value", "object", "from", "fromArtifact", "fromPath", "Directory", "Module", "module", "encoding", "url", "match", "assert", "_", "data", "current", "getCurrent", "setCurrent", "target", "functions", "args", "arg", "url", "name", "key", "json", "assert", "module_", "Module", "package_", "Package", "Target", "Object_", "Template", "build", "_Target", "#handle", "handle", "this_", "_target", "prop", "_receiver", "_", "resolve", "id", "host", "executable_", "env_", "args_", "checksum", "unsafe_", "apply", "Artifact", "mutation", "unreachable", "executable", "template", "env", "flatten", "value", "object", "resolve", "value", "Blob", "Directory", "File", "Symlink", "Template", "Mutation", "Package", "Target", "key", "apply", "args", "map", "flatten", "resolve", "arg", "object", "mutations", "key", "mutation", "mutate", "Mutation", "_Mutation", "#inner", "inner", "unresolvedArg", "template", "value", "assert", "array", "Artifact", "Template", "blob", "args", "Blob", "download", "url", "checksum", "_Blob", "#handle", "handle", "id", "Object_", "children", "apply", "arg", "utf8", "mutation", "unreachable", "child", "value", "assert", "object", "_", "size", "a", "b", "read", "format", "decompress", "extract", "directory", "args", "Directory", "_Directory", "#handle", "handle", "id", "Object_", "entries", "resolve", "reduce", "promiseEntries", "arg", "name", "entry", "existingEntry", "argEntry", "key", "value", "firstComponent", "trailingComponents", "subpath", "trailingPath", "newEntry", "Blob", "file", "File", "Symlink", "unreachable", "assert", "object", "artifact", "currentSubpath", "component", "resolved", "bundle", "entryName", "entryArtifact", "Artifact", "value", "Directory", "File", "Symlink", "assert", "Error", "message", "location", "stack", "source", "prepareStackTrace", "_error", "structuredStackTrace", "callSite", "include", "arg", "module_", "Module", "assert", "artifact", "Package", "Directory", "path", "subpath", "log", "args", "string", "arg", "stringify", "value", "stringifyInner", "visited", "stringifyObject", "Target", "hex", "Blob", "stringifyHandle", "Directory", "File", "Symlink", "Template", "component", "Mutation", "Package", "constructorName", "entries", "key", "space", "handle", "id", "object", "unreachable", "main", "target", "package_", "assert", "packageId", "path", "module_", "url", "Module", "name", "key", "json", "function_", "functions", "setCurrent", "args", "sleep", "duration", "system", "arg", "arch", "os", "System", "value", "assert", "Value", "value", "Blob", "Directory", "File", "Symlink", "Template", "Package", "Target", "assert", "prepareStackTrace", "log", "tg", "strings", "placeholders", "components", "i", "string", "placeholder", "template", "Artifact", "Blob", "Directory", "Error", "File", "Mutation", "Object_", "Package", "Symlink", "System", "Target", "Template", "Value", "apply", "assert", "blob", "build", "directory", "download", "encoding_exports", "file", "include", "main", "mutation", "resolve", "sleep", "symlink", "system", "target", "unimplemented", "unreachable", "getCurrent"]
}
