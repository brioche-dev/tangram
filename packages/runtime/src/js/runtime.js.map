{
  "version": 3,
  "sources": ["assert.ts", "encoding.ts", "syscall.ts", "file.ts", "leaf.ts", "package.ts", "path.ts", "template.ts", "symlink.ts", "module.ts", "target.ts", "resolve.ts", "mutation.ts", "branch.ts", "blob.ts", "directory.ts", "artifact.ts", "error.ts", "include.ts", "log.ts", "main.ts", "sleep.ts", "system.ts", "value.ts", "runtime.ts"],
  "sourcesContent": ["export let assert: (\n\tcondition: unknown,\n\tmessage?: string,\n) => asserts condition = (condition, message) => {\n\tif (!condition) {\n\t\tthrow new Error(message ?? \"Failed assertion.\");\n\t}\n};\n\nexport let unimplemented = (message?: string): never => {\n\tthrow new Error(message ?? \"Reached unimplemented code.\");\n};\n\nexport let unreachable = (message?: string): never => {\n\tthrow new Error(message ?? \"Reached unreachable code.\");\n};\n\nexport let todo = (): never => {\n\tthrow new Error(\"Reached todo.\");\n};\n", "import * as syscall from \"./syscall.ts\";\n\nexport namespace base64 {\n\texport let decode = (value: string): Uint8Array => {\n\t\treturn syscall.encoding.base64.decode(value);\n\t};\n\n\texport let encode = (value: Uint8Array): string => {\n\t\treturn syscall.encoding.base64.encode(value);\n\t};\n}\n\nexport namespace hex {\n\texport let decode = (value: string): Uint8Array => {\n\t\treturn syscall.encoding.hex.decode(value);\n\t};\n\n\texport let encode = (value: Uint8Array): string => {\n\t\treturn syscall.encoding.hex.encode(value);\n\t};\n}\n\nexport namespace json {\n\texport let decode = (value: string): unknown => {\n\t\treturn syscall.encoding.json.decode(value);\n\t};\n\n\texport let encode = (value: any): string => {\n\t\treturn syscall.encoding.json.encode(value);\n\t};\n}\n\nexport namespace toml {\n\texport let decode = (value: string): unknown => {\n\t\treturn syscall.encoding.toml.decode(value);\n\t};\n\n\texport let encode = (value: any): string => {\n\t\treturn syscall.encoding.toml.encode(value);\n\t};\n}\n\nexport namespace utf8 {\n\texport let decode = (value: Uint8Array): string => {\n\t\treturn syscall.encoding.utf8.decode(value);\n\t};\n\n\texport let encode = (value: string): Uint8Array => {\n\t\treturn syscall.encoding.utf8.encode(value);\n\t};\n}\n\nexport namespace yaml {\n\texport let decode = (value: string): unknown => {\n\t\treturn syscall.encoding.yaml.decode(value);\n\t};\n\n\texport let encode = (value: any): string => {\n\t\treturn syscall.encoding.yaml.encode(value);\n\t};\n}\n", "import { Artifact } from \"./artifact.ts\";\nimport { Blob } from \"./blob.ts\";\nimport { Checksum } from \"./checksum.ts\";\nimport { Directory } from \"./directory.ts\";\nimport { Object_ } from \"./object.ts\";\nimport { Target } from \"./target.ts\";\nimport { Value } from \"./value.ts\";\n\ndeclare global {\n\tfunction syscall(\n\t\tsyscall: \"archive\",\n\t\tartifact: Artifact,\n\t\tformat: Blob.ArchiveFormat,\n\t): Promise<Blob>;\n\n\tfunction syscall(syscall: \"build\", target: Target): Promise<Value>;\n\n\tfunction syscall(syscall: \"bundle\", artifact: Artifact): Promise<Directory>;\n\n\tfunction syscall(\n\t\tsyscall: \"checksum\",\n\t\talgorithm: Checksum.Algorithm,\n\t\tbytes: string | Uint8Array,\n\t): Checksum;\n\n\tfunction syscall(\n\t\tsyscall: \"compress\",\n\t\tblob: Blob,\n\t\tformat: Blob.CompressionFormat,\n\t): Promise<Blob>;\n\n\tfunction syscall(\n\t\tsyscall: \"decompress\",\n\t\tblob: Blob,\n\t\tformat: Blob.CompressionFormat,\n\t): Promise<Blob>;\n\n\tfunction syscall(\n\t\tsyscall: \"download\",\n\t\turl: string,\n\t\tchecksum: Checksum,\n\t): Promise<Blob>;\n\n\tfunction syscall(\n\t\tsyscall: \"encoding_base64_decode\",\n\t\tvalue: string,\n\t): Uint8Array;\n\n\tfunction syscall(\n\t\tsyscall: \"encoding_base64_encode\",\n\t\tvalue: Uint8Array,\n\t): string;\n\n\tfunction syscall(syscall: \"encoding_hex_decode\", value: string): Uint8Array;\n\n\tfunction syscall(syscall: \"encoding_hex_encode\", value: Uint8Array): string;\n\n\tfunction syscall(syscall: \"encoding_json_decode\", value: string): unknown;\n\n\tfunction syscall(syscall: \"encoding_json_encode\", value: any): string;\n\n\tfunction syscall(syscall: \"encoding_toml_decode\", value: string): unknown;\n\n\tfunction syscall(syscall: \"encoding_toml_encode\", value: any): string;\n\n\tfunction syscall(syscall: \"encoding_utf8_decode\", value: Uint8Array): string;\n\n\tfunction syscall(syscall: \"encoding_utf8_encode\", value: string): Uint8Array;\n\n\tfunction syscall(syscall: \"encoding_yaml_decode\", value: string): unknown;\n\n\tfunction syscall(syscall: \"encoding_yaml_encode\", value: any): string;\n\n\tfunction syscall(\n\t\tsyscall: \"extract\",\n\t\tblob: Blob,\n\t\tformat: Blob.ArchiveFormat,\n\t): Promise<Artifact>;\n\n\tfunction syscall(syscall: \"load\", id: Object_.Id): Promise<Object_>;\n\n\tfunction syscall(syscall: \"log\", value: string): void;\n\n\tfunction syscall(syscall: \"read\", blob: Blob): Promise<Uint8Array>;\n\n\tfunction syscall(syscall: \"store\", object: Object_): Promise<Object_.Id>;\n\n\tfunction syscall(syscall: \"sleep\", duration: number): Promise<void>;\n}\n\nexport let archive = async (\n\tartifact: Artifact,\n\tformat: Blob.ArchiveFormat,\n): Promise<Blob> => {\n\ttry {\n\t\treturn await syscall(\"archive\", artifact, format);\n\t} catch (cause) {\n\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t}\n};\n\nexport let build = async (target: Target): Promise<Value> => {\n\ttry {\n\t\treturn await syscall(\"build\", target);\n\t} catch (cause) {\n\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t}\n};\n\nexport let bundle = async (artifact: Artifact): Promise<Directory> => {\n\ttry {\n\t\treturn await syscall(\"bundle\", artifact);\n\t} catch (cause) {\n\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t}\n};\n\nexport let checksum = (\n\talgorithm: Checksum.Algorithm,\n\tbytes: string | Uint8Array,\n): Checksum => {\n\ttry {\n\t\treturn syscall(\"checksum\", algorithm, bytes);\n\t} catch (cause) {\n\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t}\n};\n\nexport let compress = async (\n\tblob: Blob,\n\tformat: Blob.CompressionFormat,\n): Promise<Blob> => {\n\ttry {\n\t\treturn await syscall(\"compress\", blob, format);\n\t} catch (cause) {\n\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t}\n};\n\nexport let decompress = async (\n\tblob: Blob,\n\tformat: Blob.CompressionFormat,\n): Promise<Blob> => {\n\ttry {\n\t\treturn await syscall(\"decompress\", blob, format);\n\t} catch (cause) {\n\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t}\n};\n\nexport let download = async (\n\turl: string,\n\tchecksum: Checksum,\n): Promise<Blob> => {\n\ttry {\n\t\treturn await syscall(\"download\", url, checksum);\n\t} catch (cause) {\n\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t}\n};\n\nexport let encoding = {\n\tbase64: {\n\t\tdecode: (value: string): Uint8Array => {\n\t\t\ttry {\n\t\t\t\treturn syscall(\"encoding_base64_decode\", value);\n\t\t\t} catch (cause) {\n\t\t\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t\t\t}\n\t\t},\n\n\t\tencode: (value: Uint8Array): string => {\n\t\t\ttry {\n\t\t\t\treturn syscall(\"encoding_base64_encode\", value);\n\t\t\t} catch (cause) {\n\t\t\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t\t\t}\n\t\t},\n\t},\n\n\thex: {\n\t\tdecode: (value: string): Uint8Array => {\n\t\t\ttry {\n\t\t\t\treturn syscall(\"encoding_hex_decode\", value);\n\t\t\t} catch (cause) {\n\t\t\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t\t\t}\n\t\t},\n\n\t\tencode: (value: Uint8Array): string => {\n\t\t\ttry {\n\t\t\t\treturn syscall(\"encoding_hex_encode\", value);\n\t\t\t} catch (cause) {\n\t\t\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t\t\t}\n\t\t},\n\t},\n\n\tjson: {\n\t\tdecode: (value: string): unknown => {\n\t\t\ttry {\n\t\t\t\treturn syscall(\"encoding_json_decode\", value);\n\t\t\t} catch (cause) {\n\t\t\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t\t\t}\n\t\t},\n\n\t\tencode: (value: any): string => {\n\t\t\ttry {\n\t\t\t\treturn syscall(\"encoding_json_encode\", value);\n\t\t\t} catch (cause) {\n\t\t\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t\t\t}\n\t\t},\n\t},\n\n\ttoml: {\n\t\tdecode: (value: string): unknown => {\n\t\t\ttry {\n\t\t\t\treturn syscall(\"encoding_toml_decode\", value);\n\t\t\t} catch (cause) {\n\t\t\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t\t\t}\n\t\t},\n\n\t\tencode: (value: any): string => {\n\t\t\ttry {\n\t\t\t\treturn syscall(\"encoding_toml_encode\", value);\n\t\t\t} catch (cause) {\n\t\t\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t\t\t}\n\t\t},\n\t},\n\n\tutf8: {\n\t\tdecode: (value: Uint8Array): string => {\n\t\t\ttry {\n\t\t\t\treturn syscall(\"encoding_utf8_decode\", value);\n\t\t\t} catch (cause) {\n\t\t\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t\t\t}\n\t\t},\n\n\t\tencode: (value: string): Uint8Array => {\n\t\t\ttry {\n\t\t\t\treturn syscall(\"encoding_utf8_encode\", value);\n\t\t\t} catch (cause) {\n\t\t\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t\t\t}\n\t\t},\n\t},\n\n\tyaml: {\n\t\tdecode: (value: string): unknown => {\n\t\t\ttry {\n\t\t\t\treturn syscall(\"encoding_yaml_decode\", value);\n\t\t\t} catch (cause) {\n\t\t\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t\t\t}\n\t\t},\n\n\t\tencode: (value: any): string => {\n\t\t\ttry {\n\t\t\t\treturn syscall(\"encoding_yaml_encode\", value);\n\t\t\t} catch (cause) {\n\t\t\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t\t\t}\n\t\t},\n\t},\n};\n\nexport let extract = async (\n\tblob: Blob,\n\tformat: Blob.ArchiveFormat,\n): Promise<Artifact> => {\n\ttry {\n\t\treturn await syscall(\"extract\", blob, format);\n\t} catch (cause) {\n\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t}\n};\n\nexport let log = (value: string) => {\n\ttry {\n\t\treturn syscall(\"log\", value);\n\t} catch (cause) {\n\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t}\n};\n\nexport let load = async (id: Object_.Id): Promise<Object_> => {\n\ttry {\n\t\treturn await syscall(\"load\", id);\n\t} catch (cause) {\n\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t}\n};\n\nexport let read = async (blob: Blob): Promise<Uint8Array> => {\n\ttry {\n\t\treturn await syscall(\"read\", blob);\n\t} catch (cause) {\n\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t}\n};\n\nexport let store = async (object: Object_): Promise<Object_.Id> => {\n\ttry {\n\t\treturn await syscall(\"store\", object);\n\t} catch (cause) {\n\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t}\n};\n\nexport let sleep = async (duration: number): Promise<void> => {\n\ttry {\n\t\treturn await syscall(\"sleep\", duration);\n\t} catch (cause) {\n\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t}\n};\n", "import { Artifact } from \"./artifact.ts\";\nimport { assert as assert_, unreachable } from \"./assert.ts\";\nimport { Blob, blob } from \"./blob.ts\";\nimport { Args, MutationMap, apply, mutation } from \"./mutation.ts\";\nimport { Object_ } from \"./object.ts\";\nimport * as syscall from \"./syscall.ts\";\n\nexport let file = async (...args: Args<File.Arg>) => {\n\treturn await File.new(...args);\n};\n\nexport class File {\n\t#state: File.State;\n\n\tconstructor(state: File.State) {\n\t\tthis.#state = state;\n\t}\n\n\tget state(): File.State {\n\t\treturn this.#state;\n\t}\n\n\tstatic withId(id: File.Id): File {\n\t\treturn new File({ id });\n\t}\n\n\tstatic async new(...args: Args<File.Arg>): Promise<File> {\n\t\ttype Apply = {\n\t\t\tcontents?: Array<Blob.Arg>;\n\t\t\texecutable?: Array<boolean>;\n\t\t\treferences?: Array<Artifact>;\n\t\t};\n\t\tlet {\n\t\t\tcontents: contents_,\n\t\t\texecutable: executable_,\n\t\t\treferences: references_,\n\t\t} = await apply<File.Arg, Apply>(args, async (arg) => {\n\t\t\tif (arg === undefined) {\n\t\t\t\treturn {};\n\t\t\t} else if (\n\t\t\t\ttypeof arg === \"string\" ||\n\t\t\t\targ instanceof Uint8Array ||\n\t\t\t\tBlob.is(arg)\n\t\t\t) {\n\t\t\t\treturn {\n\t\t\t\t\tcontents: await mutation({ kind: \"array_append\", values: [arg] }),\n\t\t\t\t};\n\t\t\t} else if (File.is(arg)) {\n\t\t\t\treturn {\n\t\t\t\t\tcontents: await mutation({\n\t\t\t\t\t\tkind: \"array_append\",\n\t\t\t\t\t\tvalues: [await arg.contents()],\n\t\t\t\t\t}),\n\t\t\t\t\texecutable: await mutation({\n\t\t\t\t\t\tkind: \"array_append\",\n\t\t\t\t\t\tvalues: [await arg.executable()],\n\t\t\t\t\t}),\n\t\t\t\t\treferences: await mutation({\n\t\t\t\t\t\tkind: \"array_append\",\n\t\t\t\t\t\tvalues: [await arg.references()],\n\t\t\t\t\t}),\n\t\t\t\t};\n\t\t\t} else if (typeof arg === \"object\") {\n\t\t\t\tlet ret: Partial<MutationMap<Apply>> = {};\n\t\t\t\tif (arg.contents !== undefined) {\n\t\t\t\t\tret.contents = await mutation({\n\t\t\t\t\t\tkind: \"array_append\",\n\t\t\t\t\t\tvalues: [arg.contents],\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tif (arg.executable !== undefined) {\n\t\t\t\t\tret.executable = await mutation({\n\t\t\t\t\t\tkind: \"array_append\",\n\t\t\t\t\t\tvalues: [arg.executable],\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tif (arg.references !== undefined) {\n\t\t\t\t\tret.references = await mutation({\n\t\t\t\t\t\tkind: \"array_append\",\n\t\t\t\t\t\tvalues: [arg.references],\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t} else {\n\t\t\t\treturn unreachable();\n\t\t\t}\n\t\t});\n\t\tlet contents = await blob(contents_);\n\t\tlet executable = (executable_ ?? []).some((executable) => executable);\n\t\tlet references = references_ ?? [];\n\t\treturn new File({\n\t\t\tobject: { contents, executable, references },\n\t\t});\n\t}\n\n\tstatic is(value: unknown): value is File {\n\t\treturn value instanceof File;\n\t}\n\n\tstatic expect(value: unknown): File {\n\t\tassert_(File.is(value));\n\t\treturn value;\n\t}\n\n\tstatic assert(value: unknown): asserts value is File {\n\t\tassert_(File.is(value));\n\t}\n\n\tasync id(): Promise<File.Id> {\n\t\treturn (await this.id()) as File.Id;\n\t}\n\n\tasync object(): Promise<File.Object_> {\n\t\tawait this.load();\n\t\treturn this.#state.object!;\n\t}\n\n\tasync load() {\n\t\tif (this.#state.object === undefined) {\n\t\t\tlet object = await syscall.load(this.#state.id!);\n\t\t\tassert_(object.kind === \"file\");\n\t\t\tthis.#state.object = object.value;\n\t\t}\n\t}\n\n\tasync store() {\n\t\tif (this.#state.id === undefined) {\n\t\t\tthis.#state.id = await syscall.store({\n\t\t\t\tkind: \"file\",\n\t\t\t\tvalue: this.#state.object!,\n\t\t\t});\n\t\t}\n\t}\n\n\tasync contents(): Promise<Blob> {\n\t\treturn (await this.object()).contents;\n\t}\n\n\tasync executable(): Promise<boolean> {\n\t\treturn (await this.object()).executable;\n\t}\n\n\tasync references(): Promise<Array<Artifact>> {\n\t\treturn (await this.object()).references;\n\t}\n\n\tasync size(): Promise<number> {\n\t\treturn (await this.contents()).size();\n\t}\n\n\tasync bytes(): Promise<Uint8Array> {\n\t\treturn (await this.contents()).bytes();\n\t}\n\n\tasync text(): Promise<string> {\n\t\treturn (await this.contents()).text();\n\t}\n}\n\nexport namespace File {\n\texport type Arg =\n\t\t| undefined\n\t\t| string\n\t\t| Uint8Array\n\t\t| Blob\n\t\t| File\n\t\t| ArgObject\n\t\t| Array<Arg>;\n\n\texport type ArgObject = {\n\t\tcontents?: Blob.Arg;\n\t\texecutable?: boolean;\n\t\treferences?: Array<Artifact>;\n\t};\n\n\texport type Id = string;\n\n\texport type Object_ = {\n\t\tcontents: Blob;\n\t\texecutable: boolean;\n\t\treferences: Array<Artifact>;\n\t};\n\n\texport type State = Object_.State<File.Id, File.Object_>;\n}\n", "import { Artifact } from \"./artifact.ts\";\nimport { assert as assert_, unreachable } from \"./assert.ts\";\nimport { Blob } from \"./blob.ts\";\nimport * as encoding from \"./encoding.ts\";\nimport { Args, apply, mutation } from \"./mutation.ts\";\nimport { Object_ } from \"./object.ts\";\nimport * as syscall from \"./syscall.ts\";\n\nexport let leaf = async (...args: Args<Leaf.Arg>): Promise<Leaf> => {\n\treturn await Leaf.new(...args);\n};\n\nexport class Leaf {\n\t#state: Leaf.State;\n\n\tconstructor(state: Leaf.State) {\n\t\tthis.#state = state;\n\t}\n\n\tget state(): Leaf.State {\n\t\treturn this.#state;\n\t}\n\n\tstatic withId(id: Leaf.Id): Leaf {\n\t\treturn new Leaf({ id });\n\t}\n\n\tstatic async new(...args: Args<Leaf.Arg>): Promise<Leaf> {\n\t\ttype Apply = {\n\t\t\tbytes: Array<Uint8Array>;\n\t\t};\n\t\tlet { bytes: bytes_ } = await apply<Leaf.Arg, Apply>(args, async (arg) => {\n\t\t\tif (arg === undefined) {\n\t\t\t\treturn {};\n\t\t\t} else if (typeof arg === \"string\") {\n\t\t\t\treturn {\n\t\t\t\t\tbytes: await mutation({\n\t\t\t\t\t\tkind: \"array_append\",\n\t\t\t\t\t\tvalues: [encoding.utf8.encode(arg)],\n\t\t\t\t\t}),\n\t\t\t\t};\n\t\t\t} else if (arg instanceof Uint8Array) {\n\t\t\t\treturn {\n\t\t\t\t\tbytes: await mutation({\n\t\t\t\t\t\tkind: \"array_append\",\n\t\t\t\t\t\tvalues: [arg],\n\t\t\t\t\t}),\n\t\t\t\t};\n\t\t\t} else if (Leaf.is(arg)) {\n\t\t\t\treturn {\n\t\t\t\t\tbytes: await mutation({\n\t\t\t\t\t\tkind: \"array_append\",\n\t\t\t\t\t\tvalues: [await arg.bytes()],\n\t\t\t\t\t}),\n\t\t\t\t};\n\t\t\t} else if (typeof arg === \"object\") {\n\t\t\t\treturn {\n\t\t\t\t\tbytes: await mutation({\n\t\t\t\t\t\tkind: \"array_append\",\n\t\t\t\t\t\tvalues: [arg.bytes ?? new Uint8Array()],\n\t\t\t\t\t}),\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\treturn unreachable();\n\t\t\t}\n\t\t});\n\t\tbytes_ ??= [];\n\t\tlet size = bytes_.reduce((size, bytes) => size + bytes.byteLength, 0);\n\t\tlet bytes = new Uint8Array(size);\n\t\tlet offset = 0;\n\t\tfor (let entry of bytes_) {\n\t\t\tbytes.set(entry, offset);\n\t\t\toffset += entry.byteLength;\n\t\t}\n\t\treturn new Leaf({ object: { bytes } });\n\t}\n\n\tstatic is(value: unknown): value is Leaf {\n\t\treturn value instanceof Leaf;\n\t}\n\n\tstatic expect(value: unknown): Leaf {\n\t\tassert_(Leaf.is(value));\n\t\treturn value;\n\t}\n\n\tstatic assert(value: unknown): asserts value is Leaf {\n\t\tassert_(Leaf.is(value));\n\t}\n\n\tasync id(): Promise<Leaf.Id> {\n\t\tawait this.store();\n\t\treturn this.#state.id!;\n\t}\n\n\tasync object(): Promise<Leaf.Object_> {\n\t\tawait this.load();\n\t\treturn this.#state.object!;\n\t}\n\n\tasync load() {\n\t\tif (this.#state.object === undefined) {\n\t\t\tlet object = await syscall.load(this.#state.id!);\n\t\t\tassert_(object.kind === \"leaf\");\n\t\t\tthis.#state.object = object.value;\n\t\t}\n\t}\n\n\tasync store() {\n\t\tif (this.#state.id === undefined) {\n\t\t\tthis.#state.id = await syscall.store({\n\t\t\t\tkind: \"leaf\",\n\t\t\t\tvalue: this.#state.object!,\n\t\t\t});\n\t\t}\n\t}\n\n\tasync size(): Promise<number> {\n\t\treturn (await this.object()).bytes.byteLength;\n\t}\n\n\tasync bytes(): Promise<Uint8Array> {\n\t\treturn (await this.object()).bytes;\n\t}\n\n\tasync text(): Promise<string> {\n\t\treturn encoding.utf8.decode(await syscall.read(this));\n\t}\n\n\tasync compress(format: Blob.CompressionFormat): Promise<Blob> {\n\t\treturn await syscall.compress(this, format);\n\t}\n\n\tasync decompress(format: Blob.CompressionFormat): Promise<Blob> {\n\t\treturn await syscall.decompress(this, format);\n\t}\n\n\tasync extract(format: Blob.ArchiveFormat): Promise<Artifact> {\n\t\treturn await syscall.extract(this, format);\n\t}\n}\n\nexport namespace Leaf {\n\texport type Arg =\n\t\t| undefined\n\t\t| string\n\t\t| Uint8Array\n\t\t| Leaf\n\t\t| ArgObject\n\t\t| Array<Arg>;\n\n\texport type ArgObject = {\n\t\tbytes?: Uint8Array;\n\t};\n\n\texport type Id = string;\n\n\texport type Object_ = { bytes: Uint8Array };\n\n\texport type State = Object_.State<Leaf.Id, Leaf.Object_>;\n}\n", "import { Artifact } from \"./artifact.ts\";\nimport { assert as assert_ } from \"./assert.ts\";\nimport { Object_ } from \"./object.ts\";\nimport * as syscall from \"./syscall.ts\";\n\nexport class Package {\n\t#state: Package.State;\n\n\tconstructor(state: Package.State) {\n\t\tthis.#state = state;\n\t}\n\n\tget state(): Package.State {\n\t\treturn this.#state;\n\t}\n\n\tstatic withId(id: Package.Id): Package {\n\t\treturn new Package({ id });\n\t}\n\n\tstatic is(value: unknown): value is Package {\n\t\treturn value instanceof Package;\n\t}\n\n\tstatic expect(value: unknown): Package {\n\t\tassert_(Package.is(value));\n\t\treturn value;\n\t}\n\n\tstatic assert(value: unknown): asserts value is Package {\n\t\tassert_(Package.is(value));\n\t}\n\n\tasync id(): Promise<Package.Id> {\n\t\tawait this.store();\n\t\treturn this.#state.id!;\n\t}\n\n\tasync object(): Promise<Package.Object_> {\n\t\tawait this.load();\n\t\treturn this.#state.object!;\n\t}\n\n\tasync load() {\n\t\tif (this.#state.object === undefined) {\n\t\t\tlet object = await syscall.load(this.#state.id!);\n\t\t\tassert_(object.kind === \"package\");\n\t\t\tthis.#state.object = object.value;\n\t\t}\n\t}\n\n\tasync store() {\n\t\tif (this.#state.id === undefined) {\n\t\t\tthis.#state.id = await syscall.store({\n\t\t\t\tkind: \"package\",\n\t\t\t\tvalue: this.#state.object!,\n\t\t\t});\n\t\t}\n\t}\n\n\tasync artifact(): Promise<Artifact> {\n\t\treturn (await this.object()).artifact;\n\t}\n\n\tasync dependencies(): Promise<{ [dependency: string]: Package }> {\n\t\treturn (await this.object()).dependencies;\n\t}\n}\n\nexport namespace Package {\n\texport type Arg = Package | ArgObject | Array<Arg>;\n\n\texport type ArgObject = {\n\t\tartifact: Artifact;\n\t\tdependencies?: { [dependency: string]: Package.Arg };\n\t};\n\n\texport type Id = string;\n\n\texport type Object_ = {\n\t\tartifact: Artifact;\n\t\tdependencies: { [dependency: string]: Package };\n\t};\n\n\texport type State = Object_.State<Package.Id, Package.Object_>;\n}\n", "import { assert as assert_, unreachable } from \"./assert.ts\";\n\nexport let relpath = (...args: Array<Relpath.Arg>): Relpath => {\n\treturn Relpath.new(...args);\n};\n\nexport let subpath = (...args: Array<Subpath.Arg>): Subpath => {\n\treturn Subpath.new(...args);\n};\n\ntype RelpathConstructorArg = {\n\tparents?: number;\n\tsubpath?: Subpath;\n};\n\nexport class Relpath {\n\t#parents: number;\n\t#subpath: Subpath;\n\n\tconstructor(arg?: RelpathConstructorArg) {\n\t\tthis.#parents = arg?.parents ?? 0;\n\t\tthis.#subpath = arg?.subpath ?? new Subpath();\n\t}\n\n\tstatic new(...args: Array<Relpath.Arg>): Relpath {\n\t\treturn args.reduce(function reduce(path: Relpath, arg: Relpath.Arg) {\n\t\t\tif (typeof arg === \"string\") {\n\t\t\t\tfor (let component of arg.split(\"/\")) {\n\t\t\t\t\tif (component === \"\" || component === \".\") {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else if (component === \"..\") {\n\t\t\t\t\t\tpath = path.parent();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpath.#subpath.push(component);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (arg instanceof Relpath) {\n\t\t\t\tfor (let i = 0; i < arg.#parents; i++) {\n\t\t\t\t\tpath.parent();\n\t\t\t\t}\n\t\t\t\tpath.#subpath.join(arg.#subpath);\n\t\t\t} else if (arg instanceof Subpath) {\n\t\t\t\tpath.#subpath.join(arg);\n\t\t\t} else if (arg instanceof Array) {\n\t\t\t\targ.forEach((arg) => reduce(path, arg));\n\t\t\t} else {\n\t\t\t\treturn unreachable();\n\t\t\t}\n\t\t\treturn path;\n\t\t}, new Relpath());\n\t}\n\n\tisEmpty(): boolean {\n\t\treturn this.#parents == 0 && this.#subpath.isEmpty();\n\t}\n\n\tparents(): number {\n\t\treturn this.#parents;\n\t}\n\n\tsubpath(): Subpath {\n\t\treturn this.#subpath;\n\t}\n\n\tparent(): Relpath {\n\t\tif (this.#subpath.isEmpty()) {\n\t\t\tthis.#parents += 1;\n\t\t} else {\n\t\t\tthis.#subpath.pop();\n\t\t}\n\t\treturn this;\n\t}\n\n\tjoin(other: Relpath.Arg): Relpath {\n\t\tother = Relpath.new(other);\n\t\tfor (let i = 0; i < other.#parents; i++) {\n\t\t\tthis.parent();\n\t\t}\n\t\tthis.#subpath.join(other.#subpath);\n\t\treturn this;\n\t}\n\n\textension(): string | undefined {\n\t\treturn this.#subpath.extension();\n\t}\n\n\ttoSubpath(): Subpath {\n\t\tif (this.#parents > 0) {\n\t\t\tthrow new Error(\"Cannot convert to subpath.\");\n\t\t}\n\t\treturn this.#subpath;\n\t}\n\n\ttoString(): string {\n\t\tlet string = \"\";\n\t\tfor (let i = 0; i < this.#parents; i++) {\n\t\t\tstring += \"../\";\n\t\t}\n\t\tstring += this.#subpath.toString();\n\t\treturn string;\n\t}\n}\n\nexport namespace Relpath {\n\texport type Arg = Subpath.Arg | Relpath | Array<Arg>;\n\n\texport namespace Arg {\n\t\texport let is = (value: unknown): value is Relpath.Arg => {\n\t\t\treturn (\n\t\t\t\tSubpath.Arg.is(value) ||\n\t\t\t\tvalue instanceof Relpath ||\n\t\t\t\t(value instanceof Array && value.every(Relpath.Arg.is))\n\t\t\t);\n\t\t};\n\n\t\texport let expect = (value: unknown): Relpath.Arg => {\n\t\t\tassert_(is(value));\n\t\t\treturn value;\n\t\t};\n\n\t\texport let assert = (value: unknown): asserts value is Relpath.Arg => {\n\t\t\tassert_(is(value));\n\t\t};\n\t}\n}\n\nexport class Subpath {\n\t#components: Array<string>;\n\n\tconstructor(components?: Array<string>) {\n\t\tthis.#components = components ?? [];\n\t}\n\n\tstatic new(...args: Array<Subpath.Arg>): Subpath {\n\t\treturn Relpath.new(...args).toSubpath();\n\t}\n\n\tcomponents(): Array<string> {\n\t\treturn [...this.#components];\n\t}\n\n\tisEmpty(): boolean {\n\t\treturn this.#components.length == 0;\n\t}\n\n\tjoin(other: Subpath): Subpath {\n\t\tthis.#components.push(...other.#components);\n\t\treturn this;\n\t}\n\n\tpush(component: string) {\n\t\tthis.#components.push(component);\n\t}\n\n\tpop() {\n\t\tthis.#components.pop();\n\t}\n\n\textension(): string | undefined {\n\t\treturn this.#components.at(-1)?.split(\".\").at(-1);\n\t}\n\n\ttoRelpath(): Relpath {\n\t\treturn Relpath.new(this);\n\t}\n\n\ttoString(): string {\n\t\treturn this.#components.join(\"/\");\n\t}\n}\n\nexport namespace Subpath {\n\texport type Arg = undefined | string | Subpath | Array<Arg>;\n\n\texport namespace Arg {\n\t\texport let is = (value: unknown): value is Subpath.Arg => {\n\t\t\treturn (\n\t\t\t\tvalue === undefined ||\n\t\t\t\ttypeof value === \"string\" ||\n\t\t\t\tvalue instanceof Subpath ||\n\t\t\t\t(value instanceof Array && value.every(Subpath.Arg.is))\n\t\t\t);\n\t\t};\n\n\t\texport let expect = (value: unknown): Subpath.Arg => {\n\t\t\tassert_(is(value));\n\t\t\treturn value;\n\t\t};\n\n\t\texport let assert = (value: unknown): asserts value is Subpath.Arg => {\n\t\t\tassert_(is(value));\n\t\t};\n\t}\n}\n", "import { Artifact } from \"./artifact.ts\";\nimport { assert as assert_, unreachable } from \"./assert.ts\";\nimport { Args, apply, mutation } from \"./mutation.ts\";\nimport { Unresolved } from \"./resolve.ts\";\n\nexport let template = (...args: Args<Template.Arg>): Promise<Template> => {\n\treturn Template.new(...args);\n};\n\nexport class Template {\n\t#components: Array<Template.Component>;\n\n\tconstructor(components: Array<Template.Component>) {\n\t\tthis.#components = components;\n\t}\n\n\tstatic async new(...args: Args<Template.Arg>): Promise<Template> {\n\t\ttype Apply = {\n\t\t\tcomponents: Array<Template.Component>;\n\t\t};\n\t\tlet { components } = await apply<Template.Arg, Apply>(args, async (arg) => {\n\t\t\tif (arg === undefined) {\n\t\t\t\treturn {};\n\t\t\t} else if (typeof arg === \"string\" || Artifact.is(arg)) {\n\t\t\t\treturn {\n\t\t\t\t\tcomponents: await mutation({\n\t\t\t\t\t\tkind: \"array_append\",\n\t\t\t\t\t\tvalues: [arg],\n\t\t\t\t\t}),\n\t\t\t\t};\n\t\t\t} else if (Template.is(arg)) {\n\t\t\t\treturn {\n\t\t\t\t\tcomponents: await mutation({\n\t\t\t\t\t\tkind: \"array_append\",\n\t\t\t\t\t\tvalues: arg.components,\n\t\t\t\t\t}),\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\treturn unreachable();\n\t\t\t}\n\t\t});\n\n\t\t// Normalize the components.\n\t\tcomponents = (components ?? []).reduce<Array<Template.Component>>(\n\t\t\t(components, component) => {\n\t\t\t\tlet lastComponent = components.at(-1);\n\t\t\t\tif (component === \"\") {\n\t\t\t\t\t// Ignore empty string components.\n\t\t\t\t} else if (\n\t\t\t\t\ttypeof lastComponent === \"string\" &&\n\t\t\t\t\ttypeof component === \"string\"\n\t\t\t\t) {\n\t\t\t\t\t// Merge adjacent string components.\n\t\t\t\t\tcomponents.splice(-1, 1, lastComponent + component);\n\t\t\t\t} else {\n\t\t\t\t\tcomponents.push(component);\n\t\t\t\t}\n\t\t\t\treturn components;\n\t\t\t},\n\t\t\t[],\n\t\t);\n\n\t\treturn new Template(components);\n\t}\n\n\tstatic is(value: unknown): value is Template {\n\t\treturn value instanceof Template;\n\t}\n\n\tstatic expect(value: unknown): Template {\n\t\tassert_(Template.is(value));\n\t\treturn value;\n\t}\n\n\tstatic assert(value: unknown): asserts value is Template {\n\t\tassert_(Template.is(value));\n\t}\n\n\t/** Join an array of templates with a separator. */\n\tstatic async join(\n\t\tseparator: Unresolved<Template.Arg>,\n\t\t...args: Array<Unresolved<Template.Arg>>\n\t): Promise<Template> {\n\t\tlet separatorTemplate = await template(separator);\n\t\tlet argTemplates = await Promise.all(args.map((arg) => template(arg)));\n\t\targTemplates = argTemplates.filter((arg) => arg.components.length > 0);\n\t\tlet templates = [];\n\t\tfor (let i = 0; i < argTemplates.length; i++) {\n\t\t\tif (i > 0) {\n\t\t\t\ttemplates.push(separatorTemplate);\n\t\t\t}\n\t\t\tlet argTemplate = argTemplates[i];\n\t\t\tassert_(argTemplate);\n\t\t\ttemplates.push(argTemplate);\n\t\t}\n\t\treturn template(...templates);\n\t}\n\n\tget components(): Array<Template.Component> {\n\t\treturn this.#components;\n\t}\n}\n\nexport namespace Template {\n\texport type Arg = undefined | Component | Template;\n\n\texport type Component = string | Artifact;\n}\n", "import { Artifact } from \"./artifact.ts\";\nimport { assert as assert_, unreachable } from \"./assert.ts\";\nimport { Directory } from \"./directory.ts\";\nimport { File } from \"./file.ts\";\nimport { Args, apply, mutation } from \"./mutation.ts\";\nimport { Object_ } from \"./object.ts\";\nimport { Relpath, relpath } from \"./path.ts\";\nimport { Unresolved } from \"./resolve.ts\";\nimport * as syscall from \"./syscall.ts\";\nimport { Template, template } from \"./template.ts\";\n\nexport let symlink = async (...args: Args<Symlink.Arg>): Promise<Symlink> => {\n\treturn await Symlink.new(...args);\n};\n\nexport class Symlink {\n\t#state: Symlink.State;\n\n\tconstructor(state: Symlink.State) {\n\t\tthis.#state = state;\n\t}\n\n\tget state(): Symlink.State {\n\t\treturn this.#state;\n\t}\n\n\tstatic withId(id: Symlink.Id): Symlink {\n\t\treturn new Symlink({ id });\n\t}\n\n\tstatic async new(...args: Args<Symlink.Arg>): Promise<Symlink> {\n\t\ttype Apply = {\n\t\t\tartifact?: Artifact | undefined;\n\t\t\tpath?: string | undefined;\n\t\t};\n\t\tlet { artifact, path: path_ } = await apply<Symlink.Arg, Apply>(\n\t\t\targs,\n\t\t\tasync (arg) => {\n\t\t\t\tif (arg === undefined) {\n\t\t\t\t\treturn {};\n\t\t\t\t} else if (typeof arg === \"string\") {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tpath: await mutation({ kind: \"template_append\", template: arg }),\n\t\t\t\t\t};\n\t\t\t\t} else if (Artifact.is(arg)) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tartifact: arg,\n\t\t\t\t\t\tpath: await mutation({ kind: \"unset\" as const }),\n\t\t\t\t\t};\n\t\t\t\t} else if (Template.is(arg)) {\n\t\t\t\t\tassert_(arg.components.length <= 2);\n\t\t\t\t\tlet [firstComponent, secondComponent] = arg.components;\n\t\t\t\t\tif (\n\t\t\t\t\t\ttypeof firstComponent === \"string\" &&\n\t\t\t\t\t\tsecondComponent === undefined\n\t\t\t\t\t) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tpath: await mutation({\n\t\t\t\t\t\t\t\tkind: \"template_append\" as const,\n\t\t\t\t\t\t\t\ttemplate: firstComponent,\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t};\n\t\t\t\t\t} else if (\n\t\t\t\t\t\tArtifact.is(firstComponent) &&\n\t\t\t\t\t\tsecondComponent === undefined\n\t\t\t\t\t) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tartifact: firstComponent,\n\t\t\t\t\t\t\tpath: await mutation({ kind: \"unset\" as const }),\n\t\t\t\t\t\t};\n\t\t\t\t\t} else if (\n\t\t\t\t\t\tArtifact.is(firstComponent) &&\n\t\t\t\t\t\ttypeof secondComponent === \"string\"\n\t\t\t\t\t) {\n\t\t\t\t\t\tassert_(secondComponent.startsWith(\"/\"));\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tartifact: firstComponent,\n\t\t\t\t\t\t\tpath: secondComponent.slice(1),\n\t\t\t\t\t\t};\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new Error(\"Invalid template.\");\n\t\t\t\t\t}\n\t\t\t\t} else if (Symlink.is(arg)) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tartifact: await arg.artifact(),\n\t\t\t\t\t\tpath: (await arg.path()).toString(),\n\t\t\t\t\t};\n\t\t\t\t} else if (typeof arg === \"object\") {\n\t\t\t\t\treturn arg;\n\t\t\t\t} else {\n\t\t\t\t\treturn unreachable();\n\t\t\t\t}\n\t\t\t},\n\t\t);\n\n\t\t// Create the target.\n\t\tlet path = relpath(path_ ?? \"\");\n\t\tlet target;\n\t\tif (artifact !== undefined && !path.isEmpty()) {\n\t\t\ttarget = await template(artifact, \"/\", path.toString());\n\t\t} else if (artifact !== undefined) {\n\t\t\ttarget = await template(artifact);\n\t\t} else if (!path.isEmpty()) {\n\t\t\ttarget = await template(path.toString());\n\t\t} else {\n\t\t\tthrow new Error(\"Invalid symlink.\");\n\t\t}\n\n\t\treturn new Symlink({ object: { target } });\n\t}\n\n\tstatic is(value: unknown): value is Symlink {\n\t\treturn value instanceof Symlink;\n\t}\n\n\tstatic expect(value: unknown): Symlink {\n\t\tassert_(Symlink.is(value));\n\t\treturn value;\n\t}\n\n\tstatic assert(value: unknown): asserts value is Symlink {\n\t\tassert_(Symlink.is(value));\n\t}\n\n\tasync id(): Promise<Symlink.Id> {\n\t\tawait this.store();\n\t\treturn this.#state.id!;\n\t}\n\n\tasync object(): Promise<Symlink.Object_> {\n\t\tawait this.load();\n\t\treturn this.#state.object!;\n\t}\n\n\tasync load() {\n\t\tif (this.#state.object === undefined) {\n\t\t\tlet object = await syscall.load(this.#state.id!);\n\t\t\tassert_(object.kind === \"symlink\");\n\t\t\tthis.#state.object = object.value;\n\t\t}\n\t}\n\n\tasync store() {\n\t\tif (this.#state.id === undefined) {\n\t\t\tthis.#state.id = await syscall.store({\n\t\t\t\tkind: \"symlink\",\n\t\t\t\tvalue: this.#state.object!,\n\t\t\t});\n\t\t}\n\t}\n\n\tasync target(): Promise<Template> {\n\t\treturn (await this.object()).target;\n\t}\n\n\tasync artifact(): Promise<Artifact | undefined> {\n\t\tlet target = await this.target();\n\t\tlet firstComponent = target.components.at(0);\n\t\tif (Artifact.is(firstComponent)) {\n\t\t\treturn firstComponent;\n\t\t} else {\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\tasync path(): Promise<Relpath> {\n\t\tlet target = await this.target();\n\t\tlet [firstComponent, secondComponent] = target.components;\n\t\tif (typeof firstComponent === \"string\" && secondComponent === undefined) {\n\t\t\treturn relpath(firstComponent);\n\t\t} else if (Artifact.is(firstComponent) && secondComponent === undefined) {\n\t\t\treturn relpath();\n\t\t} else if (\n\t\t\tArtifact.is(firstComponent) &&\n\t\t\ttypeof secondComponent === \"string\"\n\t\t) {\n\t\t\treturn relpath(secondComponent.slice(1));\n\t\t} else {\n\t\t\tthrow new Error(\"Invalid template.\");\n\t\t}\n\t}\n\n\tasync resolve(\n\t\tfrom?: Unresolved<Symlink.Arg>,\n\t): Promise<Directory | File | undefined> {\n\t\tfrom = from ? await symlink(from) : undefined;\n\t\tlet fromArtifact = await from?.artifact();\n\t\tif (Symlink.is(fromArtifact)) {\n\t\t\tfromArtifact = await fromArtifact.resolve();\n\t\t}\n\t\tlet fromPath = from?.path();\n\t\tlet artifact = await this.artifact();\n\t\tif (Symlink.is(artifact)) {\n\t\t\tartifact = await artifact.resolve();\n\t\t}\n\t\tlet path = await this.path();\n\t\tif (artifact !== undefined && path.isEmpty()) {\n\t\t\treturn artifact;\n\t\t} else if (artifact === undefined && !path.isEmpty()) {\n\t\t\tif (!Directory.is(fromArtifact)) {\n\t\t\t\tthrow new Error(\"Expected a directory.\");\n\t\t\t}\n\t\t\treturn await fromArtifact.tryGet(\n\t\t\t\t(await (fromPath ?? relpath()))\n\t\t\t\t\t.parent()\n\t\t\t\t\t.join(path)\n\t\t\t\t\t.toSubpath()\n\t\t\t\t\t.toString(),\n\t\t\t);\n\t\t} else if (artifact !== undefined && !path.isEmpty()) {\n\t\t\tif (!Directory.is(artifact)) {\n\t\t\t\tthrow new Error(\"Expected a directory.\");\n\t\t\t}\n\t\t\treturn await artifact.tryGet(path.toSubpath().toString());\n\t\t} else {\n\t\t\tthrow new Error(\"Invalid symlink.\");\n\t\t}\n\t}\n}\n\nexport namespace Symlink {\n\texport type Arg =\n\t\t| undefined\n\t\t| string\n\t\t| Artifact\n\t\t| Template\n\t\t| Symlink\n\t\t| ArgObject\n\t\t| Array<Arg>;\n\n\texport type ArgObject = {\n\t\tartifact?: Artifact;\n\t\tpath?: string;\n\t};\n\n\texport type Id = string;\n\n\texport type Object_ = { target: Template };\n\n\texport type State = Object_.State<Symlink.Id, Symlink.Object_>;\n}\n", "import { assert } from \"./assert.ts\";\nimport { encoding } from \"./syscall.ts\";\n\nexport type Module =\n\t| { kind: \"document\"; value: Document }\n\t| { kind: \"library\"; value: Library }\n\t| { kind: \"normal\"; value: Normal };\n\nexport type Document = {\n\tpackagePath: string;\n\tpath: string;\n};\n\nexport type Library = {\n\tpath: string;\n};\n\nexport type Normal = {\n\tpackageId: string;\n\tpath: string;\n};\n\nexport namespace Module {\n\texport let toUrl = (module: Module): string => {\n\t\tlet data = encoding.hex.encode(\n\t\t\tencoding.utf8.encode(encoding.json.encode(module)),\n\t\t);\n\t\treturn `tangram://${data}/${module.value.path}`;\n\t};\n\n\texport let fromUrl = (url: string): Module => {\n\t\tlet match = url.match(/^tangram:\\/\\/([0-9a-f]+)/);\n\t\tassert(match);\n\t\tlet [_, data] = match;\n\t\tassert(data !== undefined);\n\t\treturn encoding.json.decode(\n\t\t\tencoding.utf8.decode(encoding.hex.decode(data)),\n\t\t) as Module;\n\t};\n}\n", "import { Artifact } from \"./artifact.ts\";\nimport { assert as assert_, unreachable } from \"./assert.ts\";\nimport { Checksum } from \"./checksum.ts\";\nimport * as encoding from \"./encoding.ts\";\nimport { Module } from \"./module.ts\";\nimport {\n\tArgs,\n\tMaybeNestedArray,\n\tMutationMap,\n\tapply,\n\tflatten,\n\tmutation,\n} from \"./mutation.ts\";\nimport { Object_ } from \"./object.ts\";\nimport { Package } from \"./package.ts\";\nimport { MaybePromise, Unresolved, resolve } from \"./resolve.ts\";\nimport * as syscall from \"./syscall.ts\";\nimport { System } from \"./system.ts\";\nimport { Template, template } from \"./template.ts\";\nimport { Value } from \"./value.ts\";\n\nlet current: Target;\nexport let getCurrent = (): Target => {\n\treturn current;\n};\nexport let setCurrent = (target: Target) => {\n\tcurrent = target;\n};\n\nexport let functions: Record<string, Function> = {};\n\ntype FunctionArg<\n\tA extends Array<Value> = Array<Value>,\n\tR extends Value = Value,\n> = {\n\turl: string;\n\tname: string;\n\tfunction: (...args: A) => Unresolved<R>;\n};\n\nexport function target<\n\tA extends Array<Value> = Array<Value>,\n\tR extends Value = Value,\n>(args: FunctionArg): Target<A, R>;\nexport function target<\n\tA extends Array<Value> = Array<Value>,\n\tR extends Value = Value,\n>(...args: Args<Target.Arg>): Promise<Target<A, R>>;\nexport function target<\n\tA extends Array<Value> = Array<Value>,\n\tR extends Value = Value,\n>(...args: [FunctionArg<A, R>] | Args<Target.Arg>): MaybePromise<Target<A, R>> {\n\tif (\n\t\targs.length === 1 &&\n\t\ttypeof args[0] === \"object\" &&\n\t\t\"function\" in args[0]\n\t) {\n\t\t// Register the function.\n\t\tlet arg = args[0];\n\t\tlet { url, name } = arg;\n\t\tlet key = encoding.json.encode({ url, name });\n\t\tassert_(functions[key] === undefined);\n\t\tfunctions[key] = arg.function;\n\n\t\t// Get the package.\n\t\tlet module_ = Module.fromUrl(arg.url);\n\t\tassert_(module_.kind === \"normal\");\n\t\tlet package_ = Package.withId(module_.value.packageId);\n\n\t\t// Create the target.\n\t\treturn new Target({\n\t\t\tobject: {\n\t\t\t\thost: \"js-js\",\n\t\t\t\texecutable: new Template([module_.value.path]),\n\t\t\t\tpackage: package_,\n\t\t\t\tname: arg.name,\n\t\t\t\targs: [],\n\t\t\t\tenv: {},\n\t\t\t\tchecksum: undefined,\n\t\t\t\tunsafe: false,\n\t\t\t},\n\t\t});\n\t} else {\n\t\treturn Target.new(...args);\n\t}\n}\n\nexport let build = async (\n\t...args: Array<Unresolved<Target.Arg>>\n): Promise<Value> => {\n\treturn await (await target(...args)).build();\n};\n\nexport interface Target<\n\tA extends Array<Value> = Array<Value>,\n\tR extends Value = Value,\n> extends globalThis.Function {\n\t(...args: { [K in keyof A]: Unresolved<A[K]> }): Promise<R>;\n}\n\nexport class Target<\n\tA extends Array<Value> = Array<Value>,\n\tR extends Value = Value,\n> extends globalThis.Function {\n\t#state: Target.State;\n\n\tconstructor(state: Target.State) {\n\t\tsuper();\n\t\tthis.#state = state;\n\t\tlet this_ = this as any;\n\t\treturn new Proxy(this_, {\n\t\t\tget(_target, prop, _receiver) {\n\t\t\t\tif (typeof this_[prop] === \"function\") {\n\t\t\t\t\treturn this_[prop].bind(this_);\n\t\t\t\t} else {\n\t\t\t\t\treturn this_[prop];\n\t\t\t\t}\n\t\t\t},\n\t\t\tapply: async (_target, _, args) => {\n\t\t\t\tlet target = await Target.new(this_ as any, {\n\t\t\t\t\targs: (await resolve(args)) as Array<Value>,\n\t\t\t\t});\n\t\t\t\treturn await target.build();\n\t\t\t},\n\t\t\tgetPrototypeOf: (_target) => {\n\t\t\t\treturn Object.getPrototypeOf(this_);\n\t\t\t},\n\t\t});\n\t}\n\n\tget state(): Target.State {\n\t\treturn this.#state;\n\t}\n\n\tstatic withId(id: Target.Id): Target {\n\t\treturn new Target({ id });\n\t}\n\n\tstatic async new<\n\t\tA extends Array<Value> = Array<Value>,\n\t\tR extends Value = Value,\n\t>(...args: Args<Target.Arg>): Promise<Target<A, R>> {\n\t\ttype Apply = {\n\t\t\thost?: System;\n\t\t\texecutable?: Template.Arg;\n\t\t\tpackage?: Package | undefined;\n\t\t\tname?: string | undefined;\n\t\t\tenv?: MaybeNestedArray<MutationMap>;\n\t\t\targs?: Array<Value>;\n\t\t\tchecksum?: Checksum | undefined;\n\t\t\tunsafe?: boolean;\n\t\t};\n\t\tlet {\n\t\t\thost,\n\t\t\texecutable: executable_,\n\t\t\tpackage: package_,\n\t\t\tname,\n\t\t\tenv: env_,\n\t\t\targs: args_,\n\t\t\tchecksum,\n\t\t\tunsafe: unsafe_,\n\t\t} = await apply<Target.Arg, Apply>(args, async (arg) => {\n\t\t\tif (\n\t\t\t\ttypeof arg === \"string\" ||\n\t\t\t\tArtifact.is(arg) ||\n\t\t\t\targ instanceof Template\n\t\t\t) {\n\t\t\t\treturn {\n\t\t\t\t\thost: (await getCurrent().env())[\"TANGRAM_HOST\"] as System,\n\t\t\t\t\texecutable: \"/bin/sh\",\n\t\t\t\t\targs: [\"-c\", arg],\n\t\t\t\t};\n\t\t\t} else if (Target.is(arg)) {\n\t\t\t\treturn await arg.object();\n\t\t\t} else if (typeof arg === \"object\") {\n\t\t\t\tlet object: MutationMap<Apply> = {};\n\t\t\t\tif (\"env\" in arg) {\n\t\t\t\t\tobject.env =\n\t\t\t\t\t\targ.env !== undefined\n\t\t\t\t\t\t\t? await mutation({ kind: \"array_append\", values: [arg.env] })\n\t\t\t\t\t\t\t: await mutation({ kind: \"unset\" });\n\t\t\t\t}\n\t\t\t\tif (\"args\" in arg) {\n\t\t\t\t\tobject.args =\n\t\t\t\t\t\targ.args !== undefined\n\t\t\t\t\t\t\t? await mutation({\n\t\t\t\t\t\t\t\t\tkind: \"array_append\",\n\t\t\t\t\t\t\t\t\tvalues: [...arg.args],\n\t\t\t\t\t\t\t  })\n\t\t\t\t\t\t\t: await mutation({ kind: \"unset\" });\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\t...arg,\n\t\t\t\t\t...object,\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\treturn unreachable();\n\t\t\t}\n\t\t});\n\t\tif (!host) {\n\t\t\tthrow new Error(\"Cannot create a target without a host.\");\n\t\t}\n\t\tif (!executable_) {\n\t\t\tthrow new Error(\"Cannot create a target without an executable.\");\n\t\t}\n\t\tlet executable = await template(executable_);\n\t\tlet env = await apply(flatten(env_ ?? []), async (arg) => arg);\n\t\targs_ ??= [];\n\t\tunsafe_ ??= false;\n\t\treturn new Target({\n\t\t\tobject: {\n\t\t\t\thost,\n\t\t\t\texecutable,\n\t\t\t\tpackage: package_,\n\t\t\t\tname,\n\t\t\t\tenv,\n\t\t\t\targs: args_,\n\t\t\t\tchecksum,\n\t\t\t\tunsafe: unsafe_,\n\t\t\t},\n\t\t});\n\t}\n\n\tstatic is(value: unknown): value is Target {\n\t\treturn value instanceof Target;\n\t}\n\n\tstatic expect(value: unknown): Target {\n\t\tassert_(Target.is(value));\n\t\treturn value;\n\t}\n\n\tstatic assert(value: unknown): asserts value is Target {\n\t\tassert_(Target.is(value));\n\t}\n\n\tasync id(): Promise<Target.Id> {\n\t\tawait this.store();\n\t\treturn this.#state.id!;\n\t}\n\n\tasync object(): Promise<Target.Object_> {\n\t\tawait this.load();\n\t\treturn this.#state.object!;\n\t}\n\n\tasync load() {\n\t\tif (this.#state.object === undefined) {\n\t\t\tlet object = await syscall.load(this.#state.id!);\n\t\t\tassert_(object.kind === \"target\");\n\t\t\tthis.#state.object = object.value;\n\t\t}\n\t}\n\n\tasync store() {\n\t\tif (this.#state.id === undefined) {\n\t\t\tthis.#state.id = await syscall.store({\n\t\t\t\tkind: \"target\",\n\t\t\t\tvalue: this.#state.object!,\n\t\t\t});\n\t\t}\n\t}\n\n\tasync host(): Promise<System> {\n\t\treturn (await this.object()).host;\n\t}\n\n\tasync executable(): Promise<Template> {\n\t\treturn (await this.object()).executable;\n\t}\n\n\tasync package(): Promise<Package | undefined> {\n\t\treturn (await this.object()).package;\n\t}\n\n\tasync name_(): Promise<string | undefined> {\n\t\treturn (await this.object()).name;\n\t}\n\n\tasync env(): Promise<Record<string, Value>> {\n\t\treturn (await this.object()).env;\n\t}\n\n\tasync args(): Promise<Array<Value>> {\n\t\treturn (await this.object()).args;\n\t}\n\n\tasync checksum(): Promise<Checksum | undefined> {\n\t\treturn (await this.object()).checksum;\n\t}\n\n\tasync unsafe(): Promise<boolean> {\n\t\treturn (await this.object()).unsafe;\n\t}\n\n\tasync build(...args: A): Promise<Value> {\n\t\treturn await syscall.build(\n\t\t\tawait Target.new<[], R>(this as Target, { args }),\n\t\t);\n\t}\n}\n\nexport namespace Target {\n\texport type Arg =\n\t\t| undefined\n\t\t| string\n\t\t| Artifact\n\t\t| Template\n\t\t| Target\n\t\t| ArgObject\n\t\t| Array<Arg>;\n\n\texport type ArgObject = {\n\t\thost?: System;\n\t\texecutable?: Template.Arg;\n\t\tpackage?: Package | undefined;\n\t\tname?: string | undefined;\n\t\tenv?: MutationMap;\n\t\targs?: Array<Value>;\n\t\tchecksum?: Checksum | undefined;\n\t\tunsafe?: boolean;\n\t};\n\n\texport type Id = string;\n\n\texport type Object_ = {\n\t\thost: System;\n\t\texecutable: Template;\n\t\tpackage: Package | undefined;\n\t\tname: string | undefined;\n\t\tenv: Record<string, Value>;\n\t\targs: Array<Value>;\n\t\tchecksum: Checksum | undefined;\n\t\tunsafe: boolean;\n\t};\n\n\texport type State = Object_.State<Target.Id, Target.Object_>;\n}\n", "import { Blob } from \"./blob.ts\";\nimport { Branch } from \"./branch.ts\";\nimport { Directory } from \"./directory.ts\";\nimport { File } from \"./file.ts\";\nimport { Leaf } from \"./leaf.ts\";\nimport { Mutation } from \"./mutation.ts\";\nimport { Package } from \"./package.ts\";\nimport { Symlink } from \"./symlink.ts\";\nimport { Target } from \"./target.ts\";\nimport { Template } from \"./template.ts\";\nimport { Value } from \"./value.ts\";\n\nexport type Unresolved<T extends Value> = MaybePromise<\n\tT extends\n\t\t| undefined\n\t\t| boolean\n\t\t| number\n\t\t| string\n\t\t| Uint8Array\n\t\t| Blob\n\t\t| Directory\n\t\t| File\n\t\t| Symlink\n\t\t| Template\n\t\t| Mutation\n\t\t| Package\n\t\t| Target\n\t\t? T\n\t\t: T extends Array<infer U extends Value>\n\t\t? Array<Unresolved<U>>\n\t\t: T extends { [key: string]: Value }\n\t\t? { [K in keyof T]: Unresolved<T[K]> }\n\t\t: never\n>;\n\nexport type Resolved<T extends Unresolved<Value>> = T extends\n\t| undefined\n\t| boolean\n\t| number\n\t| string\n\t| Uint8Array\n\t| Blob\n\t| Directory\n\t| File\n\t| Symlink\n\t| Template\n\t| Mutation\n\t| Package\n\t| Target\n\t? T\n\t: T extends Promise<infer U extends Unresolved<Value>>\n\t? Resolved<U>\n\t: T extends Array<infer U extends Unresolved<Value>>\n\t? Array<Resolved<U>>\n\t: T extends { [key: string]: Unresolved<Value> }\n\t? { [K in keyof T]: Resolved<T[K]> }\n\t: never;\n\nexport type MaybePromise<T> = T | Promise<T>;\n\nexport let resolve = async <T extends Unresolved<Value>>(\n\tvalue: T,\n): Promise<Resolved<T>> => {\n\tvalue = await value;\n\tif (\n\t\tvalue === undefined ||\n\t\ttypeof value === \"boolean\" ||\n\t\ttypeof value === \"number\" ||\n\t\ttypeof value === \"string\" ||\n\t\tvalue instanceof Uint8Array ||\n\t\tvalue instanceof Leaf ||\n\t\tvalue instanceof Branch ||\n\t\tvalue instanceof Directory ||\n\t\tvalue instanceof File ||\n\t\tvalue instanceof Symlink ||\n\t\tvalue instanceof Template ||\n\t\tvalue instanceof Mutation ||\n\t\tvalue instanceof Package ||\n\t\tvalue instanceof Target\n\t) {\n\t\treturn value as unknown as Resolved<T>;\n\t} else if (value instanceof Array) {\n\t\treturn (await Promise.all(\n\t\t\tvalue.map((value) => resolve(value)),\n\t\t)) as Resolved<T>;\n\t} else if (typeof value === \"object\") {\n\t\treturn Object.fromEntries(\n\t\t\tawait Promise.all(\n\t\t\t\tObject.entries(value).map(async ([key, value]) => [\n\t\t\t\t\tkey,\n\t\t\t\t\tawait resolve(value),\n\t\t\t\t]),\n\t\t\t),\n\t\t) as Resolved<T>;\n\t} else {\n\t\tthrow new Error(\"Invalid value to resolve.\");\n\t}\n};\n", "import { Artifact } from \"./artifact.ts\";\nimport { assert, assert as assert_ } from \"./assert.ts\";\nimport { Blob } from \"./blob.ts\";\nimport { Directory } from \"./directory.ts\";\nimport { File } from \"./file.ts\";\nimport { Package } from \"./package.ts\";\nimport { Unresolved, resolve } from \"./resolve.ts\";\nimport { Symlink } from \"./symlink.ts\";\nimport { Target } from \"./target.ts\";\nimport { Template, template } from \"./template.ts\";\nimport { Value } from \"./value.ts\";\n\nexport type Args<T extends Value = Value> = Array<\n\tUnresolved<MaybeNestedArray<MaybeMutationMap<T>>>\n>;\n\nexport type MaybeMutationMap<T extends Value = Value> = T extends\n\t| undefined\n\t| boolean\n\t| number\n\t| string\n\t| Uint8Array\n\t| Blob\n\t| Directory\n\t| File\n\t| Symlink\n\t| Template\n\t| Mutation\n\t| Package\n\t| Target\n\t| Array<infer _U extends Value>\n\t? T\n\t: T extends { [key: string]: Value }\n\t? MutationMap<T>\n\t: never;\n\nexport type MutationMap<\n\tT extends { [key: string]: Value } = { [key: string]: Value },\n> = {\n\t[K in keyof T]?: MaybeMutation<T[K]>;\n};\n\nexport type MaybeMutation<T extends Value = Value> = T | Mutation<T>;\n\nexport type MaybeNestedArray<T> = T | Array<MaybeNestedArray<T>>;\n\nexport async function mutation<T extends Value = Value>(\n\targ: Unresolved<Mutation.Arg<T>>,\n): Promise<Mutation<T>> {\n\treturn await Mutation.new(arg);\n}\n\nexport let apply = async <\n\tA extends Value = Value,\n\tR extends { [key: string]: Value } = { [key: string]: Value },\n>(\n\targs: Args<A>,\n\tmap: (\n\t\targ: Exclude<A, Array<Value>>,\n\t) => Promise<MaybeNestedArray<MutationMap<R>>>,\n): Promise<Partial<R>> => {\n\treturn flatten(\n\t\tawait Promise.all(\n\t\t\tflatten(await Promise.all(args.map(resolve))).map((arg) =>\n\t\t\t\tmap(arg as unknown as Exclude<A, Array<Value>>),\n\t\t\t),\n\t\t),\n\t).reduce(async (object, mutations) => {\n\t\tfor (let [key, mutation] of Object.entries(mutations)) {\n\t\t\tawait mutate(await object, key, mutation);\n\t\t}\n\t\treturn object;\n\t}, Promise.resolve({}));\n};\n\nexport class Mutation<T extends Value = Value> {\n\t#inner: Mutation.Inner;\n\n\tconstructor(inner: Mutation.Inner) {\n\t\tthis.#inner = inner;\n\t}\n\n\tstatic async new<T extends Value = Value>(\n\t\tunresolvedArg: Unresolved<Mutation.Arg<T>>,\n\t): Promise<Mutation<T>> {\n\t\tlet arg = await resolve(unresolvedArg);\n\t\tif (arg.kind === \"array_prepend\" || arg.kind === \"array_append\") {\n\t\t\treturn new Mutation({ kind: arg.kind, value: flatten(arg.values) });\n\t\t} else if (\n\t\t\targ.kind === \"template_prepend\" ||\n\t\t\targ.kind === \"template_append\"\n\t\t) {\n\t\t\treturn new Mutation({\n\t\t\t\tkind: arg.kind,\n\t\t\t\tvalue: await template(arg.template),\n\t\t\t\tseparator: await template(arg.separator),\n\t\t\t});\n\t\t} else if (arg.kind === \"unset\") {\n\t\t\treturn new Mutation({ kind: \"unset\" });\n\t\t} else {\n\t\t\treturn new Mutation({ kind: arg.kind, value: arg.value });\n\t\t}\n\t}\n\n\t/** Check if a value is a `tg.Mutation`. */\n\tstatic is(value: unknown): value is Mutation {\n\t\treturn value instanceof Mutation;\n\t}\n\n\t/** Expect that a value is a `tg.Mutation`. */\n\tstatic expect(value: unknown): Mutation {\n\t\tassert_(Mutation.is(value));\n\t\treturn value;\n\t}\n\n\t/** Assert that a value is a `tg.Mutation`. */\n\tstatic assert(value: unknown): asserts value is Mutation {\n\t\tassert_(Mutation.is(value));\n\t}\n\n\tget inner() {\n\t\treturn this.#inner;\n\t}\n}\n\nexport namespace Mutation {\n\texport type Arg<T extends Value = Value> =\n\t\t| { kind: \"unset\" }\n\t\t| { kind: \"set\"; value: T }\n\t\t| { kind: \"set_if_unset\"; value: T }\n\t\t| {\n\t\t\t\tkind: \"array_prepend\";\n\t\t\t\tvalues: T extends Array<infer U> ? MaybeNestedArray<U> : never;\n\t\t  }\n\t\t| {\n\t\t\t\tkind: \"array_append\";\n\t\t\t\tvalues: T extends Array<infer U> ? MaybeNestedArray<U> : never;\n\t\t  }\n\t\t| {\n\t\t\t\tkind: \"template_prepend\";\n\t\t\t\ttemplate: T extends Template.Arg ? Template.Arg : never;\n\t\t\t\tseparator?: Template.Arg;\n\t\t  }\n\t\t| {\n\t\t\t\tkind: \"template_append\";\n\t\t\t\ttemplate: T extends Template.Arg ? Template.Arg : never;\n\t\t\t\tseparator?: Template.Arg;\n\t\t  };\n\n\texport type Inner =\n\t\t| { kind: \"unset\" }\n\t\t| { kind: \"set\"; value: Value }\n\t\t| { kind: \"set_if_unset\"; value: Value }\n\t\t| {\n\t\t\t\tkind: \"array_prepend\";\n\t\t\t\tvalue: Array<Value>;\n\t\t  }\n\t\t| {\n\t\t\t\tkind: \"array_append\";\n\t\t\t\tvalue: Array<Value>;\n\t\t  }\n\t\t| {\n\t\t\t\tkind: \"template_prepend\";\n\t\t\t\tvalue: Template;\n\t\t\t\tseparator: Template;\n\t\t  }\n\t\t| {\n\t\t\t\tkind: \"template_append\";\n\t\t\t\tvalue: Template;\n\t\t\t\tseparator: Template;\n\t\t  };\n}\n\nexport let flatten = <T>(value: MaybeNestedArray<T>): Array<T> => {\n\t// @ts-ignore\n\treturn value instanceof Array ? value.flat(Infinity) : [value];\n};\n\nlet mutate = async (\n\tobject: { [key: string]: Value },\n\tkey: string,\n\tmutation: MaybeMutation,\n) => {\n\tif (!(mutation instanceof Mutation)) {\n\t\tobject[key] = mutation;\n\t} else if (mutation.inner.kind === \"unset\") {\n\t\tdelete object[key];\n\t} else if (mutation.inner.kind === \"set\") {\n\t\tobject[key] = mutation.inner.value;\n\t} else if (mutation.inner.kind === \"set_if_unset\") {\n\t\tif (!(key in object)) {\n\t\t\tobject[key] = mutation.inner.value;\n\t\t}\n\t} else if (mutation.inner.kind === \"array_prepend\") {\n\t\tif (!(key in object)) {\n\t\t\tobject[key] = [];\n\t\t}\n\t\tlet array = object[key];\n\t\tassert(array instanceof Array);\n\t\tarray.unshift(...flatten(mutation.inner.value));\n\t} else if (mutation.inner.kind === \"array_append\") {\n\t\tif (!(key in object)) {\n\t\t\tobject[key] = [];\n\t\t}\n\t\tlet array = object[key];\n\t\tassert(array instanceof Array);\n\t\tarray.push(...flatten(mutation.inner.value));\n\t} else if (mutation.inner.kind === \"template_prepend\") {\n\t\tif (!(key in object)) {\n\t\t\tobject[key] = await template();\n\t\t}\n\t\tlet value = object[key];\n\t\tassert(\n\t\t\tvalue === undefined ||\n\t\t\t\ttypeof value === \"string\" ||\n\t\t\t\tArtifact.is(value) ||\n\t\t\t\tvalue instanceof Template,\n\t\t);\n\t\tobject[key] = await Template.join(\n\t\t\tmutation.inner.separator,\n\t\t\tmutation.inner.value,\n\t\t\tvalue,\n\t\t);\n\t} else if (mutation.inner.kind === \"template_append\") {\n\t\tif (!(key in object)) {\n\t\t\tobject[key] = await template();\n\t\t}\n\t\tlet value = object[key];\n\t\tassert(\n\t\t\tvalue === undefined ||\n\t\t\t\ttypeof value === \"string\" ||\n\t\t\t\tArtifact.is(value) ||\n\t\t\t\tvalue instanceof Template,\n\t\t);\n\t\tobject[key] = await Template.join(\n\t\t\tmutation.inner.separator,\n\t\t\tvalue,\n\t\t\tmutation.inner.value,\n\t\t);\n\t}\n};\n", "import { Artifact } from \"./artifact.ts\";\nimport { assert as assert_, unreachable } from \"./assert.ts\";\nimport { Blob } from \"./blob.ts\";\nimport * as encoding from \"./encoding.ts\";\nimport { Args, apply, mutation } from \"./mutation.ts\";\nimport { Object_ } from \"./object.ts\";\nimport * as syscall from \"./syscall.ts\";\n\nexport let branch = async (...args: Args<Branch.Arg>): Promise<Branch> => {\n\treturn await Branch.new(...args);\n};\n\nexport class Branch {\n\t#state: Branch.State;\n\n\tconstructor(state: Branch.State) {\n\t\tthis.#state = state;\n\t}\n\n\tget state(): Branch.State {\n\t\treturn this.#state;\n\t}\n\n\tstatic withId(id: Branch.Id): Branch {\n\t\treturn new Branch({ id });\n\t}\n\n\tstatic async new(...args: Args<Branch.Arg>): Promise<Branch> {\n\t\ttype Apply = {\n\t\t\tchildren: Array<Branch.Child>;\n\t\t};\n\t\tlet { children } = await apply<Branch.Arg, Apply>(args, async (arg) => {\n\t\t\tif (arg === undefined) {\n\t\t\t\treturn {};\n\t\t\t} else if (Branch.is(arg)) {\n\t\t\t\treturn {\n\t\t\t\t\tchildren: await mutation({\n\t\t\t\t\t\tkind: \"array_append\",\n\t\t\t\t\t\tvalues: [{ blob: arg, size: await arg.size() }],\n\t\t\t\t\t}),\n\t\t\t\t};\n\t\t\t} else if (typeof arg === \"object\") {\n\t\t\t\treturn {\n\t\t\t\t\tchildren: await mutation({\n\t\t\t\t\t\tkind: \"array_append\",\n\t\t\t\t\t\tvalues: arg.children ?? [],\n\t\t\t\t\t}),\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\treturn unreachable();\n\t\t\t}\n\t\t});\n\t\tchildren ??= [];\n\t\treturn new Branch({ object: { children } });\n\t}\n\n\tstatic is(value: unknown): value is Branch {\n\t\treturn value instanceof Branch;\n\t}\n\n\tstatic expect(value: unknown): Branch {\n\t\tassert_(Branch.is(value));\n\t\treturn value;\n\t}\n\n\tstatic assert(value: unknown): asserts value is Branch {\n\t\tassert_(Branch.is(value));\n\t}\n\n\tasync id(): Promise<Branch.Id> {\n\t\tawait this.store();\n\t\treturn this.#state.id!;\n\t}\n\n\tasync object(): Promise<Branch.Object_> {\n\t\tawait this.load();\n\t\treturn this.#state.object!;\n\t}\n\n\tasync load() {\n\t\tif (this.#state.object === undefined) {\n\t\t\tlet object = await syscall.load(this.#state.id!);\n\t\t\tassert_(object.kind === \"branch\");\n\t\t\tthis.#state.object = object.value;\n\t\t}\n\t}\n\n\tasync store() {\n\t\tif (this.#state.id === undefined) {\n\t\t\tthis.#state.id = await syscall.store({\n\t\t\t\tkind: \"branch\",\n\t\t\t\tvalue: this.#state.object!,\n\t\t\t});\n\t\t}\n\t}\n\n\tasync children(): Promise<Array<Branch.Child>> {\n\t\treturn (await this.object()).children;\n\t}\n\n\tasync size(): Promise<number> {\n\t\treturn (await this.children())\n\t\t\t.map(({ size }) => size)\n\t\t\t.reduce((a, b) => a + b, 0);\n\t}\n\n\tasync bytes(): Promise<Uint8Array> {\n\t\treturn await syscall.read(this);\n\t}\n\n\tasync text(): Promise<string> {\n\t\treturn encoding.utf8.decode(await syscall.read(this));\n\t}\n\n\tasync compress(format: Blob.CompressionFormat): Promise<Blob> {\n\t\treturn await syscall.compress(this, format);\n\t}\n\n\tasync decompress(format: Blob.CompressionFormat): Promise<Blob> {\n\t\treturn await syscall.decompress(this, format);\n\t}\n\n\tasync extract(format: Blob.ArchiveFormat): Promise<Artifact> {\n\t\treturn await syscall.extract(this, format);\n\t}\n}\n\nexport namespace Branch {\n\texport type Arg = undefined | Branch | ArgObject | Array<Arg>;\n\n\texport type ArgObject = {\n\t\tchildren?: Array<Child>;\n\t};\n\n\texport type Child = { blob: Blob; size: number };\n\n\texport type Id = string;\n\n\texport type Object_ = { children: Array<Child> };\n\n\texport type State = Object_.State<Branch.Id, Branch.Object_>;\n}\n", "import { assert as assert_, unreachable } from \"./assert.ts\";\nimport { Branch } from \"./branch.ts\";\nimport { Checksum } from \"./checksum.ts\";\nimport * as encoding from \"./encoding.ts\";\nimport { Leaf } from \"./leaf.ts\";\nimport { Args, apply, mutation } from \"./mutation.ts\";\nimport * as syscall from \"./syscall.ts\";\n\nexport type Blob = Leaf | Branch;\n\nexport let blob = async (...args: Args<Blob.Arg>) => {\n\treturn await Blob.new(...args);\n};\n\nexport let download = async (\n\turl: string,\n\tchecksum: Checksum,\n): Promise<Blob> => {\n\treturn await Blob.download(url, checksum);\n};\n\nexport declare namespace Blob {\n\tlet new_: (...args: Args<Blob.Arg>) => Promise<Blob>;\n\texport { new_ as new };\n}\n\nexport namespace Blob {\n\texport type Arg = undefined | string | Uint8Array | Blob | Array<Arg>;\n\n\texport type Id = string;\n\n\texport type Object_ = Array<[Blob, number]> | Uint8Array;\n\n\texport type ArchiveFormat = \".tar\" | \".zip\";\n\n\texport type CompressionFormat =\n\t\t| \".bz2\"\n\t\t| \".gz\"\n\t\t| \".lz\"\n\t\t| \".xz\"\n\t\t| \".zstd\"\n\t\t| \".zst\";\n\n\texport let new_ = async (...args: Args<Blob.Arg>): Promise<Blob> => {\n\t\ttype Apply = { children: Array<Blob> };\n\t\tlet { children: children_ } = await apply<Blob.Arg, Apply>(\n\t\t\targs,\n\t\t\tasync (arg) => {\n\t\t\t\tif (arg === undefined) {\n\t\t\t\t\treturn {};\n\t\t\t\t} else if (typeof arg === \"string\") {\n\t\t\t\t\tlet blob = new Leaf({\n\t\t\t\t\t\tobject: { bytes: encoding.utf8.encode(arg) },\n\t\t\t\t\t});\n\t\t\t\t\treturn {\n\t\t\t\t\t\tchildren: await mutation({\n\t\t\t\t\t\t\tkind: \"array_append\" as const,\n\t\t\t\t\t\t\tvalues: [blob],\n\t\t\t\t\t\t}),\n\t\t\t\t\t};\n\t\t\t\t} else if (arg instanceof Uint8Array) {\n\t\t\t\t\tlet blob = new Leaf({ object: { bytes: arg } });\n\t\t\t\t\treturn {\n\t\t\t\t\t\tchildren: await mutation({\n\t\t\t\t\t\t\tkind: \"array_append\" as const,\n\t\t\t\t\t\t\tvalues: [blob],\n\t\t\t\t\t\t}),\n\t\t\t\t\t};\n\t\t\t\t} else if (Blob.is(arg)) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tchildren: await mutation({\n\t\t\t\t\t\t\tkind: \"array_append\" as const,\n\t\t\t\t\t\t\tvalues: [arg],\n\t\t\t\t\t\t}),\n\t\t\t\t\t};\n\t\t\t\t} else {\n\t\t\t\t\treturn unreachable();\n\t\t\t\t}\n\t\t\t},\n\t\t);\n\t\tif (!children_ || children_.length === 0) {\n\t\t\treturn new Leaf({\n\t\t\t\tobject: { bytes: new Uint8Array() },\n\t\t\t});\n\t\t} else if (children_.length === 1) {\n\t\t\treturn children_[0]!;\n\t\t} else {\n\t\t\tlet children = await Promise.all(\n\t\t\t\tchildren_.map<Promise<Branch.Child>>(async (blob) => {\n\t\t\t\t\treturn { blob, size: await blob.size() };\n\t\t\t\t}),\n\t\t\t);\n\t\t\treturn new Branch({\n\t\t\t\tobject: { children },\n\t\t\t});\n\t\t}\n\t};\n\tBlob.new = new_;\n\n\texport let is = (value: unknown): value is Blob => {\n\t\treturn Leaf.is(value) || Branch.is(value);\n\t};\n\n\texport let expect = (value: unknown): Blob => {\n\t\tassert_(is(value));\n\t\treturn value;\n\t};\n\n\texport let assert = (value: unknown): asserts value is Blob => {\n\t\tassert_(is(value));\n\t};\n\n\texport let download = async (\n\t\turl: string,\n\t\tchecksum: Checksum,\n\t): Promise<Blob> => {\n\t\treturn await syscall.download(url, checksum);\n\t};\n}\n", "import { Artifact } from \"./artifact.ts\";\nimport { assert as assert_, unreachable } from \"./assert.ts\";\nimport { Blob } from \"./blob.ts\";\nimport { File, file } from \"./file.ts\";\nimport { Object_ } from \"./object.ts\";\nimport { Subpath, subpath } from \"./path.ts\";\nimport { Unresolved, resolve } from \"./resolve.ts\";\nimport { Symlink } from \"./symlink.ts\";\nimport * as syscall from \"./syscall.ts\";\n\nexport let directory = async (...args: Array<Unresolved<Directory.Arg>>) => {\n\treturn await Directory.new(...args);\n};\n\nexport class Directory {\n\t#state: Directory.State;\n\n\tconstructor(state: Directory.State) {\n\t\tthis.#state = state;\n\t}\n\n\tget state(): Directory.State {\n\t\treturn this.#state;\n\t}\n\n\tstatic withId(id: Directory.Id): Directory {\n\t\treturn new Directory({ id });\n\t}\n\n\tstatic async new(\n\t\t...args: Array<Unresolved<Directory.Arg>>\n\t): Promise<Directory> {\n\t\tlet entries = await (\n\t\t\tawait Promise.all(args.map(resolve))\n\t\t).reduce<Promise<Record<string, Artifact>>>(async function reduce(\n\t\t\tpromiseEntries,\n\t\t\targ,\n\t\t) {\n\t\t\tlet entries = await promiseEntries;\n\t\t\tif (arg === undefined) {\n\t\t\t\t// If the arg is undefined, then continue.\n\t\t\t} else if (Directory.is(arg)) {\n\t\t\t\t// If the arg is a directory, then apply each entry.\n\t\t\t\tfor (let [name, entry] of Object.entries(await arg.entries())) {\n\t\t\t\t\t// Get an existing entry.\n\t\t\t\t\tlet existingEntry = entries[name];\n\n\t\t\t\t\t// Merge the existing entry with the entry if they are both directories.\n\t\t\t\t\tif (Directory.is(existingEntry) && Directory.is(entry)) {\n\t\t\t\t\t\tentry = await Directory.new(existingEntry, entry);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Set the entry.\n\t\t\t\t\tentries[name] = entry;\n\t\t\t\t}\n\t\t\t} else if (arg instanceof Array) {\n\t\t\t\tfor (let argEntry of arg) {\n\t\t\t\t\tentries = await reduce(Promise.resolve(entries), argEntry);\n\t\t\t\t}\n\t\t\t} else if (typeof arg === \"object\") {\n\t\t\t\t// If the arg is an object, then apply each entry.\n\t\t\t\tfor (let [key, value] of Object.entries(arg)) {\n\t\t\t\t\t// Separate the first path component from the trailing path components.\n\t\t\t\t\tlet [firstComponent, ...trailingComponents] =\n\t\t\t\t\t\tsubpath(key).components();\n\t\t\t\t\tif (firstComponent === undefined) {\n\t\t\t\t\t\tthrow new Error(\"The path must have at least one component.\");\n\t\t\t\t\t}\n\t\t\t\t\tlet name = firstComponent;\n\n\t\t\t\t\t// Get an existing entry.\n\t\t\t\t\tlet existingEntry = entries[name];\n\n\t\t\t\t\t// Remove the entry if it is not a directory.\n\t\t\t\t\tif (!Directory.is(existingEntry)) {\n\t\t\t\t\t\texistingEntry = undefined;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (trailingComponents.length > 0) {\n\t\t\t\t\t\t// If there are trailing path components, then recurse.\n\t\t\t\t\t\tlet trailingPath = subpath(trailingComponents).toString();\n\n\t\t\t\t\t\t// Merge the entry with the trailing path.\n\t\t\t\t\t\tlet newEntry = await Directory.new(existingEntry, {\n\t\t\t\t\t\t\t[trailingPath]: value,\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\t// Add the entry.\n\t\t\t\t\t\tentries[name] = newEntry;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// If there are no trailing path components, then create the artifact specified by the value.\n\t\t\t\t\t\tif (value === undefined) {\n\t\t\t\t\t\t\tdelete entries[name];\n\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\ttypeof value === \"string\" ||\n\t\t\t\t\t\t\tvalue instanceof Uint8Array ||\n\t\t\t\t\t\t\tBlob.is(value)\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tlet newEntry = await file(value);\n\t\t\t\t\t\t\tentries[name] = newEntry;\n\t\t\t\t\t\t} else if (File.is(value) || Symlink.is(value)) {\n\t\t\t\t\t\t\tentries[name] = value;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tentries[name] = await Directory.new(existingEntry, value);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn unreachable();\n\t\t\t}\n\t\t\treturn entries;\n\t\t}, Promise.resolve({}));\n\t\treturn new Directory({ object: { entries } });\n\t}\n\n\tstatic is(value: unknown): value is Directory {\n\t\treturn value instanceof Directory;\n\t}\n\n\tstatic expect(value: unknown): Directory {\n\t\tassert_(Directory.is(value));\n\t\treturn value;\n\t}\n\n\tstatic assert(value: unknown): asserts value is Directory {\n\t\tassert_(Directory.is(value));\n\t}\n\n\tasync id(): Promise<Directory.Id> {\n\t\tawait this.store();\n\t\treturn this.#state.id!;\n\t}\n\n\tasync object(): Promise<Directory.Object_> {\n\t\tawait this.load();\n\t\treturn this.#state.object!;\n\t}\n\n\tasync load() {\n\t\tif (this.#state.object === undefined) {\n\t\t\tlet object = await syscall.load(this.#state.id!);\n\t\t\tassert_(object.kind === \"directory\");\n\t\t\tthis.#state.object = object.value;\n\t\t}\n\t}\n\n\tasync store() {\n\t\tif (this.#state.id === undefined) {\n\t\t\tthis.#state.id = await syscall.store({\n\t\t\t\tkind: \"directory\",\n\t\t\t\tvalue: this.#state.object!,\n\t\t\t});\n\t\t}\n\t}\n\n\tasync get(arg: string): Promise<Directory | File> {\n\t\tlet artifact = await this.tryGet(arg);\n\t\tassert_(artifact, `Failed to get the directory entry \"${arg}\".`);\n\t\treturn artifact;\n\t}\n\n\tasync tryGet(arg: string): Promise<Directory | File | undefined> {\n\t\tlet artifact: Directory | File = this;\n\t\tlet currentSubpath = subpath();\n\t\tfor (let component of subpath(arg).components()) {\n\t\t\tif (!Directory.is(artifact)) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\tcurrentSubpath.push(component);\n\t\t\tlet entry: Artifact | undefined = (await artifact.entries())[component];\n\t\t\tif (entry === undefined) {\n\t\t\t\treturn undefined;\n\t\t\t} else if (Symlink.is(entry)) {\n\t\t\t\tlet resolved = await entry.resolve({\n\t\t\t\t\tartifact: this,\n\t\t\t\t\tpath: currentSubpath.toString(),\n\t\t\t\t});\n\t\t\t\tif (resolved === undefined) {\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\t\t\t\tartifact = resolved;\n\t\t\t} else {\n\t\t\t\tartifact = entry;\n\t\t\t}\n\t\t}\n\t\treturn artifact;\n\t}\n\n\tasync entries(): Promise<Record<string, Artifact>> {\n\t\tlet entries: Record<string, Artifact> = {};\n\t\tfor await (let [name, artifact] of this) {\n\t\t\tentries[name] = artifact;\n\t\t}\n\t\treturn entries;\n\t}\n\n\tasync bundle(): Promise<Directory> {\n\t\treturn await syscall.bundle(this);\n\t}\n\n\tasync *walk(): AsyncIterableIterator<[Subpath, Artifact]> {\n\t\tfor await (let [name, artifact] of this) {\n\t\t\tyield [subpath(name), artifact];\n\t\t\tif (Directory.is(artifact)) {\n\t\t\t\tfor await (let [entryName, entryArtifact] of artifact.walk()) {\n\t\t\t\t\tyield [subpath(name).join(entryName), entryArtifact];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tasync *[Symbol.asyncIterator](): AsyncIterator<[string, Artifact]> {\n\t\tlet object = await this.object();\n\t\tfor (let [name, artifact] of Object.entries(object.entries)) {\n\t\t\tyield [name, artifact];\n\t\t}\n\t}\n}\n\nexport namespace Directory {\n\texport type Arg = undefined | Directory | ArgObject | Array<Arg>;\n\n\ttype ArgObject = {\n\t\t[name: string]:\n\t\t\t| undefined\n\t\t\t| string\n\t\t\t| Uint8Array\n\t\t\t| Blob\n\t\t\t| Artifact\n\t\t\t| ArgObject;\n\t};\n\n\texport type Id = string;\n\n\texport type Object_ = {\n\t\tentries: Record<string, Artifact>;\n\t};\n\n\texport type State = Object_.State<Directory.Id, Directory.Object_>;\n}\n", "import { assert as assert_ } from \"./assert.ts\";\nimport { Blob } from \"./blob.ts\";\nimport { Directory } from \"./directory.ts\";\nimport { File } from \"./file.ts\";\nimport { Symlink } from \"./symlink.ts\";\nimport * as syscall from \"./syscall.ts\";\n\nexport type Artifact = Directory | File | Symlink;\n\nexport namespace Artifact {\n\texport type Id = string;\n\n\texport let is = (value: unknown): value is Artifact => {\n\t\treturn Directory.is(value) || File.is(value) || Symlink.is(value);\n\t};\n\n\texport let expect = (value: unknown): Artifact => {\n\t\tassert_(is(value));\n\t\treturn value;\n\t};\n\n\texport let assert = (value: unknown): asserts value is Artifact => {\n\t\tassert_(is(value));\n\t};\n\n\texport let archive = async (\n\t\tartifact: Artifact,\n\t\tformat: Blob.ArchiveFormat,\n\t): Promise<Blob> => {\n\t\treturn await syscall.archive(artifact, format);\n\t};\n}\n", "export class Error {\n\tmessage: string;\n\tlocation: Location | undefined;\n\tstack: Array<Location> | undefined;\n\tsource: Error | undefined;\n\n\tconstructor(\n\t\tmessage: string,\n\t\tlocation?: Location,\n\t\tstack?: Array<Location>,\n\t\tsource?: Error,\n\t) {\n\t\tthis.message = message;\n\t\tthis.location = location;\n\t\tthis.stack = stack;\n\t\tthis.source = source;\n\t}\n}\n\ntype Location = { source: string; line: number; column: number };\n\n/** This type is derived from <https://v8.dev/docs/stack-trace-api#customizing-stack-traces>. */\ntype CallSite = {\n\tgetTypeName(): string;\n\tgetFunctionName(): string;\n\tgetMethodName(): string;\n\tgetFileName(): string | undefined;\n\tgetLineNumber(): number | undefined;\n\tgetColumnNumber(): number | undefined;\n\tgetEvalOrigin(): unknown | undefined;\n\tisEval(): boolean;\n\tisNative(): boolean;\n\tisConstructor(): boolean;\n\tisAsync(): boolean;\n\tisPromiseAll(): boolean;\n\t// isPromiseAny(): boolean;\n\tgetPromiseIndex(): number | null;\n};\n\nexport let prepareStackTrace = (\n\t_error: unknown,\n\tstructuredStackTrace: Array<CallSite>,\n) => {\n\tlet callSites = structuredStackTrace.map((callSite) => {\n\t\treturn {\n\t\t\ttypeName: callSite.getTypeName(),\n\t\t\tfunctionName: callSite.getFunctionName(),\n\t\t\tmethodName: callSite.getMethodName(),\n\t\t\tfileName: callSite.getFileName(),\n\t\t\tlineNumber: callSite.getLineNumber(),\n\t\t\tcolumnNumber: callSite.getColumnNumber(),\n\t\t\tisEval: callSite.isEval(),\n\t\t\tisNative: callSite.isNative(),\n\t\t\tisConstructor: callSite.isConstructor(),\n\t\t\tisAsync: callSite.isAsync(),\n\t\t\tisPromiseAll: callSite.isPromiseAll(),\n\t\t\t// isPromiseAny: callSite.isPromiseAny(),\n\t\t\tpromiseIndex: callSite.getPromiseIndex(),\n\t\t};\n\t});\n\treturn { callSites };\n};\n", "import { Artifact } from \"./artifact.ts\";\nimport { assert } from \"./assert.ts\";\nimport { Directory } from \"./directory.ts\";\nimport { Module } from \"./module.ts\";\nimport { Package } from \"./package.ts\";\nimport { Relpath, subpath } from \"./path.ts\";\n\ntype Arg = {\n\turl: string;\n\tpath: Relpath.Arg;\n};\n\nexport let include = async (arg: Arg): Promise<Artifact> => {\n\tlet module_ = Module.fromUrl(arg.url);\n\tassert(module_.kind === \"normal\");\n\tlet package_ = Package.withId(module_.value.packageId);\n\tlet artifact = await package_.artifact();\n\tDirectory.assert(artifact);\n\tlet path = subpath(module_.value.path)\n\t\t.toRelpath()\n\t\t.parent()\n\t\t.join(arg.path)\n\t\t.toSubpath()\n\t\t.toString();\n\tlet includedArtifact = await artifact.get(path);\n\treturn includedArtifact;\n};\n", "import { unreachable } from \"./assert.ts\";\nimport { Branch } from \"./branch.ts\";\nimport { Directory } from \"./directory.ts\";\nimport * as encoding from \"./encoding.ts\";\nimport { File } from \"./file.ts\";\nimport { Leaf } from \"./leaf.ts\";\nimport { Mutation } from \"./mutation.ts\";\nimport { Object_ } from \"./object.ts\";\nimport { Package } from \"./package.ts\";\nimport { Symlink } from \"./symlink.ts\";\nimport * as syscall from \"./syscall.ts\";\nimport { Target } from \"./target.ts\";\nimport { Template } from \"./template.ts\";\n\nexport let log = (...args: Array<unknown>) => {\n\tlet string = args.map((arg) => stringify(arg)).join(\" \") + \"\\n\";\n\tsyscall.log(string);\n};\n\nlet stringify = (value: unknown): string => {\n\treturn stringifyInner(value, new WeakSet());\n};\n\nlet stringifyInner = (value: unknown, visited: WeakSet<object>): string => {\n\tswitch (typeof value) {\n\t\tcase \"string\": {\n\t\t\treturn `\"${value}\"`;\n\t\t}\n\t\tcase \"number\": {\n\t\t\treturn value.toString();\n\t\t}\n\t\tcase \"boolean\": {\n\t\t\treturn value ? \"true\" : \"false\";\n\t\t}\n\t\tcase \"undefined\": {\n\t\t\treturn \"undefined\";\n\t\t}\n\t\tcase \"object\": {\n\t\t\tif (value === null) {\n\t\t\t\treturn \"null\";\n\t\t\t} else {\n\t\t\t\treturn stringifyObject(value, visited);\n\t\t\t}\n\t\t}\n\t\tcase \"function\": {\n\t\t\tif (Target.is(value)) {\n\t\t\t\treturn stringifyObject(value, visited);\n\t\t\t} else {\n\t\t\t\treturn `(function \"${value.name ?? \"(anonymous)\"}\")`;\n\t\t\t}\n\t\t}\n\t\tcase \"symbol\": {\n\t\t\treturn \"(symbol)\";\n\t\t}\n\t\tcase \"bigint\": {\n\t\t\treturn value.toString();\n\t\t}\n\t}\n};\n\nlet stringifyObject = (value: object, visited: WeakSet<object>): string => {\n\tif (visited.has(value)) {\n\t\treturn \"(circular)\";\n\t}\n\tvisited.add(value);\n\tif (value instanceof Array) {\n\t\treturn `[${value\n\t\t\t.map((value) => stringifyInner(value, visited))\n\t\t\t.join(\", \")}]`;\n\t} else if (value instanceof Uint8Array) {\n\t\tlet bytes = encoding.hex.encode(value);\n\t\treturn `(tg.bytes ${bytes})`;\n\t} else if (value instanceof Error) {\n\t\treturn value.message;\n\t} else if (value instanceof Promise) {\n\t\treturn \"(promise)\";\n\t} else if (Leaf.is(value)) {\n\t\treturn stringifyState(\"leaf\", value.state, visited);\n\t} else if (Branch.is(value)) {\n\t\treturn stringifyState(\"branch\", value.state, visited);\n\t} else if (Directory.is(value)) {\n\t\treturn stringifyState(\"directory\", value.state, visited);\n\t} else if (File.is(value)) {\n\t\treturn stringifyState(\"file\", value.state, visited);\n\t} else if (Symlink.is(value)) {\n\t\treturn stringifyState(\"symlink\", value.state, visited);\n\t} else if (Template.is(value)) {\n\t\treturn `\\`${value.components\n\t\t\t.map((component) => {\n\t\t\t\tif (typeof component === \"string\") {\n\t\t\t\t\treturn component;\n\t\t\t\t} else {\n\t\t\t\t\treturn `\\${${stringifyInner(component, visited)}}`;\n\t\t\t\t}\n\t\t\t})\n\t\t\t.join(\"\")}\\``;\n\t} else if (Mutation.is(value)) {\n\t\treturn `(tg.mutation ${stringifyObject(value.inner, visited)})`;\n\t} else if (Package.is(value)) {\n\t\treturn stringifyState(\"package\", value.state, visited);\n\t} else if (Target.is(value)) {\n\t\treturn stringifyState(\"target\", value.state, visited);\n\t} else {\n\t\tlet string = \"\";\n\t\tif (\n\t\t\tvalue.constructor !== undefined &&\n\t\t\tvalue.constructor.name !== \"Object\"\n\t\t) {\n\t\t\tstring += `${value.constructor.name} `;\n\t\t}\n\t\tstring += \"{\";\n\t\tlet entries = Object.entries(value);\n\t\tif (entries.length > 0) {\n\t\t\tstring += \" \";\n\t\t}\n\t\tstring += entries\n\t\t\t.map(([key, value]) => `${key}: ${stringifyInner(value, visited)}`)\n\t\t\t.join(\", \");\n\t\tif (entries.length > 0) {\n\t\t\tstring += \" \";\n\t\t}\n\t\tstring += \"}\";\n\t\treturn string;\n\t}\n};\n\nlet stringifyState = (\n\tkind: string,\n\tstate: Object_.State<string, object>,\n\tvisited: WeakSet<object>,\n): string => {\n\tlet { id, object } = state;\n\tif (id !== undefined) {\n\t\treturn id;\n\t} else if (object !== undefined) {\n\t\treturn `(tg.${kind} ${stringifyObject(object, visited)})`;\n\t} else {\n\t\treturn unreachable();\n\t}\n};\n", "import { assert } from \"./assert.ts\";\nimport * as encoding from \"./encoding.ts\";\nimport { Module } from \"./module.ts\";\nimport { resolve } from \"./resolve.ts\";\nimport { Target, functions, setCurrent } from \"./target.ts\";\nimport { Value } from \"./value.ts\";\n\nexport let main = async (target: Target): Promise<Value> => {\n\t// Load the executable.\n\tlet package_ = await target.package();\n\tassert(package_);\n\tlet packageId = await package_.id();\n\tlet executable = await target.executable();\n\tlet path = executable.components[0];\n\tassert(typeof path === \"string\");\n\tlet module_ = {\n\t\tkind: \"normal\" as const,\n\t\tvalue: { packageId, path },\n\t};\n\tlet url = Module.toUrl(module_);\n\tawait import(url);\n\n\t// Get the target.\n\tlet name = await target.name_();\n\tif (!name) {\n\t\tthrow new Error(\"The target must have a name.\");\n\t}\n\n\t// Get the function.\n\tlet key = encoding.json.encode({ url, name });\n\tlet function_ = functions[key];\n\tif (!function_) {\n\t\tthrow new Error(\"Failed to find the function.\");\n\t}\n\n\t// Set the current target.\n\tsetCurrent(target);\n\n\t// Get the args.\n\tlet args = await target.args();\n\n\t// Call the function.\n\tlet output = await resolve(function_(...args));\n\n\treturn output;\n};\n", "import * as syscall from \"./syscall.ts\";\n\nexport let sleep = async (duration: number) => {\n\treturn await syscall.sleep(duration);\n};\n", "import { assert as assert_ } from \"./assert.ts\";\n\nexport let system = (arg: System.Arg): System => {\n\tif (typeof arg === \"string\") {\n\t\treturn arg;\n\t} else {\n\t\tlet { arch, os } = arg;\n\t\treturn `${arch}-${os}` as System;\n\t}\n};\n\nexport type System =\n\t| \"aarch64-darwin\"\n\t| \"aarch64-linux\"\n\t| \"js-js\"\n\t| \"x86_64-darwin\"\n\t| \"x86_64-linux\";\n\nexport declare namespace System {\n\tlet new_: (arg: System.Arg) => System;\n\texport { new_ as new };\n}\n\nexport namespace System {\n\texport type Arg = System | ArgObject;\n\n\texport type ArgObject = {\n\t\tarch: Arch;\n\t\tos: Os;\n\t};\n\n\texport type Arch = \"aarch64\" | \"js\" | \"x86_64\";\n\n\texport type Os = \"darwin\" | \"js\" | \"linux\";\n\texport let new_ = (arg: System.Arg): System => {\n\t\treturn system(arg);\n\t};\n\tSystem.new = new_;\n\n\texport let is = (value: unknown): value is System => {\n\t\treturn (\n\t\t\tvalue === \"aarch64-darwin\" ||\n\t\t\tvalue === \"aarch64-linux\" ||\n\t\t\tvalue === \"js-js\" ||\n\t\t\tvalue === \"x86_64-darwin\" ||\n\t\t\tvalue === \"x86_64-linux\"\n\t\t);\n\t};\n\n\texport let expect = (value: unknown): System => {\n\t\tassert_(System.is(value));\n\t\treturn value;\n\t};\n\n\texport let assert = (value: unknown): asserts value is System => {\n\t\tassert_(System.is(value));\n\t};\n\n\texport let arch = (system: System): Arch => {\n\t\tswitch (system) {\n\t\t\tcase \"aarch64-darwin\":\n\t\t\tcase \"aarch64-linux\": {\n\t\t\t\treturn \"aarch64\";\n\t\t\t}\n\t\t\tcase \"js-js\": {\n\t\t\t\treturn \"js\";\n\t\t\t}\n\t\t\tcase \"x86_64-linux\":\n\t\t\tcase \"x86_64-darwin\": {\n\t\t\t\treturn \"x86_64\";\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\tthrow new Error(\"Invalid system.\");\n\t\t\t}\n\t\t}\n\t};\n\n\texport let os = (system: System): Os => {\n\t\tswitch (system) {\n\t\t\tcase \"aarch64-darwin\":\n\t\t\tcase \"x86_64-darwin\": {\n\t\t\t\treturn \"darwin\";\n\t\t\t}\n\t\t\tcase \"js-js\": {\n\t\t\t\treturn \"js\";\n\t\t\t}\n\t\t\tcase \"x86_64-linux\":\n\t\t\tcase \"aarch64-linux\": {\n\t\t\t\treturn \"linux\";\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\tthrow new Error(\"Invalid system.\");\n\t\t\t}\n\t\t}\n\t};\n}\n", "import { assert as assert_ } from \"./assert.ts\";\nimport { Blob } from \"./blob.ts\";\nimport { Branch } from \"./branch.ts\";\nimport { Directory } from \"./directory.ts\";\nimport { File } from \"./file.ts\";\nimport { Leaf } from \"./leaf.ts\";\nimport { Mutation } from \"./mutation.ts\";\nimport { Package } from \"./package.ts\";\nimport { Symlink } from \"./symlink.ts\";\nimport { Target } from \"./target.ts\";\nimport { Template } from \"./template.ts\";\n\nexport type Value =\n\t| undefined\n\t| boolean\n\t| number\n\t| string\n\t| Uint8Array\n\t| Blob\n\t| Directory\n\t| File\n\t| Symlink\n\t| Template\n\t| Mutation\n\t| Package\n\t| Target\n\t| Array<Value>\n\t| { [key: string]: Value };\n\nexport namespace Value {\n\texport let is = (value: unknown): value is Value => {\n\t\treturn (\n\t\t\tvalue === undefined ||\n\t\t\ttypeof value === \"boolean\" ||\n\t\t\ttypeof value === \"number\" ||\n\t\t\ttypeof value === \"string\" ||\n\t\t\tvalue instanceof Uint8Array ||\n\t\t\tvalue instanceof Leaf ||\n\t\t\tvalue instanceof Branch ||\n\t\t\tvalue instanceof Directory ||\n\t\t\tvalue instanceof File ||\n\t\t\tvalue instanceof Symlink ||\n\t\t\tvalue instanceof Template ||\n\t\t\tvalue instanceof Package ||\n\t\t\tvalue instanceof Target ||\n\t\t\tvalue instanceof Array ||\n\t\t\ttypeof value === \"object\"\n\t\t);\n\t};\n\n\texport let expect = (value: unknown): Value => {\n\t\tassert_(is(value));\n\t\treturn value;\n\t};\n\n\texport let assert = (value: unknown): asserts value is Value => {\n\t\tassert_(is(value));\n\t};\n}\n", "import { Artifact } from \"./artifact.ts\";\nimport { assert, unimplemented, unreachable } from \"./assert.ts\";\nimport { Blob, blob, download } from \"./blob.ts\";\nimport { Branch, branch } from \"./branch.ts\";\nimport { Directory, directory } from \"./directory.ts\";\nimport * as encoding from \"./encoding.ts\";\nimport { Error as Error_, prepareStackTrace } from \"./error.ts\";\nimport { File, file } from \"./file.ts\";\nimport { include } from \"./include.ts\";\nimport { Leaf, leaf } from \"./leaf.ts\";\nimport { log } from \"./log.ts\";\nimport { main } from \"./main.ts\";\nimport { Args, Mutation, apply, mutation } from \"./mutation.ts\";\nimport { Package } from \"./package.ts\";\nimport { resolve } from \"./resolve.ts\";\nimport { sleep } from \"./sleep.ts\";\nimport { Symlink, symlink } from \"./symlink.ts\";\nimport { System, system } from \"./system.ts\";\nimport { Target, build, getCurrent, target } from \"./target.ts\";\nimport { Template, template } from \"./template.ts\";\nimport { Value } from \"./value.ts\";\n\nObject.defineProperties(Error, {\n\tprepareStackTrace: { value: prepareStackTrace },\n});\n\nObject.defineProperties(globalThis, {\n\tconsole: { value: { log } },\n});\n\nasync function tg(\n\tstrings: TemplateStringsArray,\n\t...placeholders: Args<Template.Arg>\n): Promise<Template> {\n\tlet components: Args<Template.Arg> = [];\n\tfor (let i = 0; i < strings.length - 1; i++) {\n\t\tlet string = strings[i]!;\n\t\tcomponents.push(string);\n\t\tlet placeholder = placeholders[i]!;\n\t\tcomponents.push(placeholder);\n\t}\n\tcomponents.push(strings[strings.length - 1]!);\n\treturn await template(...components);\n}\n\nObject.assign(tg, {\n\tArtifact,\n\tBlob,\n\tBranch,\n\tDirectory,\n\tError: Error_,\n\tFile,\n\tLeaf,\n\tMutation,\n\tPackage,\n\tSymlink,\n\tSystem,\n\tTarget,\n\tTemplate,\n\tValue,\n\tapply,\n\tassert,\n\tblob,\n\tbranch,\n\tbuild,\n\tdirectory,\n\tdownload,\n\tencoding,\n\tfile,\n\tinclude,\n\tleaf,\n\tlog,\n\tmain,\n\tmutation,\n\tresolve,\n\tsleep,\n\tsymlink,\n\tsystem,\n\ttarget,\n\ttemplate,\n\tunimplemented,\n\tunreachable,\n});\n\nObject.defineProperties(tg, {\n\tcurrent: { get: getCurrent },\n});\n\nObject.defineProperties(globalThis, {\n\ttg: { value: tg },\n});\n"],
  "mappings": "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",
  "names": ["assert", "condition", "message", "unimplemented", "unreachable", "encoding_exports", "__export", "base64", "hex", "json", "toml", "utf8", "yaml", "archive", "artifact", "format", "cause", "build", "target", "bundle", "compress", "blob", "format", "cause", "decompress", "download", "url", "checksum", "encoding", "value", "extract", "log", "load", "id", "read", "store", "object", "sleep", "duration", "base64", "value", "encoding", "hex", "json", "toml", "utf8", "yaml", "file", "args", "File", "_File", "#state", "state", "id", "contents_", "executable_", "references_", "apply", "arg", "Blob", "mutation", "ret", "unreachable", "contents", "blob", "executable", "references", "value", "assert", "object", "load", "store", "leaf", "args", "Leaf", "_Leaf", "#state", "state", "id", "bytes_", "apply", "arg", "mutation", "utf8", "unreachable", "size", "bytes", "offset", "entry", "value", "assert", "object", "load", "store", "read", "format", "compress", "decompress", "extract", "Package", "_Package", "#state", "state", "id", "value", "assert", "object", "load", "store", "relpath", "args", "Relpath", "subpath", "Subpath", "_Relpath", "#parents", "#subpath", "arg", "reduce", "path", "component", "unreachable", "other", "i", "string", "Arg", "value", "assert", "#components", "components", "template", "args", "Template", "_Template", "#components", "components", "apply", "arg", "Artifact", "mutation", "unreachable", "component", "lastComponent", "value", "assert", "separator", "separatorTemplate", "argTemplates", "templates", "i", "argTemplate", "symlink", "args", "Symlink", "_Symlink", "#state", "state", "id", "artifact", "path_", "apply", "arg", "mutation", "Artifact", "Template", "assert", "firstComponent", "secondComponent", "unreachable", "path", "relpath", "target", "template", "value", "object", "load", "store", "from", "fromArtifact", "fromPath", "Directory", "Module", "module", "encoding", "url", "match", "assert", "_", "data", "current", "getCurrent", "setCurrent", "target", "functions", "args", "arg", "url", "name", "key", "json", "assert", "module_", "Module", "package_", "Package", "Target", "Template", "build", "_Target", "#state", "state", "this_", "_target", "prop", "_receiver", "_", "resolve", "id", "host", "executable_", "env_", "args_", "checksum", "unsafe_", "apply", "Artifact", "object", "mutation", "unreachable", "executable", "template", "env", "flatten", "value", "load", "store", "resolve", "value", "Leaf", "Branch", "Directory", "File", "Symlink", "Template", "Mutation", "Package", "Target", "key", "mutation", "arg", "Mutation", "apply", "args", "map", "flatten", "resolve", "object", "mutations", "key", "mutate", "_Mutation", "#inner", "inner", "unresolvedArg", "template", "value", "assert", "array", "Artifact", "Template", "branch", "args", "Branch", "_Branch", "#state", "state", "id", "children", "apply", "arg", "mutation", "unreachable", "value", "assert", "object", "load", "store", "size", "a", "b", "read", "utf8", "format", "compress", "decompress", "extract", "blob", "args", "Blob", "download", "url", "checksum", "children_", "apply", "arg", "Leaf", "utf8", "mutation", "unreachable", "children", "Branch", "value", "assert", "directory", "args", "Directory", "_Directory", "#state", "state", "id", "entries", "resolve", "reduce", "promiseEntries", "arg", "name", "entry", "existingEntry", "argEntry", "key", "value", "firstComponent", "trailingComponents", "subpath", "trailingPath", "newEntry", "Blob", "file", "File", "Symlink", "unreachable", "assert", "object", "load", "store", "artifact", "currentSubpath", "component", "resolved", "bundle", "entryName", "entryArtifact", "Artifact", "value", "Directory", "File", "Symlink", "assert", "artifact", "format", "archive", "Error", "message", "location", "stack", "source", "prepareStackTrace", "_error", "structuredStackTrace", "callSite", "include", "arg", "module_", "Module", "assert", "artifact", "Package", "Directory", "path", "subpath", "log", "args", "string", "arg", "stringify", "value", "stringifyInner", "visited", "stringifyObject", "Target", "hex", "Leaf", "stringifyState", "Branch", "Directory", "File", "Symlink", "Template", "component", "Mutation", "Package", "entries", "key", "kind", "state", "id", "object", "unreachable", "main", "target", "package_", "assert", "packageId", "path", "module_", "url", "Module", "name", "key", "json", "function_", "functions", "setCurrent", "args", "resolve", "sleep", "duration", "system", "arg", "arch", "os", "System", "value", "assert", "Value", "value", "Leaf", "Branch", "Directory", "File", "Symlink", "Template", "Package", "Target", "assert", "prepareStackTrace", "log", "tg", "strings", "placeholders", "components", "i", "string", "placeholder", "template", "Artifact", "Blob", "Branch", "Directory", "Error", "File", "Leaf", "Mutation", "Package", "Symlink", "System", "Target", "Template", "Value", "apply", "assert", "blob", "branch", "build", "directory", "download", "encoding_exports", "file", "include", "leaf", "main", "mutation", "resolve", "sleep", "symlink", "system", "target", "unimplemented", "unreachable", "getCurrent"]
}
