{
  "version": 3,
  "sources": ["assert.ts", "encoding.ts", "syscall.ts", "object.ts", "blob.ts", "file.ts", "path.ts", "artifact.ts", "template.ts", "symlink.ts", "directory.ts", "package.ts", "module.ts", "target.ts", "resolve.ts", "args.ts", "error.ts", "include.ts", "log.ts", "main.ts", "system.ts", "value.ts", "runtime.ts"],
  "sourcesContent": ["export let assert: (\n\tcondition: unknown,\n\tmessage?: string,\n) => asserts condition = (condition, message) => {\n\tif (!condition) {\n\t\tthrow new Error(message ?? \"Failed assertion.\");\n\t}\n};\n\nexport let unimplemented = (message?: string): never => {\n\tthrow new Error(message ?? \"Reached unimplemented code.\");\n};\n\nexport let unreachable = (message?: string): never => {\n\tthrow new Error(message ?? \"Reached unreachable code.\");\n};\n\nexport let todo = (): never => {\n\tthrow new Error(\"Reached todo.\");\n};\n", "import * as syscall from \"./syscall.ts\";\n\nexport namespace base64 {\n\texport let decode = (value: string): Uint8Array => {\n\t\treturn syscall.encoding.base64.decode(value);\n\t};\n\n\texport let encode = (value: Uint8Array): string => {\n\t\treturn syscall.encoding.base64.encode(value);\n\t};\n}\n\nexport namespace hex {\n\texport let decode = (value: string): Uint8Array => {\n\t\treturn syscall.encoding.hex.decode(value);\n\t};\n\n\texport let encode = (value: Uint8Array): string => {\n\t\treturn syscall.encoding.hex.encode(value);\n\t};\n}\n\nexport namespace json {\n\texport let decode = (value: string): unknown => {\n\t\treturn syscall.encoding.json.decode(value);\n\t};\n\n\texport let encode = (value: any): string => {\n\t\treturn syscall.encoding.json.encode(value);\n\t};\n}\n\nexport namespace toml {\n\texport let decode = (value: string): unknown => {\n\t\treturn syscall.encoding.toml.decode(value);\n\t};\n\n\texport let encode = (value: any): string => {\n\t\treturn syscall.encoding.toml.encode(value);\n\t};\n}\n\nexport namespace utf8 {\n\texport let decode = (value: Uint8Array): string => {\n\t\treturn syscall.encoding.utf8.decode(value);\n\t};\n\n\texport let encode = (value: string): Uint8Array => {\n\t\treturn syscall.encoding.utf8.encode(value);\n\t};\n}\n\nexport namespace yaml {\n\texport let decode = (value: string): unknown => {\n\t\treturn syscall.encoding.yaml.decode(value);\n\t};\n\n\texport let encode = (value: any): string => {\n\t\treturn syscall.encoding.yaml.encode(value);\n\t};\n}\n", "import { Artifact } from \"./artifact.ts\";\nimport { Blob } from \"./blob.ts\";\nimport { Checksum } from \"./checksum.ts\";\nimport { Directory } from \"./directory.ts\";\nimport { Object_ } from \"./object.ts\";\nimport { Target } from \"./target.ts\";\nimport { Value } from \"./value.ts\";\n\ndeclare global {\n\tfunction syscall(syscall: \"build\", target: Target): Promise<Value>;\n\n\tfunction syscall(syscall: \"bundle\", artifact: Artifact): Promise<Directory>;\n\n\tfunction syscall(\n\t\tsyscall: \"checksum\",\n\t\talgorithm: Checksum.Algorithm,\n\t\tbytes: string | Uint8Array,\n\t): Checksum;\n\n\tfunction syscall(\n\t\tsyscall: \"decompress\",\n\t\tblob: Blob,\n\t\tformat: Blob.CompressionFormat,\n\t): Promise<Blob>;\n\n\tfunction syscall(\n\t\tsyscall: \"download\",\n\t\turl: string,\n\t\tchecksum: Checksum,\n\t): Promise<Blob>;\n\n\tfunction syscall(\n\t\tsyscall: \"encoding_base64_decode\",\n\t\tvalue: string,\n\t): Uint8Array;\n\n\tfunction syscall(\n\t\tsyscall: \"encoding_base64_encode\",\n\t\tvalue: Uint8Array,\n\t): string;\n\n\tfunction syscall(syscall: \"encoding_hex_decode\", value: string): Uint8Array;\n\n\tfunction syscall(syscall: \"encoding_hex_encode\", value: Uint8Array): string;\n\n\tfunction syscall(syscall: \"encoding_json_decode\", value: string): unknown;\n\n\tfunction syscall(syscall: \"encoding_json_encode\", value: any): string;\n\n\tfunction syscall(syscall: \"encoding_toml_decode\", value: string): unknown;\n\n\tfunction syscall(syscall: \"encoding_toml_encode\", value: any): string;\n\n\tfunction syscall(syscall: \"encoding_utf8_decode\", value: Uint8Array): string;\n\n\tfunction syscall(syscall: \"encoding_utf8_encode\", value: string): Uint8Array;\n\n\tfunction syscall(syscall: \"encoding_yaml_decode\", value: string): unknown;\n\n\tfunction syscall(syscall: \"encoding_yaml_encode\", value: any): string;\n\n\tfunction syscall(\n\t\tsyscall: \"extract\",\n\t\tblob: Blob,\n\t\tformat: Blob.ArchiveFormat,\n\t): Promise<Artifact>;\n\n\tfunction syscall(syscall: \"load\", id: Object_.Id): Promise<Object_>;\n\n\tfunction syscall(syscall: \"log\", value: string): void;\n\n\tfunction syscall(syscall: \"read\", blob: Blob): Promise<Uint8Array>;\n\n\tfunction syscall(syscall: \"store\", object: Object_): Promise<Object_.Id>;\n}\n\nexport let build = async (target: Target): Promise<Value> => {\n\ttry {\n\t\treturn await syscall(\"build\", target);\n\t} catch (cause) {\n\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t}\n};\n\nexport let bundle = async (artifact: Artifact): Promise<Directory> => {\n\ttry {\n\t\treturn await syscall(\"bundle\", artifact);\n\t} catch (cause) {\n\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t}\n};\n\nexport let checksum = (\n\talgorithm: Checksum.Algorithm,\n\tbytes: string | Uint8Array,\n): Checksum => {\n\ttry {\n\t\treturn syscall(\"checksum\", algorithm, bytes);\n\t} catch (cause) {\n\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t}\n};\n\nexport let decompress = async (\n\tblob: Blob,\n\tformat: Blob.CompressionFormat,\n): Promise<Blob> => {\n\ttry {\n\t\treturn await syscall(\"decompress\", blob, format);\n\t} catch (cause) {\n\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t}\n};\n\nexport let download = async (\n\turl: string,\n\tchecksum: Checksum,\n): Promise<Blob> => {\n\ttry {\n\t\treturn await syscall(\"download\", url, checksum);\n\t} catch (cause) {\n\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t}\n};\n\nexport let encoding = {\n\tbase64: {\n\t\tdecode: (value: string): Uint8Array => {\n\t\t\ttry {\n\t\t\t\treturn syscall(\"encoding_base64_decode\", value);\n\t\t\t} catch (cause) {\n\t\t\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t\t\t}\n\t\t},\n\n\t\tencode: (value: Uint8Array): string => {\n\t\t\ttry {\n\t\t\t\treturn syscall(\"encoding_base64_encode\", value);\n\t\t\t} catch (cause) {\n\t\t\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t\t\t}\n\t\t},\n\t},\n\n\thex: {\n\t\tdecode: (value: string): Uint8Array => {\n\t\t\ttry {\n\t\t\t\treturn syscall(\"encoding_hex_decode\", value);\n\t\t\t} catch (cause) {\n\t\t\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t\t\t}\n\t\t},\n\n\t\tencode: (value: Uint8Array): string => {\n\t\t\ttry {\n\t\t\t\treturn syscall(\"encoding_hex_encode\", value);\n\t\t\t} catch (cause) {\n\t\t\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t\t\t}\n\t\t},\n\t},\n\n\tjson: {\n\t\tdecode: (value: string): unknown => {\n\t\t\ttry {\n\t\t\t\treturn syscall(\"encoding_json_decode\", value);\n\t\t\t} catch (cause) {\n\t\t\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t\t\t}\n\t\t},\n\n\t\tencode: (value: any): string => {\n\t\t\ttry {\n\t\t\t\treturn syscall(\"encoding_json_encode\", value);\n\t\t\t} catch (cause) {\n\t\t\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t\t\t}\n\t\t},\n\t},\n\n\ttoml: {\n\t\tdecode: (value: string): unknown => {\n\t\t\ttry {\n\t\t\t\treturn syscall(\"encoding_toml_decode\", value);\n\t\t\t} catch (cause) {\n\t\t\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t\t\t}\n\t\t},\n\n\t\tencode: (value: any): string => {\n\t\t\ttry {\n\t\t\t\treturn syscall(\"encoding_toml_encode\", value);\n\t\t\t} catch (cause) {\n\t\t\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t\t\t}\n\t\t},\n\t},\n\n\tutf8: {\n\t\tdecode: (value: Uint8Array): string => {\n\t\t\ttry {\n\t\t\t\treturn syscall(\"encoding_utf8_decode\", value);\n\t\t\t} catch (cause) {\n\t\t\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t\t\t}\n\t\t},\n\n\t\tencode: (value: string): Uint8Array => {\n\t\t\ttry {\n\t\t\t\treturn syscall(\"encoding_utf8_encode\", value);\n\t\t\t} catch (cause) {\n\t\t\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t\t\t}\n\t\t},\n\t},\n\n\tyaml: {\n\t\tdecode: (value: string): unknown => {\n\t\t\ttry {\n\t\t\t\treturn syscall(\"encoding_yaml_decode\", value);\n\t\t\t} catch (cause) {\n\t\t\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t\t\t}\n\t\t},\n\n\t\tencode: (value: any): string => {\n\t\t\ttry {\n\t\t\t\treturn syscall(\"encoding_yaml_encode\", value);\n\t\t\t} catch (cause) {\n\t\t\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t\t\t}\n\t\t},\n\t},\n};\n\nexport let extract = async (\n\tblob: Blob,\n\tformat: Blob.ArchiveFormat,\n): Promise<Artifact> => {\n\ttry {\n\t\treturn await syscall(\"extract\", blob, format);\n\t} catch (cause) {\n\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t}\n};\n\nexport let log = (value: string) => {\n\ttry {\n\t\treturn syscall(\"log\", value);\n\t} catch (cause) {\n\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t}\n};\n\nexport let load = async (id: Object_.Id): Promise<Object_> => {\n\ttry {\n\t\treturn await syscall(\"load\", id);\n\t} catch (cause) {\n\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t}\n};\n\nexport let read = async (blob: Blob): Promise<Uint8Array> => {\n\ttry {\n\t\treturn await syscall(\"read\", blob);\n\t} catch (cause) {\n\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t}\n};\n\nexport let store = async (object: Object_): Promise<Object_.Id> => {\n\ttry {\n\t\treturn await syscall(\"store\", object);\n\t} catch (cause) {\n\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t}\n};\n", "import { Blob } from \"./blob.ts\";\nimport { Directory } from \"./directory.ts\";\nimport { File } from \"./file.ts\";\nimport { Package } from \"./package.ts\";\nimport { Symlink } from \"./symlink.ts\";\nimport { Target } from \"./target.ts\";\n\nexport type Object_ =\n\t| { kind: \"blob\"; value: Blob.Object_ }\n\t| { kind: \"directory\"; value: Directory.Object_ }\n\t| { kind: \"file\"; value: File.Object_ }\n\t| { kind: \"symlink\"; value: Symlink.Object_ }\n\t| { kind: \"package\"; value: Package.Object_ }\n\t| { kind: \"target\"; value: Target.Object_ };\n\nexport namespace Object_ {\n\texport type Id = string;\n\n\texport class Handle {\n\t\t#state: State;\n\n\t\tconstructor(state: State) {\n\t\t\tthis.#state = state;\n\t\t}\n\n\t\tget state(): State {\n\t\t\treturn this.#state;\n\t\t}\n\n\t\tstatic withId(id: Id): Handle {\n\t\t\treturn new Handle({ id, object: undefined });\n\t\t}\n\n\t\tstatic withObject(object: Object_): Handle {\n\t\t\treturn new Handle({ id: undefined, object });\n\t\t}\n\n\t\texpectId(): Id {\n\t\t\tif (this.#state.id === undefined) {\n\t\t\t\tthrow new Error();\n\t\t\t}\n\t\t\treturn this.#state.id;\n\t\t}\n\n\t\texpectObject(): Object_ {\n\t\t\tif (this.#state.object === undefined) {\n\t\t\t\tthrow new Error();\n\t\t\t}\n\t\t\treturn this.#state.object;\n\t\t}\n\n\t\tasync id(): Promise<Id> {\n\t\t\tawait this.store();\n\t\t\treturn this.#state.id!;\n\t\t}\n\n\t\tasync object(): Promise<Object_> {\n\t\t\tawait this.load();\n\t\t\treturn this.#state.object!;\n\t\t}\n\n\t\tasync load() {\n\t\t\tif (this.#state.object === undefined) {\n\t\t\t\tthis.#state.object = await syscall(\"load\", this.#state.id!);\n\t\t\t}\n\t\t}\n\n\t\tasync store() {\n\t\t\tif (this.#state.id === undefined) {\n\t\t\t\tthis.#state.id = await syscall(\"store\", this.#state.object!);\n\t\t\t}\n\t\t}\n\t}\n\n\texport type State = {\n\t\tid: Id | undefined;\n\t\tobject: Object_ | undefined;\n\t};\n}\n", "import { Args } from \"./args.ts\";\nimport { Artifact } from \"./artifact.ts\";\nimport { assert as assert_, unreachable } from \"./assert.ts\";\nimport { Checksum } from \"./checksum.ts\";\nimport * as encoding from \"./encoding.ts\";\nimport { Object_ } from \"./object.ts\";\nimport * as syscall from \"./syscall.ts\";\n\nexport let blob = async (...args: Args<Blob.Arg>) => {\n\treturn await Blob.new(...args);\n};\n\nexport let download = async (\n\turl: string,\n\tchecksum: Checksum,\n): Promise<Blob> => {\n\treturn await Blob.download(url, checksum);\n};\n\nexport class Blob {\n\t#handle: Object_.Handle;\n\n\tconstructor(handle: Object_.Handle) {\n\t\tthis.#handle = handle;\n\t}\n\n\tstatic withId(id: Blob.Id): Blob {\n\t\treturn new Blob(Object_.Handle.withId(id));\n\t}\n\n\tstatic async new(...args: Args<Blob.Arg>): Promise<Blob> {\n\t\ttype Apply = { children: Array<Uint8Array> };\n\t\tlet { children } = await Args.apply<Blob.Arg, Apply>(args, async (arg) => {\n\t\t\tif (arg === undefined) {\n\t\t\t\treturn { children: [] };\n\t\t\t} else if (typeof arg === \"string\") {\n\t\t\t\treturn {\n\t\t\t\t\tchildren: {\n\t\t\t\t\t\tkind: \"append\" as const,\n\t\t\t\t\t\tvalue: encoding.utf8.encode(arg),\n\t\t\t\t\t},\n\t\t\t\t};\n\t\t\t} else if (arg instanceof Uint8Array) {\n\t\t\t\treturn {\n\t\t\t\t\tchildren: {\n\t\t\t\t\t\tkind: \"append\" as const,\n\t\t\t\t\t\tvalue: arg,\n\t\t\t\t\t},\n\t\t\t\t};\n\t\t\t} else if (Blob.is(arg)) {\n\t\t\t\treturn {\n\t\t\t\t\tchildren: { kind: \"append\" as const, value: await arg.bytes() },\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\treturn unreachable();\n\t\t\t}\n\t\t});\n\t\tif (!children || children.length === 0) {\n\t\t\tchildren = [new Uint8Array()];\n\t\t}\n\t\treturn new Blob(\n\t\t\tObject_.Handle.withObject({\n\t\t\t\tkind: \"blob\",\n\t\t\t\tvalue: await Promise.all(\n\t\t\t\t\tchildren.map<Promise<[Blob, number]>>(async (child) => {\n\t\t\t\t\t\tlet childBlob = new Blob(\n\t\t\t\t\t\t\tObject_.Handle.withObject({\n\t\t\t\t\t\t\t\tkind: \"blob\",\n\t\t\t\t\t\t\t\tvalue: child,\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t);\n\t\t\t\t\t\treturn [childBlob, await childBlob.size()];\n\t\t\t\t\t}),\n\t\t\t\t),\n\t\t\t}),\n\t\t);\n\t}\n\n\tstatic async download(url: string, checksum: Checksum): Promise<Blob> {\n\t\treturn await syscall.download(url, checksum);\n\t}\n\n\tstatic is(value: unknown): value is Blob {\n\t\treturn value instanceof Blob;\n\t}\n\n\tstatic expect(value: unknown): Blob {\n\t\tassert_(Blob.is(value));\n\t\treturn value;\n\t}\n\n\tstatic assert(value: unknown): asserts value is Blob {\n\t\tassert_(Blob.is(value));\n\t}\n\n\tasync id(): Promise<Blob.Id> {\n\t\treturn (await this.#handle.id()) as Blob.Id;\n\t}\n\n\tasync object(): Promise<Blob.Object_> {\n\t\tlet object = await this.#handle.object();\n\t\tassert_(object.kind === \"blob\");\n\t\treturn object.value;\n\t}\n\n\tget handle(): Object_.Handle {\n\t\treturn this.#handle;\n\t}\n\n\tasync size(): Promise<number> {\n\t\tlet object = await this.object();\n\t\tif (object instanceof Array) {\n\t\t\treturn object.map(([_, size]) => size).reduce((a, b) => a + b, 0);\n\t\t} else {\n\t\t\treturn object.byteLength;\n\t\t}\n\t}\n\n\tasync bytes(): Promise<Uint8Array> {\n\t\treturn await syscall.read(this);\n\t}\n\n\tasync text(): Promise<string> {\n\t\treturn encoding.utf8.decode(await syscall.read(this));\n\t}\n\n\tasync decompress(format: Blob.CompressionFormat): Promise<Blob> {\n\t\treturn await syscall.decompress(this, format);\n\t}\n\n\tasync extract(format: Blob.ArchiveFormat): Promise<Artifact> {\n\t\treturn await syscall.extract(this, format);\n\t}\n}\n\nexport namespace Blob {\n\texport type Arg = undefined | string | Uint8Array | Blob;\n\n\texport namespace Arg {\n\t\texport let is = (value: unknown): value is Arg => {\n\t\t\treturn (\n\t\t\t\tvalue === undefined ||\n\t\t\t\ttypeof value === \"string\" ||\n\t\t\t\tvalue instanceof Uint8Array ||\n\t\t\t\tBlob.is(value) ||\n\t\t\t\t(value instanceof Array && value.every(Arg.is))\n\t\t\t);\n\t\t};\n\n\t\texport let expect = (value: unknown): Arg => {\n\t\t\tassert_(is(value));\n\t\t\treturn value;\n\t\t};\n\n\t\texport let assert = (value: unknown): asserts value is Arg => {\n\t\t\tassert_(is(value));\n\t\t};\n\t}\n\n\texport type Id = string;\n\n\texport type Object_ = Array<[Blob, number]> | Uint8Array;\n\n\texport type ArchiveFormat = \".tar\" | \".zip\";\n\n\texport type CompressionFormat = \".bz2\" | \".gz\" | \".lz\" | \".xz\" | \".zstd\";\n}\n", "import { Args } from \"./args.ts\";\nimport { Artifact } from \"./artifact.ts\";\nimport { assert as assert_, unreachable } from \"./assert.ts\";\nimport { Blob, blob } from \"./blob.ts\";\nimport { Object_ } from \"./object.ts\";\n\nexport let file = async (...args: Args<File.Arg>) => {\n\treturn await File.new(...args);\n};\n\nexport class File {\n\t#handle: Object_.Handle;\n\n\tconstructor(handle: Object_.Handle) {\n\t\tthis.#handle = handle;\n\t}\n\n\tstatic withId(id: File.Id): File {\n\t\treturn new File(Object_.Handle.withId(id));\n\t}\n\n\tstatic async new(...args: Args<File.Arg>): Promise<File> {\n\t\ttype Apply = {\n\t\t\tcontents: Array<Blob.Arg>;\n\t\t\texecutable: Array<boolean>;\n\t\t\treferences: Array<Artifact>;\n\t\t};\n\t\tlet {\n\t\t\tcontents: contentsArgs,\n\t\t\texecutable: executableArgs,\n\t\t\treferences,\n\t\t} = await Args.apply<File.Arg, Apply>(args, async (arg) => {\n\t\t\tif (Blob.Arg.is(arg)) {\n\t\t\t\treturn { contents: { kind: \"append\" as const, value: arg } };\n\t\t\t} else if (File.is(arg)) {\n\t\t\t\tlet contents = {\n\t\t\t\t\tkind: \"append\" as const,\n\t\t\t\t\tvalue: await arg.contents(),\n\t\t\t\t};\n\t\t\t\tlet executable = {\n\t\t\t\t\tkind: \"append\" as const,\n\t\t\t\t\tvalue: await arg.executable(),\n\t\t\t\t};\n\t\t\t\tlet references = {\n\t\t\t\t\tkind: \"append\" as const,\n\t\t\t\t\tvalue: await arg.references(),\n\t\t\t\t};\n\t\t\t\treturn {\n\t\t\t\t\tcontents,\n\t\t\t\t\texecutable,\n\t\t\t\t\treferences,\n\t\t\t\t};\n\t\t\t} else if (typeof arg === \"object\") {\n\t\t\t\tlet object: Args.MutationObject<Apply> = {};\n\t\t\t\tif (\"contents\" in arg) {\n\t\t\t\t\tobject.contents = {\n\t\t\t\t\t\tkind: \"append\" as const,\n\t\t\t\t\t\tvalue: arg.contents,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tif (\"executable\" in arg) {\n\t\t\t\t\tobject.executable = {\n\t\t\t\t\t\tkind: \"append\" as const,\n\t\t\t\t\t\tvalue: arg.executable,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tif (\"references\" in arg) {\n\t\t\t\t\tobject.references = {\n\t\t\t\t\t\tkind: \"append\" as const,\n\t\t\t\t\t\tvalue: arg.references,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\treturn object;\n\t\t\t} else {\n\t\t\t\treturn unreachable();\n\t\t\t}\n\t\t});\n\t\tlet contents = await blob(contentsArgs);\n\t\tlet executable = (executableArgs ?? []).some((executable) => executable);\n\t\treferences ??= [];\n\t\treturn new File(\n\t\t\tObject_.Handle.withObject({\n\t\t\t\tkind: \"file\",\n\t\t\t\tvalue: { contents, executable, references },\n\t\t\t}),\n\t\t);\n\t}\n\n\tstatic is(value: unknown): value is File {\n\t\treturn value instanceof File;\n\t}\n\n\tstatic expect(value: unknown): File {\n\t\tassert_(File.is(value));\n\t\treturn value;\n\t}\n\n\tstatic assert(value: unknown): asserts value is File {\n\t\tassert_(File.is(value));\n\t}\n\n\tasync id(): Promise<File.Id> {\n\t\treturn (await this.#handle.id()) as File.Id;\n\t}\n\n\tasync object(): Promise<File.Object_> {\n\t\tlet object = await this.#handle.object();\n\t\tassert_(object.kind === \"file\");\n\t\treturn object.value;\n\t}\n\n\tget handle(): Object_.Handle {\n\t\treturn this.#handle;\n\t}\n\n\tasync contents(): Promise<Blob> {\n\t\treturn (await this.object()).contents;\n\t}\n\n\tasync executable(): Promise<boolean> {\n\t\treturn (await this.object()).executable;\n\t}\n\n\tasync references(): Promise<Array<Artifact>> {\n\t\treturn (await this.object()).references;\n\t}\n\n\tasync size(): Promise<number> {\n\t\treturn (await this.contents()).size();\n\t}\n\n\tasync bytes(): Promise<Uint8Array> {\n\t\treturn (await this.contents()).bytes();\n\t}\n\n\tasync text(): Promise<string> {\n\t\treturn (await this.contents()).text();\n\t}\n}\n\nexport namespace File {\n\texport type Arg = Blob.Arg | File | ArgObject;\n\n\texport type ArgObject = {\n\t\tcontents?: Blob.Arg;\n\t\texecutable?: boolean;\n\t\treferences?: Array<Artifact>;\n\t};\n\n\texport type Id = string;\n\n\texport type Object_ = {\n\t\tcontents: Blob;\n\t\texecutable: boolean;\n\t\treferences: Array<Artifact>;\n\t};\n}\n", "import { assert as assert_, unreachable } from \"./assert.ts\";\n\nexport let relpath = (...args: Array<Relpath.Arg>): Relpath => {\n\treturn Relpath.new(...args);\n};\n\nexport let subpath = (...args: Array<Subpath.Arg>): Subpath => {\n\treturn Subpath.new(...args);\n};\n\ntype RelpathConstructorArg = {\n\tparents?: number;\n\tsubpath?: Subpath;\n};\n\nexport class Relpath {\n\t#parents: number;\n\t#subpath: Subpath;\n\n\tconstructor(arg?: RelpathConstructorArg) {\n\t\tthis.#parents = arg?.parents ?? 0;\n\t\tthis.#subpath = arg?.subpath ?? new Subpath();\n\t}\n\n\tstatic new(...args: Array<Relpath.Arg>): Relpath {\n\t\treturn args.reduce(function reduce(path: Relpath, arg: Relpath.Arg) {\n\t\t\tif (typeof arg === \"string\") {\n\t\t\t\tfor (let component of arg.split(\"/\")) {\n\t\t\t\t\tif (component === \"\" || component === \".\") {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else if (component === \"..\") {\n\t\t\t\t\t\tpath = path.parent();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpath.#subpath.push(component);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (arg instanceof Relpath) {\n\t\t\t\tfor (let i = 0; i < arg.#parents; i++) {\n\t\t\t\t\tpath.parent();\n\t\t\t\t}\n\t\t\t\tpath.#subpath.join(arg.#subpath);\n\t\t\t} else if (arg instanceof Subpath) {\n\t\t\t\tpath.#subpath.join(arg);\n\t\t\t} else if (arg instanceof Array) {\n\t\t\t\targ.forEach((arg) => reduce(path, arg));\n\t\t\t} else {\n\t\t\t\treturn unreachable();\n\t\t\t}\n\t\t\treturn path;\n\t\t}, new Relpath());\n\t}\n\n\tisEmpty(): boolean {\n\t\treturn this.#parents == 0 && this.#subpath.isEmpty();\n\t}\n\n\tparents(): number {\n\t\treturn this.#parents;\n\t}\n\n\tsubpath(): Subpath {\n\t\treturn this.#subpath;\n\t}\n\n\tparent(): Relpath {\n\t\tif (this.#subpath.isEmpty()) {\n\t\t\tthis.#parents += 1;\n\t\t} else {\n\t\t\tthis.#subpath.pop();\n\t\t}\n\t\treturn this;\n\t}\n\n\tjoin(other: Relpath.Arg): Relpath {\n\t\tother = Relpath.new(other);\n\t\tfor (let i = 0; i < other.#parents; i++) {\n\t\t\tthis.parent();\n\t\t}\n\t\tthis.#subpath.join(other.#subpath);\n\t\treturn this;\n\t}\n\n\textension(): string | undefined {\n\t\treturn this.#subpath.extension();\n\t}\n\n\ttoSubpath(): Subpath {\n\t\tif (this.#parents > 0) {\n\t\t\tthrow new Error(\"Cannot convert to subpath.\");\n\t\t}\n\t\treturn this.#subpath;\n\t}\n\n\ttoString(): string {\n\t\tlet string = \"\";\n\t\tfor (let i = 0; i < this.#parents; i++) {\n\t\t\tstring += \"../\";\n\t\t}\n\t\tstring += this.#subpath.toString();\n\t\treturn string;\n\t}\n}\n\nexport namespace Relpath {\n\texport type Arg = Subpath.Arg | Relpath | Array<Arg>;\n\n\texport namespace Arg {\n\t\texport let is = (value: unknown): value is Relpath.Arg => {\n\t\t\treturn (\n\t\t\t\tSubpath.Arg.is(value) ||\n\t\t\t\tvalue instanceof Relpath ||\n\t\t\t\t(value instanceof Array && value.every(Relpath.Arg.is))\n\t\t\t);\n\t\t};\n\n\t\texport let expect = (value: unknown): Relpath.Arg => {\n\t\t\tassert_(is(value));\n\t\t\treturn value;\n\t\t};\n\n\t\texport let assert = (value: unknown): asserts value is Relpath.Arg => {\n\t\t\tassert_(is(value));\n\t\t};\n\t}\n}\n\nexport class Subpath {\n\t#components: Array<string>;\n\n\tconstructor(components?: Array<string>) {\n\t\tthis.#components = components ?? [];\n\t}\n\n\tstatic new(...args: Array<Subpath.Arg>): Subpath {\n\t\treturn Relpath.new(...args).toSubpath();\n\t}\n\n\tcomponents(): Array<string> {\n\t\treturn [...this.#components];\n\t}\n\n\tisEmpty(): boolean {\n\t\treturn this.#components.length == 0;\n\t}\n\n\tjoin(other: Subpath): Subpath {\n\t\tthis.#components.push(...other.#components);\n\t\treturn this;\n\t}\n\n\tpush(component: string) {\n\t\tthis.#components.push(component);\n\t}\n\n\tpop() {\n\t\tthis.#components.pop();\n\t}\n\n\textension(): string | undefined {\n\t\treturn this.#components.at(-1)?.split(\".\").at(-1);\n\t}\n\n\ttoRelpath(): Relpath {\n\t\treturn Relpath.new(this);\n\t}\n\n\ttoString(): string {\n\t\treturn this.#components.join(\"/\");\n\t}\n}\n\nexport namespace Subpath {\n\texport type Arg = undefined | string | Subpath | Array<Arg>;\n\n\texport namespace Arg {\n\t\texport let is = (value: unknown): value is Subpath.Arg => {\n\t\t\treturn (\n\t\t\t\tvalue === undefined ||\n\t\t\t\ttypeof value === \"string\" ||\n\t\t\t\tvalue instanceof Subpath ||\n\t\t\t\t(value instanceof Array && value.every(Subpath.Arg.is))\n\t\t\t);\n\t\t};\n\n\t\texport let expect = (value: unknown): Subpath.Arg => {\n\t\t\tassert_(is(value));\n\t\t\treturn value;\n\t\t};\n\n\t\texport let assert = (value: unknown): asserts value is Subpath.Arg => {\n\t\t\tassert_(is(value));\n\t\t};\n\t}\n}\n", "import { assert as assert_ } from \"./assert.ts\";\nimport { Directory } from \"./directory.ts\";\nimport { File } from \"./file.ts\";\nimport { Symlink } from \"./symlink.ts\";\n\nexport type Artifact = Directory | File | Symlink;\n\nexport namespace Artifact {\n\texport type Id = string;\n\n\texport let is = (value: unknown): value is Artifact => {\n\t\treturn Directory.is(value) || File.is(value) || Symlink.is(value);\n\t};\n\n\texport let expect = (value: unknown): Artifact => {\n\t\tassert_(is(value));\n\t\treturn value;\n\t};\n\n\texport let assert = (value: unknown): asserts value is Artifact => {\n\t\tassert_(is(value));\n\t};\n}\n", "import { Args } from \"./args.ts\";\nimport { Artifact } from \"./artifact.ts\";\nimport { assert as assert_, unreachable } from \"./assert.ts\";\nimport { Unresolved } from \"./resolve.ts\";\n\nexport let template = (...args: Args<Template.Arg>): Promise<Template> => {\n\treturn Template.new(...args);\n};\n\nexport class Template {\n\t#components: Array<Template.Component>;\n\n\tconstructor(components: Array<Template.Component>) {\n\t\tthis.#components = components;\n\t}\n\n\tstatic async new(...args: Args<Template.Arg>): Promise<Template> {\n\t\ttype Apply = {\n\t\t\tcomponents: Array<Template.Component>;\n\t\t};\n\t\tlet { components } = await Args.apply<Template.Arg, Apply>(\n\t\t\targs,\n\t\t\tasync (arg) => {\n\t\t\t\tif (arg === undefined) {\n\t\t\t\t\treturn {};\n\t\t\t\t} else if (Template.Component.is(arg)) {\n\t\t\t\t\treturn { components: { kind: \"append\" as const, value: arg } };\n\t\t\t\t} else if (Template.is(arg)) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tcomponents: { kind: \"append\" as const, value: arg.components },\n\t\t\t\t\t};\n\t\t\t\t} else {\n\t\t\t\t\treturn unreachable();\n\t\t\t\t}\n\t\t\t},\n\t\t);\n\n\t\t// Normalize the components.\n\t\tcomponents = (components ?? []).reduce<Array<Template.Component>>(\n\t\t\t(components, component) => {\n\t\t\t\tlet lastComponent = components.at(-1);\n\t\t\t\tif (component === \"\") {\n\t\t\t\t\t// Ignore empty string components.\n\t\t\t\t} else if (\n\t\t\t\t\ttypeof lastComponent === \"string\" &&\n\t\t\t\t\ttypeof component === \"string\"\n\t\t\t\t) {\n\t\t\t\t\t// Merge adjacent string components.\n\t\t\t\t\tcomponents.splice(-1, 1, lastComponent + component);\n\t\t\t\t} else {\n\t\t\t\t\tcomponents.push(component);\n\t\t\t\t}\n\t\t\t\treturn components;\n\t\t\t},\n\t\t\t[],\n\t\t);\n\n\t\treturn new Template(components);\n\t}\n\n\tstatic is(value: unknown): value is Template {\n\t\treturn value instanceof Template;\n\t}\n\n\tstatic expect(value: unknown): Template {\n\t\tassert_(Template.is(value));\n\t\treturn value;\n\t}\n\n\tstatic assert(value: unknown): asserts value is Template {\n\t\tassert_(Template.is(value));\n\t}\n\n\t/** Join an array of templates with a separator. */\n\tstatic async join(\n\t\tseparator: Unresolved<Template.Arg>,\n\t\t...args: Array<Unresolved<Template.Arg>>\n\t): Promise<Template> {\n\t\tlet separatorTemplate = await template(separator);\n\t\tlet argTemplates = await Promise.all(args.map((arg) => template(arg)));\n\t\targTemplates = argTemplates.filter((arg) => arg.components.length > 0);\n\t\tlet templates = [];\n\t\tfor (let i = 0; i < argTemplates.length; i++) {\n\t\t\tif (i > 0) {\n\t\t\t\ttemplates.push(separatorTemplate);\n\t\t\t}\n\t\t\tlet argTemplate = argTemplates[i];\n\t\t\tassert_(argTemplate);\n\t\t\ttemplates.push(argTemplate);\n\t\t}\n\t\treturn template(...templates);\n\t}\n\n\tget components(): Array<Template.Component> {\n\t\treturn this.#components;\n\t}\n}\n\nexport namespace Template {\n\texport type Arg = undefined | Component | Template;\n\n\texport namespace Arg {\n\t\texport let is = (value: unknown): value is Arg => {\n\t\t\treturn (\n\t\t\t\tvalue === undefined ||\n\t\t\t\tComponent.is(value) ||\n\t\t\t\tTemplate.is(value) ||\n\t\t\t\t(value instanceof Array && value.every((value) => Arg.is(value)))\n\t\t\t);\n\t\t};\n\t}\n\n\texport type Component = string | Artifact;\n\n\texport namespace Component {\n\t\texport let is = (value: unknown): value is Component => {\n\t\t\treturn typeof value === \"string\" || Artifact.is(value);\n\t\t};\n\t}\n}\n", "import { Args } from \"./args.ts\";\nimport { Artifact } from \"./artifact.ts\";\nimport { assert as assert_, unreachable } from \"./assert.ts\";\nimport { Directory } from \"./directory.ts\";\nimport { File } from \"./file.ts\";\nimport { Object_ } from \"./object.ts\";\nimport { Relpath, relpath } from \"./path.ts\";\nimport { Unresolved } from \"./resolve.ts\";\nimport { Template, template } from \"./template.ts\";\n\nexport let symlink = async (...args: Args<Symlink.Arg>): Promise<Symlink> => {\n\treturn await Symlink.new(...args);\n};\n\nexport class Symlink {\n\t#handle: Object_.Handle;\n\n\tconstructor(handle: Object_.Handle) {\n\t\tthis.#handle = handle;\n\t}\n\n\tstatic withId(id: Symlink.Id): Symlink {\n\t\treturn new Symlink(Object_.Handle.withId(id));\n\t}\n\n\tstatic async new(...args: Args<Symlink.Arg>): Promise<Symlink> {\n\t\ttype Apply = {\n\t\t\tartifact: Artifact | undefined;\n\t\t\tpath: Array<string> | undefined;\n\t\t};\n\t\tlet { artifact, path: path_ } = await Args.apply<Symlink.Arg, Apply>(\n\t\t\targs,\n\t\t\tasync (arg) => {\n\t\t\t\tif (arg === \"undefined\") {\n\t\t\t\t\treturn { artifact: { kind: \"unset\" as const } };\n\t\t\t\t}\n\t\t\t\tif (typeof arg === \"string\") {\n\t\t\t\t\treturn { path: { kind: \"append\" as const, value: arg } };\n\t\t\t\t} else if (Artifact.is(arg)) {\n\t\t\t\t\treturn { artifact: { kind: \"set\" as const, value: arg } };\n\t\t\t\t} else if (Template.is(arg)) {\n\t\t\t\t\tassert_(arg.components.length <= 2);\n\t\t\t\t\tlet [firstComponent, secondComponent] = arg.components;\n\t\t\t\t\tif (\n\t\t\t\t\t\ttypeof firstComponent === \"string\" &&\n\t\t\t\t\t\tsecondComponent === undefined\n\t\t\t\t\t) {\n\t\t\t\t\t\treturn { path: { kind: \"set\" as const, value: [firstComponent] } };\n\t\t\t\t\t} else if (\n\t\t\t\t\t\tArtifact.is(firstComponent) &&\n\t\t\t\t\t\tsecondComponent === undefined\n\t\t\t\t\t) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tartifact: { kind: \"set\" as const, value: firstComponent },\n\t\t\t\t\t\t};\n\t\t\t\t\t} else if (\n\t\t\t\t\t\tArtifact.is(firstComponent) &&\n\t\t\t\t\t\ttypeof secondComponent === \"string\"\n\t\t\t\t\t) {\n\t\t\t\t\t\tassert_(secondComponent.startsWith(\"/\"));\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tartifact: { kind: \"set\" as const, value: firstComponent },\n\t\t\t\t\t\t\tpath: { kind: \"set\" as const, value: [secondComponent.slice(1)] },\n\t\t\t\t\t\t};\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new Error(\"Invalid template.\");\n\t\t\t\t\t}\n\t\t\t\t} else if (Symlink.is(arg)) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tartifact: { kind: \"set\" as const, value: await arg.artifact() },\n\t\t\t\t\t\tpath: {\n\t\t\t\t\t\t\tkind: \"set\" as const,\n\t\t\t\t\t\t\tvalue: [(await arg.path()).toString()],\n\t\t\t\t\t\t},\n\t\t\t\t\t};\n\t\t\t\t} else if (typeof arg === \"object\") {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tartifact: { kind: \"set\" as const, value: arg.artifact },\n\t\t\t\t\t\tpath: { kind: \"set\" as const, value: arg.path ? [arg.path] : [] },\n\t\t\t\t\t};\n\t\t\t\t} else {\n\t\t\t\t\treturn unreachable();\n\t\t\t\t}\n\t\t\t},\n\t\t);\n\n\t\t// Create the target.\n\t\tlet path = relpath(...(path_ ?? []));\n\t\tlet target;\n\t\tif (artifact !== undefined && !path.isEmpty()) {\n\t\t\ttarget = await template(artifact, \"/\", path.toString());\n\t\t} else if (artifact !== undefined) {\n\t\t\ttarget = await template(artifact);\n\t\t} else if (!path.isEmpty()) {\n\t\t\ttarget = await template(path.toString());\n\t\t} else {\n\t\t\tthrow new Error(\"Invalid symlink.\");\n\t\t}\n\n\t\treturn new Symlink(\n\t\t\tObject_.Handle.withObject({ kind: \"symlink\", value: { target } }),\n\t\t);\n\t}\n\n\tstatic is(value: unknown): value is Symlink {\n\t\treturn value instanceof Symlink;\n\t}\n\n\tstatic expect(value: unknown): Symlink {\n\t\tassert_(Symlink.is(value));\n\t\treturn value;\n\t}\n\n\tstatic assert(value: unknown): asserts value is Symlink {\n\t\tassert_(Symlink.is(value));\n\t}\n\n\tasync id(): Promise<Symlink.Id> {\n\t\treturn (await this.#handle.id()) as Symlink.Id;\n\t}\n\n\tasync object(): Promise<Symlink.Object_> {\n\t\tlet object = await this.#handle.object();\n\t\tassert_(object.kind === \"symlink\");\n\t\treturn object.value;\n\t}\n\n\tget handle(): Object_.Handle {\n\t\treturn this.#handle;\n\t}\n\n\tasync target(): Promise<Template> {\n\t\treturn (await this.object()).target;\n\t}\n\n\tasync artifact(): Promise<Artifact | undefined> {\n\t\tlet target = await this.target();\n\t\tlet firstComponent = target.components.at(0);\n\t\tif (Artifact.is(firstComponent)) {\n\t\t\treturn firstComponent;\n\t\t} else {\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\tasync path(): Promise<Relpath> {\n\t\tlet target = await this.target();\n\t\tlet [firstComponent, secondComponent] = target.components;\n\t\tif (typeof firstComponent === \"string\" && secondComponent === undefined) {\n\t\t\treturn relpath(firstComponent);\n\t\t} else if (Artifact.is(firstComponent) && secondComponent === undefined) {\n\t\t\treturn relpath();\n\t\t} else if (\n\t\t\tArtifact.is(firstComponent) &&\n\t\t\ttypeof secondComponent === \"string\"\n\t\t) {\n\t\t\treturn relpath(secondComponent.slice(1));\n\t\t} else {\n\t\t\tthrow new Error(\"Invalid template.\");\n\t\t}\n\t}\n\n\tasync resolve(\n\t\tfrom?: Unresolved<Symlink.Arg>,\n\t): Promise<Directory | File | undefined> {\n\t\tfrom = from ? await symlink(from) : undefined;\n\t\tlet fromArtifact = await from?.artifact();\n\t\tif (Symlink.is(fromArtifact)) {\n\t\t\tfromArtifact = await fromArtifact.resolve();\n\t\t}\n\t\tlet fromPath = from?.path();\n\t\tlet artifact = await this.artifact();\n\t\tif (Symlink.is(artifact)) {\n\t\t\tartifact = await artifact.resolve();\n\t\t}\n\t\tlet path = await this.path();\n\t\tif (artifact !== undefined && path.isEmpty()) {\n\t\t\treturn artifact;\n\t\t} else if (artifact === undefined && !path.isEmpty()) {\n\t\t\tif (!Directory.is(fromArtifact)) {\n\t\t\t\tthrow new Error(\"Expected a directory.\");\n\t\t\t}\n\t\t\treturn await fromArtifact.tryGet(\n\t\t\t\t(await (fromPath ?? relpath()))\n\t\t\t\t\t.parent()\n\t\t\t\t\t.join(path)\n\t\t\t\t\t.toSubpath()\n\t\t\t\t\t.toString(),\n\t\t\t);\n\t\t} else if (artifact !== undefined && !path.isEmpty()) {\n\t\t\tif (!Directory.is(artifact)) {\n\t\t\t\tthrow new Error(\"Expected a directory.\");\n\t\t\t}\n\t\t\treturn await artifact.tryGet(path.toSubpath().toString());\n\t\t} else {\n\t\t\tthrow new Error(\"Invalid symlink.\");\n\t\t}\n\t}\n}\n\nexport namespace Symlink {\n\texport type Arg =\n\t\t| undefined\n\t\t| string\n\t\t| Artifact\n\t\t| Template\n\t\t| Symlink\n\t\t| ArgObject;\n\n\texport type ArgObject = {\n\t\tartifact?: Artifact;\n\t\tpath?: string | undefined;\n\t};\n\n\texport type Id = string;\n\n\texport type Object_ = { target: Template };\n}\n", "import { Artifact } from \"./artifact.ts\";\nimport { assert as assert_, unreachable } from \"./assert.ts\";\nimport { Blob } from \"./blob.ts\";\nimport { File, file } from \"./file.ts\";\nimport { Object_ } from \"./object.ts\";\nimport { Subpath, subpath } from \"./path.ts\";\nimport { Unresolved, resolve } from \"./resolve.ts\";\nimport { Symlink } from \"./symlink.ts\";\nimport * as syscall from \"./syscall.ts\";\n\nexport let directory = async (...args: Array<Unresolved<Directory.Arg>>) => {\n\treturn await Directory.new(...args);\n};\n\nexport class Directory {\n\t#handle: Object_.Handle;\n\n\tconstructor(handle: Object_.Handle) {\n\t\tthis.#handle = handle;\n\t}\n\n\tstatic withId(id: Directory.Id): Directory {\n\t\treturn new Directory(Object_.Handle.withId(id));\n\t}\n\n\tstatic async new(\n\t\t...args: Array<Unresolved<Directory.Arg>>\n\t): Promise<Directory> {\n\t\tlet entries = await (\n\t\t\tawait Promise.all(args.map(resolve))\n\t\t).reduce<Promise<Record<string, Artifact>>>(async function reduce(\n\t\t\tpromiseEntries,\n\t\t\targ,\n\t\t) {\n\t\t\tlet entries = await promiseEntries;\n\t\t\tif (arg === undefined) {\n\t\t\t\t// If the arg is undefined, then continue.\n\t\t\t} else if (Directory.is(arg)) {\n\t\t\t\t// If the arg is a directory, then apply each entry.\n\t\t\t\tfor (let [name, entry] of Object.entries(await arg.entries())) {\n\t\t\t\t\t// Get an existing entry.\n\t\t\t\t\tlet existingEntry = entries[name];\n\n\t\t\t\t\t// Merge the existing entry with the entry if they are both directories.\n\t\t\t\t\tif (Directory.is(existingEntry) && Directory.is(entry)) {\n\t\t\t\t\t\tentry = await Directory.new(existingEntry, entry);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Set the entry.\n\t\t\t\t\tentries[name] = entry;\n\t\t\t\t}\n\t\t\t} else if (arg instanceof Array) {\n\t\t\t\tfor (let argEntry of arg) {\n\t\t\t\t\tentries = await reduce(Promise.resolve(entries), argEntry);\n\t\t\t\t}\n\t\t\t} else if (typeof arg === \"object\") {\n\t\t\t\t// If the arg is an object, then apply each entry.\n\t\t\t\tfor (let [key, value] of Object.entries(arg)) {\n\t\t\t\t\t// Separate the first path component from the trailing path components.\n\t\t\t\t\tlet [firstComponent, ...trailingComponents] =\n\t\t\t\t\t\tsubpath(key).components();\n\t\t\t\t\tif (firstComponent === undefined) {\n\t\t\t\t\t\tthrow new Error(\"The path must have at least one component.\");\n\t\t\t\t\t}\n\t\t\t\t\tlet name = firstComponent;\n\n\t\t\t\t\t// Get an existing entry.\n\t\t\t\t\tlet existingEntry = entries[name];\n\n\t\t\t\t\t// Remove the entry if it is not a directory.\n\t\t\t\t\tif (!Directory.is(existingEntry)) {\n\t\t\t\t\t\texistingEntry = undefined;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (trailingComponents.length > 0) {\n\t\t\t\t\t\t// If there are trailing path components, then recurse.\n\t\t\t\t\t\tlet trailingPath = subpath(trailingComponents).toString();\n\n\t\t\t\t\t\t// Merge the entry with the trailing path.\n\t\t\t\t\t\tlet newEntry = await Directory.new(existingEntry, {\n\t\t\t\t\t\t\t[trailingPath]: value,\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\t// Add the entry.\n\t\t\t\t\t\tentries[name] = newEntry;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// If there are no trailing path components, then create the artifact specified by the value.\n\t\t\t\t\t\tif (value === undefined) {\n\t\t\t\t\t\t\tdelete entries[name];\n\t\t\t\t\t\t} else if (Blob.Arg.is(value)) {\n\t\t\t\t\t\t\tlet newEntry = await file(value);\n\t\t\t\t\t\t\tentries[name] = newEntry;\n\t\t\t\t\t\t} else if (File.is(value) || Symlink.is(value)) {\n\t\t\t\t\t\t\tentries[name] = value;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlet newEntry = await Directory.new(existingEntry, value);\n\t\t\t\t\t\t\tentries[name] = newEntry;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn unreachable();\n\t\t\t}\n\t\t\treturn entries;\n\t\t}, Promise.resolve({}));\n\t\treturn new Directory(\n\t\t\tObject_.Handle.withObject({ kind: \"directory\", value: { entries } }),\n\t\t);\n\t}\n\n\tstatic is(value: unknown): value is Directory {\n\t\treturn value instanceof Directory;\n\t}\n\n\tstatic expect(value: unknown): Directory {\n\t\tassert_(Directory.is(value));\n\t\treturn value;\n\t}\n\n\tstatic assert(value: unknown): asserts value is Directory {\n\t\tassert_(Directory.is(value));\n\t}\n\n\tasync id(): Promise<Directory.Id> {\n\t\treturn (await this.#handle.id()) as Directory.Id;\n\t}\n\n\tasync object(): Promise<Directory.Object_> {\n\t\tlet object = await this.#handle.object();\n\t\tassert_(object.kind === \"directory\");\n\t\treturn object.value;\n\t}\n\n\tget handle(): Object_.Handle {\n\t\treturn this.#handle;\n\t}\n\n\tasync get(arg: string): Promise<Directory | File> {\n\t\tlet artifact = await this.tryGet(arg);\n\t\tassert_(artifact, `Failed to get the directory entry \"${arg}\".`);\n\t\treturn artifact;\n\t}\n\n\tasync tryGet(arg: string): Promise<Directory | File | undefined> {\n\t\tlet artifact: Directory | File = this;\n\t\tlet currentSubpath = subpath();\n\t\tfor (let component of subpath(arg).components()) {\n\t\t\tif (!Directory.is(artifact)) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\tcurrentSubpath.push(component);\n\t\t\tlet entry: Artifact | undefined = (await artifact.entries())[component];\n\t\t\tif (entry === undefined) {\n\t\t\t\treturn undefined;\n\t\t\t} else if (Symlink.is(entry)) {\n\t\t\t\tlet resolved = await entry.resolve({\n\t\t\t\t\tartifact: this,\n\t\t\t\t\tpath: currentSubpath.toString(),\n\t\t\t\t});\n\t\t\t\tif (resolved === undefined) {\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\t\t\t\tartifact = resolved;\n\t\t\t} else {\n\t\t\t\tartifact = entry;\n\t\t\t}\n\t\t}\n\t\treturn artifact;\n\t}\n\n\tasync entries(): Promise<Record<string, Artifact>> {\n\t\tlet entries: Record<string, Artifact> = {};\n\t\tfor await (let [name, artifact] of this) {\n\t\t\tentries[name] = artifact;\n\t\t}\n\t\treturn entries;\n\t}\n\n\tasync bundle(): Promise<Directory> {\n\t\treturn await syscall.bundle(this);\n\t}\n\n\tasync *walk(): AsyncIterableIterator<[Subpath, Artifact]> {\n\t\tfor await (let [name, artifact] of this) {\n\t\t\tyield [subpath(name), artifact];\n\t\t\tif (Directory.is(artifact)) {\n\t\t\t\tfor await (let [entryName, entryArtifact] of artifact.walk()) {\n\t\t\t\t\tyield [subpath(name).join(entryName), entryArtifact];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tasync *[Symbol.asyncIterator](): AsyncIterator<[string, Artifact]> {\n\t\tlet object = await this.object();\n\t\tfor (let [name, artifact] of Object.entries(object.entries)) {\n\t\t\tyield [name, artifact];\n\t\t}\n\t}\n}\n\nexport namespace Directory {\n\texport type Arg = undefined | Directory | Array<Arg> | ArgObject;\n\n\ttype ArgObject = {\n\t\t[name: string]: undefined | Blob.Arg | Artifact | ArgObject;\n\t};\n\n\texport type Id = string;\n\n\texport type Object_ = {\n\t\tentries: Record<string, Artifact>;\n\t};\n}\n", "import { Artifact } from \"./artifact.ts\";\nimport { assert as assert_ } from \"./assert.ts\";\nimport { Object_ } from \"./object.ts\";\n\nexport class Package {\n\t#handle: Object_.Handle;\n\n\tconstructor(handle: Object_.Handle) {\n\t\tthis.#handle = handle;\n\t}\n\n\tstatic withId(id: Package.Id): Package {\n\t\treturn new Package(Object_.Handle.withId(id));\n\t}\n\n\tstatic is(value: unknown): value is Package {\n\t\treturn value instanceof Package;\n\t}\n\n\tstatic expect(value: unknown): Package {\n\t\tassert_(Package.is(value));\n\t\treturn value;\n\t}\n\n\tstatic assert(value: unknown): asserts value is Package {\n\t\tassert_(Package.is(value));\n\t}\n\n\tasync id(): Promise<Package.Id> {\n\t\treturn (await this.#handle.id()) as Package.Id;\n\t}\n\n\tasync object(): Promise<Package.Object_> {\n\t\tlet object = await this.#handle.object();\n\t\tassert_(object.kind === \"package\");\n\t\treturn object.value;\n\t}\n\n\tget handle(): Object_.Handle {\n\t\treturn this.#handle;\n\t}\n\n\tasync artifact(): Promise<Artifact> {\n\t\treturn (await this.object()).artifact;\n\t}\n\n\tasync dependencies(): Promise<{ [dependency: string]: Package }> {\n\t\treturn (await this.object()).dependencies;\n\t}\n}\n\nexport namespace Package {\n\texport type Arg = Package | Array<Arg> | ArgObject;\n\n\texport type ArgObject = {\n\t\tartifact: Artifact;\n\t\tdependencies?: { [dependency: string]: Package.Arg };\n\t};\n\n\texport type Id = string;\n\n\texport type Object_ = {\n\t\tartifact: Artifact;\n\t\tdependencies: { [dependency: string]: Package };\n\t};\n}\n", "import { assert } from \"./assert.ts\";\nimport { encoding } from \"./syscall.ts\";\n\nexport type Module =\n\t| { kind: \"document\"; value: Document }\n\t| { kind: \"library\"; value: Library }\n\t| { kind: \"normal\"; value: Normal };\n\nexport type Document = {\n\tpackagePath: string;\n\tpath: string;\n};\n\nexport type Library = {\n\tpath: string;\n};\n\nexport type Normal = {\n\tpackageId: string;\n\tpath: string;\n};\n\nexport namespace Module {\n\texport let toUrl = (module: Module): string => {\n\t\tlet data = encoding.hex.encode(\n\t\t\tencoding.utf8.encode(encoding.json.encode(module)),\n\t\t);\n\t\treturn `tangram://${data}/${module.value.path}`;\n\t};\n\n\texport let fromUrl = (url: string): Module => {\n\t\tlet match = url.match(/^tangram:\\/\\/([0-9a-f]+)/);\n\t\tassert(match);\n\t\tlet [_, data] = match;\n\t\tassert(data !== undefined);\n\t\treturn encoding.json.decode(\n\t\t\tencoding.utf8.decode(encoding.hex.decode(data)),\n\t\t) as Module;\n\t};\n}\n", "import { Args, flatten } from \"./args.ts\";\nimport { assert as assert_, unreachable } from \"./assert.ts\";\nimport { Checksum } from \"./checksum.ts\";\nimport * as encoding from \"./encoding.ts\";\nimport { Module } from \"./module.ts\";\nimport { Object_ } from \"./object.ts\";\nimport { Package } from \"./package.ts\";\nimport { MaybePromise, Unresolved } from \"./resolve.ts\";\nimport * as syscall from \"./syscall.ts\";\nimport { System } from \"./system.ts\";\nimport { Template, template } from \"./template.ts\";\nimport { Value } from \"./value.ts\";\n\nlet current: Target;\nexport let getCurrent = (): Target => {\n\treturn current;\n};\nexport let setCurrent = (target: Target) => {\n\tcurrent = target;\n};\n\nexport let functions: Record<string, Function> = {};\n\ntype FunctionArg<\n\tA extends Array<Value> = Array<Value>,\n\tR extends Value = Value,\n> = {\n\turl: string;\n\tname: string;\n\tfunction: (...args: A) => MaybePromise<R | void>;\n};\n\nexport function target<\n\tA extends Array<Value> = Array<Value>,\n\tR extends Value = Value,\n>(args: FunctionArg): Target<A, R>;\nexport function target<\n\tA extends Array<Value> = Array<Value>,\n\tR extends Value = Value,\n>(...args: Args<Target.Arg>): Promise<Target<A, R>>;\nexport function target<\n\tA extends Array<Value> = Array<Value>,\n\tR extends Value = Value,\n>(...args: [FunctionArg<A, R>] | Args<Target.Arg>): MaybePromise<Target<A, R>> {\n\tif (\n\t\targs.length === 1 &&\n\t\ttypeof args[0] === \"object\" &&\n\t\t\"function\" in args[0]\n\t) {\n\t\t// Register the function.\n\t\tlet arg = args[0];\n\t\tlet { url, name } = arg;\n\t\tlet key = encoding.json.encode({ url, name });\n\t\tassert_(functions[key] === undefined);\n\t\tfunctions[key] = arg.function;\n\n\t\t// Get the package.\n\t\tlet module_ = Module.fromUrl(arg.url);\n\t\tassert_(module_.kind === \"normal\");\n\t\tlet package_ = Package.withId(module_.value.packageId);\n\n\t\t// Create the target.\n\t\treturn new Target(\n\t\t\tObject_.Handle.withObject({\n\t\t\t\tkind: \"target\",\n\t\t\t\tvalue: {\n\t\t\t\t\thost: \"js-js\",\n\t\t\t\t\texecutable: new Template([module_.value.path]),\n\t\t\t\t\tpackage: package_,\n\t\t\t\t\tname: arg.name,\n\t\t\t\t\targs: [],\n\t\t\t\t\tenv: {},\n\t\t\t\t\tchecksum: undefined,\n\t\t\t\t\tunsafe: false,\n\t\t\t\t},\n\t\t\t}),\n\t\t);\n\t} else {\n\t\treturn Target.new(...args);\n\t}\n}\n\nexport let build = async (\n\t...args: Array<Unresolved<Target.Arg>>\n): Promise<Value> => {\n\treturn await (await target(...args)).build();\n};\n\nexport interface Target<\n\tA extends Array<Value> = Array<Value>,\n\tR extends Value = Value,\n> extends globalThis.Function {\n\t(...args: { [K in keyof A]: Unresolved<A[K]> }): Promise<R>;\n}\n\nexport class Target<\n\tA extends Array<Value> = Array<Value>,\n\tR extends Value = Value,\n> extends globalThis.Function {\n\t#handle: Object_.Handle;\n\n\tconstructor(handle: Object_.Handle) {\n\t\tsuper();\n\t\tthis.#handle = handle;\n\t\tlet this_ = this as any;\n\t\treturn new Proxy(this_, {\n\t\t\tget(_target, prop, _receiver) {\n\t\t\t\tif (typeof this_[prop] === \"function\") {\n\t\t\t\t\treturn this_[prop].bind(this_);\n\t\t\t\t} else {\n\t\t\t\t\treturn this_[prop];\n\t\t\t\t}\n\t\t\t},\n\t\t\tapply: async (_target, _, args) => {\n\t\t\t\tlet target = await Target.new(this_ as any, {\n\t\t\t\t\targs: args as Array<Value>,\n\t\t\t\t});\n\t\t\t\treturn await target.build();\n\t\t\t},\n\t\t\tgetPrototypeOf: (_target) => {\n\t\t\t\treturn Object.getPrototypeOf(this_);\n\t\t\t},\n\t\t});\n\t}\n\n\tstatic withId(id: Target.Id): Target {\n\t\treturn new Target(Object_.Handle.withId(id));\n\t}\n\n\tstatic async new<\n\t\tA extends Array<Value> = Array<Value>,\n\t\tR extends Value = Value,\n\t>(...args: Args<Target.Arg>): Promise<Target<A, R>> {\n\t\ttype Apply = {\n\t\t\thost?: System;\n\t\t\texecutable?: Template;\n\t\t\tpackage?: Package | undefined;\n\t\t\tname?: string | undefined;\n\t\t\tenv?:\n\t\t\t\t| Record<string, Value>\n\t\t\t\t| Array<Record<string, EnvMutation>>\n\t\t\t\t| undefined;\n\t\t\targs: Array<Value>;\n\t\t\tchecksum?: Checksum | undefined;\n\t\t\tunsafe?: boolean;\n\t\t};\n\t\tlet {\n\t\t\thost,\n\t\t\texecutable,\n\t\t\tpackage: package_,\n\t\t\tname,\n\t\t\tenv: env_,\n\t\t\targs: args_,\n\t\t\tchecksum,\n\t\t\tunsafe: unsafe_,\n\t\t} = await Args.apply<Target.Arg, Apply>(args, async (arg) => {\n\t\t\tif (Template.Arg.is(arg)) {\n\t\t\t\tlet host = {\n\t\t\t\t\tkind: \"set\" as const,\n\t\t\t\t\tvalue: (await getCurrent().env())[\"TANGRAM_HOST\"] as System,\n\t\t\t\t};\n\t\t\t\tlet executable = {\n\t\t\t\t\tkind: \"set\" as const,\n\t\t\t\t\tvalue: await template(\"/bin/sh\"),\n\t\t\t\t};\n\t\t\t\tlet args_ = {\n\t\t\t\t\tkind: \"set\" as const,\n\t\t\t\t\tvalue: [\"-c\", await template(arg)],\n\t\t\t\t};\n\t\t\t\treturn { host, executable, args_ };\n\t\t\t} else if (Target.is(arg)) {\n\t\t\t\tlet host = { kind: \"set\" as const, value: await arg.host() };\n\t\t\t\tlet executable = {\n\t\t\t\t\tkind: \"set\" as const,\n\t\t\t\t\tvalue: await arg.executable(),\n\t\t\t\t};\n\t\t\t\tlet package_ = { kind: \"set\" as const, value: await arg.package() };\n\t\t\t\tlet name = { kind: \"set\" as const, value: await arg.name_() };\n\t\t\t\tlet env = { kind: \"set\" as const, value: await arg.env() };\n\t\t\t\tlet args_ = { kind: \"set\" as const, value: await arg.args() };\n\t\t\t\tlet checksum = { kind: \"set\" as const, value: await arg.checksum() };\n\t\t\t\tlet unsafe = { kind: \"set\" as const, value: await arg.unsafe() };\n\t\t\t\treturn {\n\t\t\t\t\thost,\n\t\t\t\t\texecutable,\n\t\t\t\t\tpackage: package_,\n\t\t\t\t\tname,\n\t\t\t\t\tenv,\n\t\t\t\t\targs: args_,\n\t\t\t\t\tchecksum,\n\t\t\t\t\tunsafe,\n\t\t\t\t};\n\t\t\t} else if (typeof arg === \"object\") {\n\t\t\t\tlet object: Args.MutationObject<Apply> = {};\n\t\t\t\tif (\"host\" in arg) {\n\t\t\t\t\tobject.host = {\n\t\t\t\t\t\tkind: \"set\" as const,\n\t\t\t\t\t\tvalue: arg.host,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tif (\"executable\" in arg) {\n\t\t\t\t\tobject.executable = {\n\t\t\t\t\t\tkind: \"set\" as const,\n\t\t\t\t\t\tvalue: await template(arg.executable),\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tif (\"package\" in arg) {\n\t\t\t\t\tobject.package = {\n\t\t\t\t\t\tkind: \"set\" as const,\n\t\t\t\t\t\tvalue: arg.package,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tif (\"name\" in arg) {\n\t\t\t\t\tobject.name = {\n\t\t\t\t\t\tkind: \"set\" as const,\n\t\t\t\t\t\tvalue: arg.name,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tif (\"env\" in arg) {\n\t\t\t\t\tobject.env =\n\t\t\t\t\t\targ.env === undefined\n\t\t\t\t\t\t\t? { kind: \"unset\" }\n\t\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\t\tkind: \"append\" as const,\n\t\t\t\t\t\t\t\t\tvalue: arg.env,\n\t\t\t\t\t\t\t  };\n\t\t\t\t}\n\t\t\t\tif (\"args\" in arg) {\n\t\t\t\t\tobject.args = {\n\t\t\t\t\t\tkind: \"append\" as const,\n\t\t\t\t\t\tvalue: arg.args,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tif (\"checksum\" in arg) {\n\t\t\t\t\tobject.checksum = {\n\t\t\t\t\t\tkind: \"set\" as const,\n\t\t\t\t\t\tvalue: arg.checksum,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tif (\"unsafe\" in arg) {\n\t\t\t\t\tobject.unsafe = {\n\t\t\t\t\t\tkind: \"set\" as const,\n\t\t\t\t\t\tvalue: arg.unsafe,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\treturn object;\n\t\t\t} else {\n\t\t\t\treturn unreachable();\n\t\t\t}\n\t\t});\n\t\tif (!host) {\n\t\t\tthrow new Error(\"Cannot create a target without a host.\");\n\t\t}\n\t\tif (!executable) {\n\t\t\tthrow new Error(\"Cannot create a target without an executable.\");\n\t\t}\n\t\tlet env =\n\t\t\tenv_ && env_ instanceof Array\n\t\t\t\t? await processEnvMutations({}, ...(env_ ?? []))\n\t\t\t\t: env_ ?? {};\n\t\targs_ ??= [];\n\t\tunsafe_ ??= false;\n\t\treturn new Target(\n\t\t\tObject_.Handle.withObject({\n\t\t\t\tkind: \"target\",\n\t\t\t\tvalue: {\n\t\t\t\t\thost,\n\t\t\t\t\texecutable,\n\t\t\t\t\tpackage: package_,\n\t\t\t\t\tname,\n\t\t\t\t\tenv,\n\t\t\t\t\targs: args_,\n\t\t\t\t\tchecksum,\n\t\t\t\t\tunsafe: unsafe_,\n\t\t\t\t},\n\t\t\t}),\n\t\t);\n\t}\n\n\tstatic is(value: unknown): value is Target {\n\t\treturn value instanceof Target;\n\t}\n\n\tstatic expect(value: unknown): Target {\n\t\tassert_(Target.is(value));\n\t\treturn value;\n\t}\n\n\tstatic assert(value: unknown): asserts value is Target {\n\t\tassert_(Target.is(value));\n\t}\n\n\tasync id(): Promise<Target.Id> {\n\t\treturn (await this.#handle.id()) as Target.Id;\n\t}\n\n\tasync object(): Promise<Target.Object_> {\n\t\tlet object = await this.#handle.object();\n\t\tassert_(object.kind === \"target\");\n\t\treturn object.value;\n\t}\n\n\tget handle(): Object_.Handle {\n\t\treturn this.#handle;\n\t}\n\n\tasync host(): Promise<System> {\n\t\treturn (await this.object()).host;\n\t}\n\n\tasync executable(): Promise<Template> {\n\t\treturn (await this.object()).executable;\n\t}\n\n\tasync package(): Promise<Package | undefined> {\n\t\treturn (await this.object()).package;\n\t}\n\n\tasync name_(): Promise<string | undefined> {\n\t\treturn (await this.object()).name;\n\t}\n\n\tasync env(): Promise<Record<string, Value>> {\n\t\treturn (await this.object()).env;\n\t}\n\n\tasync args(): Promise<Array<Value>> {\n\t\treturn (await this.object()).args;\n\t}\n\n\tasync checksum(): Promise<Checksum | undefined> {\n\t\treturn (await this.object()).checksum;\n\t}\n\n\tasync unsafe(): Promise<boolean> {\n\t\treturn (await this.object()).unsafe;\n\t}\n\n\tasync build(...args: A): Promise<Value> {\n\t\treturn await syscall.build(\n\t\t\tawait Target.new<[], R>(this as Target, { args }),\n\t\t);\n\t}\n}\n\nexport namespace Target {\n\texport type Arg = Template.Arg | Target | ArgObject;\n\n\texport type ArgObject = {\n\t\thost?: System;\n\t\texecutable?: Template.Arg;\n\t\tpackage?: Package | undefined;\n\t\tname?: string | undefined;\n\t\tenv?: Record<string, EnvMutation> | undefined;\n\t\targs?: Array<Value>;\n\t\tchecksum?: Checksum | undefined;\n\t\tunsafe?: boolean;\n\t};\n\n\texport type Id = string;\n\n\texport type Object_ = {\n\t\thost: System;\n\t\texecutable: Template;\n\t\tpackage: Package | undefined;\n\t\tname: string | undefined;\n\t\tenv: Record<string, Value>;\n\t\targs: Array<Value>;\n\t\tchecksum: Checksum | undefined;\n\t\tunsafe: boolean;\n\t};\n}\n\ntype EnvMutation =\n\t| Template.Arg\n\t| { kind: \"unset\" }\n\t| { kind: \"set\"; value: Template.Arg }\n\t| { kind: \"set_if_unset\"; value: Template.Arg }\n\t| {\n\t\t\tkind: \"append\";\n\t\t\tvalue: Args.MaybeNestedArray<Template.Arg>;\n\t\t\tseparator?: Template.Arg;\n\t  }\n\t| {\n\t\t\tkind: \"prepend\";\n\t\t\tvalue: Args.MaybeNestedArray<Template.Arg>;\n\t\t\tseparator?: Template.Arg;\n\t  };\n\n/** Collect a list of env mutations into a single environment. */\nlet processEnvMutations = async (\n\tinit: Record<string, Value>,\n\t...args: Array<Record<string, EnvMutation>>\n): Promise<Record<string, Value>> => {\n\tlet env = { ...init };\n\tfor (let arg of args) {\n\t\t// Apply mutations for a single argument.\n\t\tfor (let [key, mutation] of Object.entries(arg)) {\n\t\t\tawait mutateEnv(env, key, mutation);\n\t\t}\n\t}\n\treturn env;\n};\n\n/** Mutate an env object in-place. */\nlet mutateEnv = async (\n\tenv: Record<string, Value>,\n\tkey: string,\n\tmutation: EnvMutation,\n) => {\n\tif (Template.Arg.is(mutation)) {\n\t\tmutation = { kind: \"set\", value: mutation };\n\t}\n\tif (mutation.kind === \"unset\") {\n\t\tdelete env[key];\n\t} else if (mutation.kind === \"set\") {\n\t\tenv[key] = mutation.value;\n\t} else if (mutation.kind === \"set_if_unset\") {\n\t\tif (!(key in env)) {\n\t\t\tenv[key] = mutation.value;\n\t\t}\n\t} else if (mutation.kind === \"append\") {\n\t\tif (!(key in env)) {\n\t\t\tenv[key] = await template();\n\t\t}\n\t\tlet t = env[key];\n\t\tassert_(Template.Arg.is(t));\n\t\tenv[key] = await Template.join(\n\t\t\tmutation.separator ?? \"\",\n\t\t\tt,\n\t\t\t...flatten(mutation.value),\n\t\t);\n\t} else if (mutation.kind === \"prepend\") {\n\t\tif (!(key in env)) {\n\t\t\tenv[key] = await template();\n\t\t}\n\t\tlet t = env[key];\n\t\tassert_(Template.Arg.is(t));\n\t\tenv[key] = await Template.join(\n\t\t\tmutation.separator ?? \"\",\n\t\t\t...flatten(mutation.value),\n\t\t\tt,\n\t\t);\n\t}\n};\n", "import { Blob } from \"./blob.ts\";\nimport { Directory } from \"./directory.ts\";\nimport { File } from \"./file.ts\";\nimport { Package } from \"./package.ts\";\nimport { Symlink } from \"./symlink.ts\";\nimport { Target } from \"./target.ts\";\nimport { Template } from \"./template.ts\";\nimport { Value } from \"./value.ts\";\n\nexport type Unresolved<T extends Value> = MaybePromise<\n\tT extends\n\t\t| undefined\n\t\t| boolean\n\t\t| number\n\t\t| string\n\t\t| Uint8Array\n\t\t| Blob\n\t\t| Directory\n\t\t| File\n\t\t| Symlink\n\t\t| Template\n\t\t| Package\n\t\t| Target\n\t\t? T\n\t\t: T extends Array<infer U extends Value>\n\t\t? Array<Unresolved<U>>\n\t\t: T extends { [key: string]: Value }\n\t\t? { [K in keyof T]: Unresolved<T[K]> }\n\t\t: never\n>;\n\nexport type Resolved<T extends Unresolved<Value>> = T extends\n\t| undefined\n\t| boolean\n\t| number\n\t| string\n\t| Uint8Array\n\t| Blob\n\t| Directory\n\t| File\n\t| Symlink\n\t| Template\n\t| Package\n\t| Target\n\t? T\n\t: T extends Promise<infer U extends Unresolved<Value>>\n\t? Resolved<U>\n\t: T extends Array<infer U extends Unresolved<Value>>\n\t? Array<Resolved<U>>\n\t: T extends { [key: string]: Unresolved<Value> }\n\t? { [K in keyof T]: Resolved<T[K]> }\n\t: never;\n\nexport type MaybePromise<T> = T | Promise<T>;\n\nexport let resolve = async <T extends Unresolved<Value>>(\n\tvalue: T,\n): Promise<Resolved<T>> => {\n\tvalue = await value;\n\tif (\n\t\tvalue === undefined ||\n\t\ttypeof value === \"boolean\" ||\n\t\ttypeof value === \"number\" ||\n\t\ttypeof value === \"string\" ||\n\t\tvalue instanceof Uint8Array ||\n\t\tvalue instanceof Blob ||\n\t\tvalue instanceof Directory ||\n\t\tvalue instanceof File ||\n\t\tvalue instanceof Symlink ||\n\t\tvalue instanceof Template ||\n\t\tvalue instanceof Package ||\n\t\tvalue instanceof Target\n\t) {\n\t\treturn value as unknown as Resolved<T>;\n\t} else if (value instanceof Array) {\n\t\treturn (await Promise.all(\n\t\t\tvalue.map((value) => resolve(value)),\n\t\t)) as Resolved<T>;\n\t} else if (typeof value === \"object\") {\n\t\treturn Object.fromEntries(\n\t\t\tawait Promise.all(\n\t\t\t\tObject.entries(value).map(async ([key, value]) => [\n\t\t\t\t\tkey,\n\t\t\t\t\tawait resolve(value),\n\t\t\t\t]),\n\t\t\t),\n\t\t) as Resolved<T>;\n\t} else {\n\t\tthrow new Error(\"Invalid value to resolve.\");\n\t}\n};\n", "import { assert } from \"./assert.ts\";\nimport { Unresolved, resolve } from \"./resolve.ts\";\nimport { Value } from \"./value.ts\";\n\nexport type Args<T extends Value> = Array<Unresolved<Args.MaybeNestedArray<T>>>;\n\nexport namespace Args {\n\texport type Mutation<T extends Value = Value> =\n\t\t| { kind: \"unset\" }\n\t\t| { kind: \"set\"; value: T }\n\t\t| { kind: \"set_if_unset\"; value: T }\n\t\t| {\n\t\t\t\tkind: \"prepend\";\n\t\t\t\tvalue: T extends Array<infer U> ? MaybeNestedArray<U> : never;\n\t\t  }\n\t\t| {\n\t\t\t\tkind: \"append\";\n\t\t\t\tvalue: T extends Array<infer U> ? MaybeNestedArray<U> : never;\n\t\t  };\n\n\texport type MaybeNestedArray<T> = T | Array<MaybeNestedArray<T>>;\n\n\texport type MutationObject<T extends { [key: string]: Value }> = {\n\t\t[K in keyof T]?: MaybeNestedArray<Mutation<T[K]>>;\n\t};\n\n\texport let apply = async <\n\t\tA extends Value,\n\t\tR extends { [key: string]: Value },\n\t>(\n\t\targs: Args<A>,\n\t\tmap: (arg: A) => Promise<MaybeNestedArray<MutationObject<R>>>,\n\t): Promise<Partial<R>> => {\n\t\treturn flatten(\n\t\t\tawait Promise.all(\n\t\t\t\tflatten(await Promise.all(args.map(resolve))).map((arg) =>\n\t\t\t\t\tmap(arg as A),\n\t\t\t\t),\n\t\t\t),\n\t\t).reduce((object, mutations) => {\n\t\t\tfor (let [key, mutation] of Object.entries(mutations)) {\n\t\t\t\tmutate(object, key, mutation);\n\t\t\t}\n\t\t\treturn object;\n\t\t}, {});\n\t};\n}\n\nexport let flatten = <T>(value: Args.MaybeNestedArray<T>): Array<T> => {\n\t// @ts-ignore\n\treturn value instanceof Array ? value.flat(Infinity) : [value];\n};\n\nlet mutate = (\n\tobject: { [key: string]: Value },\n\tkey: string,\n\tmutation: Args.Mutation,\n) => {\n\tif (mutation.kind === \"unset\") {\n\t\tdelete object[key];\n\t} else if (mutation.kind === \"set\") {\n\t\tobject[key] = mutation.value;\n\t} else if (mutation.kind === \"set_if_unset\") {\n\t\tif (!(key in object)) {\n\t\t\tobject[key] = mutation.value;\n\t\t}\n\t} else if (mutation.kind === \"prepend\") {\n\t\tif (!(key in object)) {\n\t\t\tobject[key] = [];\n\t\t}\n\t\tlet array = object[key];\n\t\tassert(array instanceof Array);\n\t\tarray.unshift(...flatten(mutation.value));\n\t} else if (mutation.kind === \"append\") {\n\t\tif (!(key in object)) {\n\t\t\tobject[key] = [];\n\t\t}\n\t\tlet array = object[key];\n\t\tassert(array instanceof Array);\n\t\tarray.push(...flatten(mutation.value));\n\t}\n};\n", "export class Error {\n\tmessage: string;\n\tlocation: Location | undefined;\n\tstack: Array<Location> | undefined;\n\tsource: Error | undefined;\n\n\tconstructor(\n\t\tmessage: string,\n\t\tlocation?: Location,\n\t\tstack?: Array<Location>,\n\t\tsource?: Error,\n\t) {\n\t\tthis.message = message;\n\t\tthis.location = location;\n\t\tthis.stack = stack;\n\t\tthis.source = source;\n\t}\n}\n\ntype Location = { source: string; line: number; column: number };\n\n/** This type is derived from <https://v8.dev/docs/stack-trace-api#customizing-stack-traces>. */\ntype CallSite = {\n\tgetTypeName(): string;\n\tgetFunctionName(): string;\n\tgetMethodName(): string;\n\tgetFileName(): string | undefined;\n\tgetLineNumber(): number | undefined;\n\tgetColumnNumber(): number | undefined;\n\tgetEvalOrigin(): unknown | undefined;\n\tisEval(): boolean;\n\tisNative(): boolean;\n\tisConstructor(): boolean;\n\tisAsync(): boolean;\n\tisPromiseAll(): boolean;\n\t// isPromiseAny(): boolean;\n\tgetPromiseIndex(): number | null;\n};\n\nexport let prepareStackTrace = (\n\t_error: unknown,\n\tstructuredStackTrace: Array<CallSite>,\n) => {\n\tlet callSites = structuredStackTrace.map((callSite) => {\n\t\treturn {\n\t\t\ttypeName: callSite.getTypeName(),\n\t\t\tfunctionName: callSite.getFunctionName(),\n\t\t\tmethodName: callSite.getMethodName(),\n\t\t\tfileName: callSite.getFileName(),\n\t\t\tlineNumber: callSite.getLineNumber(),\n\t\t\tcolumnNumber: callSite.getColumnNumber(),\n\t\t\tisEval: callSite.isEval(),\n\t\t\tisNative: callSite.isNative(),\n\t\t\tisConstructor: callSite.isConstructor(),\n\t\t\tisAsync: callSite.isAsync(),\n\t\t\tisPromiseAll: callSite.isPromiseAll(),\n\t\t\t// isPromiseAny: callSite.isPromiseAny(),\n\t\t\tpromiseIndex: callSite.getPromiseIndex(),\n\t\t};\n\t});\n\treturn { callSites };\n};\n", "import { Artifact } from \"./artifact.ts\";\nimport { assert } from \"./assert.ts\";\nimport { Directory } from \"./directory.ts\";\nimport { Module } from \"./module.ts\";\nimport { Package } from \"./package.ts\";\nimport { Relpath, subpath } from \"./path.ts\";\n\ntype Arg = {\n\turl: string;\n\tpath: Relpath.Arg;\n};\n\nexport let include = async (arg: Arg): Promise<Artifact> => {\n\tlet module_ = Module.fromUrl(arg.url);\n\tassert(module_.kind === \"normal\");\n\tlet package_ = Package.withId(module_.value.packageId);\n\tlet artifact = await package_.artifact();\n\tDirectory.assert(artifact);\n\tlet path = subpath(module_.value.path)\n\t\t.toRelpath()\n\t\t.parent()\n\t\t.join(arg.path)\n\t\t.toSubpath()\n\t\t.toString();\n\tlet includedArtifact = await artifact.get(path);\n\treturn includedArtifact;\n};\n", "import { unreachable } from \"./assert.ts\";\nimport { Blob } from \"./blob.ts\";\nimport { Directory } from \"./directory.ts\";\nimport { File } from \"./file.ts\";\nimport { Object_ } from \"./object.ts\";\nimport { Package } from \"./package.ts\";\nimport { Symlink } from \"./symlink.ts\";\nimport * as syscall from \"./syscall.ts\";\nimport { Target } from \"./target.ts\";\nimport { Template } from \"./template.ts\";\n\nexport let log = (...args: Array<unknown>) => {\n\tlet string = args.map((arg) => stringify(arg)).join(\" \");\n\tsyscall.log(string);\n};\n\nlet stringify = (value: unknown): string => {\n\treturn stringifyInner(value, new WeakSet());\n};\n\nlet stringifyInner = (value: unknown, visited: WeakSet<object>): string => {\n\tswitch (typeof value) {\n\t\tcase \"string\": {\n\t\t\treturn `\"${value}\"`;\n\t\t}\n\t\tcase \"number\": {\n\t\t\treturn value.toString();\n\t\t}\n\t\tcase \"boolean\": {\n\t\t\treturn value ? \"true\" : \"false\";\n\t\t}\n\t\tcase \"undefined\": {\n\t\t\treturn \"undefined\";\n\t\t}\n\t\tcase \"object\": {\n\t\t\tif (value === null) {\n\t\t\t\treturn \"null\";\n\t\t\t} else {\n\t\t\t\treturn stringifyObject(value, visited);\n\t\t\t}\n\t\t}\n\t\tcase \"function\": {\n\t\t\treturn `(function \"${value.name ?? \"(anonymous)\"}\")`;\n\t\t}\n\t\tcase \"symbol\": {\n\t\t\treturn \"(symbol)\";\n\t\t}\n\t\tcase \"bigint\": {\n\t\t\treturn value.toString();\n\t\t}\n\t}\n};\n\nlet stringifyObject = (value: object, visited: WeakSet<object>): string => {\n\tif (visited.has(value)) {\n\t\treturn \"(circular)\";\n\t}\n\tvisited.add(value);\n\tif (value instanceof Array) {\n\t\treturn `[${value\n\t\t\t.map((value) => stringifyInner(value, visited))\n\t\t\t.join(\", \")}]`;\n\t} else if (value instanceof Error) {\n\t\treturn value.message;\n\t} else if (value instanceof Promise) {\n\t\treturn \"(promise)\";\n\t} else if (Blob.is(value)) {\n\t\tlet handle = stringifyHandle(value.handle, visited);\n\t\treturn `(tg.blob ${handle})`;\n\t} else if (Directory.is(value)) {\n\t\tlet handle = stringifyHandle(value.handle, visited);\n\t\treturn `(tg.directory ${handle})`;\n\t} else if (File.is(value)) {\n\t\tlet handle = stringifyHandle(value.handle, visited);\n\t\treturn `(tg.file ${handle})`;\n\t} else if (Symlink.is(value)) {\n\t\tlet handle = stringifyHandle(value.handle, visited);\n\t\treturn `(tg.symlink ${handle})`;\n\t} else if (Template.is(value)) {\n\t\tlet string = value.components\n\t\t\t.map((component) => {\n\t\t\t\tif (typeof component === \"string\") {\n\t\t\t\t\treturn component;\n\t\t\t\t} else {\n\t\t\t\t\treturn `\\${${stringifyInner(component, visited)}}`;\n\t\t\t\t}\n\t\t\t})\n\t\t\t.join(\"\");\n\t\treturn `(tg.template \"${string}\")`;\n\t} else if (Package.is(value)) {\n\t\tlet handle = stringifyHandle(value.handle, visited);\n\t\treturn `(tg.package \"${handle}\")`;\n\t} else if (Target.is(value)) {\n\t\tlet handle = stringifyHandle(value.handle, visited);\n\t\treturn `(tg.target \"${handle}\")`;\n\t} else {\n\t\tlet constructorName = \"\";\n\t\tif (\n\t\t\tvalue.constructor !== undefined &&\n\t\t\tvalue.constructor.name !== \"Object\"\n\t\t) {\n\t\t\tconstructorName = `${value.constructor.name} `;\n\t\t}\n\t\tlet entries = Object.entries(value).map(\n\t\t\t([key, value]) => `${key}: ${stringifyInner(value, visited)}`,\n\t\t);\n\t\treturn `${constructorName}{ ${entries.join(\", \")} }`;\n\t}\n};\n\nlet stringifyHandle = (\n\thandle: Object_.Handle,\n\tvisited: WeakSet<object>,\n): string => {\n\tlet { id, object } = handle.state;\n\tif (id !== undefined) {\n\t\treturn id;\n\t}\n\tif (object !== undefined) {\n\t\treturn stringifyObject(object, visited);\n\t}\n\treturn unreachable();\n};\n", "import { assert } from \"./assert.ts\";\nimport * as encoding from \"./encoding.ts\";\nimport { Module } from \"./module.ts\";\nimport { Target, functions, setCurrent } from \"./target.ts\";\nimport { Value } from \"./value.ts\";\n\nexport let main = async (target: Target): Promise<Value> => {\n\t// Load the executable.\n\tlet package_ = await target.package();\n\tassert(package_);\n\tlet packageId = await package_.id();\n\tlet executable = await target.executable();\n\tlet path = executable.components[0];\n\tassert(typeof path === \"string\");\n\tlet module_ = {\n\t\tkind: \"normal\" as const,\n\t\tvalue: { packageId, path },\n\t};\n\tlet url = Module.toUrl(module_);\n\tawait import(url);\n\n\t// Get the target.\n\tlet name = await target.name_();\n\tif (!name) {\n\t\tthrow new Error(\"The target must have a name.\");\n\t}\n\n\t// Get the function.\n\tlet key = encoding.json.encode({ url, name });\n\tlet function_ = functions[key];\n\tif (!function_) {\n\t\tthrow new Error(\"Failed to find the function.\");\n\t}\n\n\t// Set the current target.\n\tsetCurrent(target);\n\n\t// Get the args.\n\tlet args = await target.args();\n\n\t// Call the function.\n\tlet output = await function_(...args);\n\n\treturn output;\n};\n", "import { assert as assert_ } from \"./assert.ts\";\n\nexport let system = (arg: System.Arg): System => {\n\tif (typeof arg === \"string\") {\n\t\treturn arg;\n\t} else {\n\t\tlet { arch, os } = arg;\n\t\treturn `${arch}-${os}` as System;\n\t}\n};\n\nexport type System =\n\t| \"aarch64-darwin\"\n\t| \"aarch64-linux\"\n\t| \"js-js\"\n\t| \"x86_64-darwin\"\n\t| \"x86_64-linux\";\n\nexport declare namespace System {\n\tlet new_: (arg: System.Arg) => System;\n\texport { new_ as new };\n}\n\nexport namespace System {\n\texport type Arg = System | ArgObject;\n\n\texport type ArgObject = {\n\t\tarch: Arch;\n\t\tos: Os;\n\t};\n\n\texport type Arch = \"aarch64\" | \"js\" | \"x86_64\";\n\n\texport type Os = \"darwin\" | \"js\" | \"linux\";\n\texport let new_ = (arg: System.Arg): System => {\n\t\treturn system(arg);\n\t};\n\tSystem.new = new_;\n\n\texport let is = (value: unknown): value is System => {\n\t\treturn (\n\t\t\tvalue === \"aarch64-darwin\" ||\n\t\t\tvalue === \"aarch64-linux\" ||\n\t\t\tvalue === \"js-js\" ||\n\t\t\tvalue === \"x86_64-darwin\" ||\n\t\t\tvalue === \"x86_64-linux\"\n\t\t);\n\t};\n\n\texport let expect = (value: unknown): System => {\n\t\tassert_(System.is(value));\n\t\treturn value;\n\t};\n\n\texport let assert = (value: unknown): asserts value is System => {\n\t\tassert_(System.is(value));\n\t};\n\n\texport let arch = (system: System): Arch => {\n\t\tswitch (system) {\n\t\t\tcase \"aarch64-darwin\":\n\t\t\tcase \"aarch64-linux\": {\n\t\t\t\treturn \"aarch64\";\n\t\t\t}\n\t\t\tcase \"js-js\": {\n\t\t\t\treturn \"js\";\n\t\t\t}\n\t\t\tcase \"x86_64-linux\":\n\t\t\tcase \"x86_64-darwin\": {\n\t\t\t\treturn \"x86_64\";\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\tthrow new Error(\"Invalid system.\");\n\t\t\t}\n\t\t}\n\t};\n\n\texport let os = (system: System): Os => {\n\t\tswitch (system) {\n\t\t\tcase \"aarch64-darwin\":\n\t\t\tcase \"x86_64-darwin\": {\n\t\t\t\treturn \"darwin\";\n\t\t\t}\n\t\t\tcase \"js-js\": {\n\t\t\t\treturn \"js\";\n\t\t\t}\n\t\t\tcase \"x86_64-linux\":\n\t\t\tcase \"aarch64-linux\": {\n\t\t\t\treturn \"linux\";\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\tthrow new Error(\"Invalid system.\");\n\t\t\t}\n\t\t}\n\t};\n}\n", "import { assert as assert_ } from \"./assert.ts\";\nimport { Blob } from \"./blob.ts\";\nimport { Directory } from \"./directory.ts\";\nimport { File } from \"./file.ts\";\nimport { Package } from \"./package.ts\";\nimport { Symlink } from \"./symlink.ts\";\nimport { Target } from \"./target.ts\";\nimport { Template } from \"./template.ts\";\n\nexport type Value =\n\t| undefined\n\t| boolean\n\t| number\n\t| string\n\t| Uint8Array\n\t| Blob\n\t| Directory\n\t| File\n\t| Symlink\n\t| Template\n\t| Package\n\t| Target\n\t| Array<Value>\n\t| { [key: string]: Value };\n\nexport namespace Value {\n\texport let is = (value: unknown): value is Value => {\n\t\treturn (\n\t\t\tvalue === undefined ||\n\t\t\ttypeof value === \"boolean\" ||\n\t\t\ttypeof value === \"number\" ||\n\t\t\ttypeof value === \"string\" ||\n\t\t\tvalue instanceof Uint8Array ||\n\t\t\tvalue instanceof Blob ||\n\t\t\tvalue instanceof Directory ||\n\t\t\tvalue instanceof File ||\n\t\t\tvalue instanceof Symlink ||\n\t\t\tvalue instanceof Template ||\n\t\t\tvalue instanceof Package ||\n\t\t\tvalue instanceof Target ||\n\t\t\tvalue instanceof Array ||\n\t\t\ttypeof value === \"object\"\n\t\t);\n\t};\n\n\texport let expect = (value: unknown): Value => {\n\t\tassert_(is(value));\n\t\treturn value;\n\t};\n\n\texport let assert = (value: unknown): asserts value is Value => {\n\t\tassert_(is(value));\n\t};\n}\n", "import { Args } from \"./args.ts\";\nimport { Artifact } from \"./artifact.ts\";\nimport { assert, unimplemented, unreachable } from \"./assert.ts\";\nimport { Blob, blob, download } from \"./blob.ts\";\nimport { Directory, directory } from \"./directory.ts\";\nimport * as encoding from \"./encoding.ts\";\nimport { Error as Error_, prepareStackTrace } from \"./error.ts\";\nimport { File, file } from \"./file.ts\";\nimport { include } from \"./include.ts\";\nimport { log } from \"./log.ts\";\nimport { main } from \"./main.ts\";\nimport { Object_ } from \"./object.ts\";\nimport { Package } from \"./package.ts\";\nimport { resolve } from \"./resolve.ts\";\nimport { Symlink, symlink } from \"./symlink.ts\";\nimport { System, system } from \"./system.ts\";\nimport { Target, build, getCurrent, target } from \"./target.ts\";\nimport { Template, template } from \"./template.ts\";\nimport { Value } from \"./value.ts\";\n\nObject.defineProperties(Error, {\n\tprepareStackTrace: { value: prepareStackTrace },\n});\n\nObject.defineProperties(globalThis, {\n\tconsole: { value: { log } },\n});\n\nasync function tg(\n\tstrings: TemplateStringsArray,\n\t...placeholders: Args<Template.Arg>\n): Promise<Template> {\n\tlet components: Args<Template.Arg> = [];\n\tfor (let i = 0; i < strings.length - 1; i++) {\n\t\tlet string = strings[i]!;\n\t\tcomponents.push(string);\n\t\tlet placeholder = placeholders[i]!;\n\t\tcomponents.push(placeholder);\n\t}\n\tcomponents.push(strings[strings.length - 1]!);\n\treturn await template(...components);\n}\n\nObject.assign(tg, {\n\tArgs,\n\tArtifact,\n\tBlob,\n\tDirectory,\n\tError: Error_,\n\tFile,\n\tObject_,\n\tPackage,\n\tSymlink,\n\tSystem,\n\tTarget,\n\tTemplate,\n\tValue,\n\tassert,\n\tblob,\n\tbuild,\n\tdirectory,\n\tdownload,\n\tencoding,\n\tfile,\n\tinclude,\n\tlog,\n\tmain,\n\tresolve,\n\tsymlink,\n\tsystem,\n\ttarget,\n\ttemplate,\n\tunimplemented,\n\tunreachable,\n});\n\nObject.defineProperties(tg, {\n\tcurrent: { get: getCurrent },\n});\n\nObject.defineProperties(globalThis, {\n\ttg: { value: tg },\n});\n"],
  "mappings": "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",
  "names": ["assert", "condition", "message", "unimplemented", "unreachable", "encoding_exports", "__export", "base64", "hex", "json", "toml", "utf8", "yaml", "build", "target", "cause", "bundle", "artifact", "decompress", "blob", "format", "cause", "download", "url", "checksum", "encoding", "value", "extract", "log", "read", "blob", "cause", "base64", "value", "encoding", "hex", "json", "toml", "utf8", "yaml", "Object_", "Handle", "#state", "state", "id", "object", "blob", "args", "Blob", "download", "url", "checksum", "_Blob", "#handle", "handle", "id", "Object_", "children", "Args", "arg", "utf8", "unreachable", "child", "childBlob", "value", "assert", "object", "_", "size", "a", "b", "read", "format", "decompress", "extract", "Arg", "file", "args", "File", "_File", "#handle", "handle", "id", "Object_", "contentsArgs", "executableArgs", "references", "Args", "arg", "Blob", "contents", "executable", "object", "unreachable", "blob", "value", "assert", "relpath", "args", "Relpath", "subpath", "Subpath", "_Relpath", "#parents", "#subpath", "arg", "reduce", "path", "component", "unreachable", "other", "i", "string", "Arg", "value", "assert", "#components", "components", "Artifact", "value", "Directory", "File", "Symlink", "assert", "template", "args", "Template", "_Template", "#components", "components", "Args", "arg", "unreachable", "component", "lastComponent", "value", "assert", "separator", "separatorTemplate", "argTemplates", "templates", "i", "argTemplate", "Arg", "Component", "Artifact", "symlink", "args", "Symlink", "_Symlink", "#handle", "handle", "id", "Object_", "artifact", "path_", "Args", "arg", "Artifact", "Template", "assert", "firstComponent", "secondComponent", "unreachable", "path", "relpath", "target", "template", "value", "object", "from", "fromArtifact", "fromPath", "Directory", "directory", "args", "Directory", "_Directory", "#handle", "handle", "id", "Object_", "entries", "resolve", "reduce", "promiseEntries", "arg", "name", "entry", "existingEntry", "argEntry", "key", "value", "firstComponent", "trailingComponents", "subpath", "trailingPath", "newEntry", "Blob", "file", "File", "Symlink", "unreachable", "assert", "object", "artifact", "currentSubpath", "component", "resolved", "bundle", "entryName", "entryArtifact", "Package", "_Package", "#handle", "handle", "id", "Object_", "value", "assert", "object", "Module", "module", "encoding", "url", "match", "assert", "_", "data", "current", "getCurrent", "setCurrent", "target", "functions", "args", "arg", "url", "name", "key", "json", "assert", "module_", "Module", "package_", "Package", "Target", "Object_", "Template", "build", "_Target", "#handle", "handle", "this_", "_target", "prop", "_receiver", "_", "id", "host", "executable", "env_", "args_", "checksum", "unsafe_", "Args", "template", "env", "unsafe", "object", "unreachable", "processEnvMutations", "value", "init", "mutation", "mutateEnv", "t", "flatten", "resolve", "value", "Blob", "Directory", "File", "Symlink", "Template", "Package", "Target", "key", "Args", "args", "map", "flatten", "resolve", "arg", "object", "mutations", "key", "mutation", "mutate", "value", "array", "assert", "Error", "message", "location", "stack", "source", "prepareStackTrace", "_error", "structuredStackTrace", "callSite", "include", "arg", "module_", "Module", "assert", "artifact", "Package", "Directory", "path", "subpath", "log", "args", "string", "arg", "stringify", "value", "stringifyInner", "visited", "stringifyObject", "Blob", "stringifyHandle", "Directory", "File", "Symlink", "Template", "component", "Package", "Target", "constructorName", "entries", "key", "handle", "id", "object", "unreachable", "main", "target", "package_", "assert", "packageId", "path", "module_", "url", "Module", "name", "key", "json", "function_", "functions", "setCurrent", "args", "system", "arg", "arch", "os", "System", "value", "assert", "Value", "value", "Blob", "Directory", "File", "Symlink", "Template", "Package", "Target", "assert", "prepareStackTrace", "log", "tg", "strings", "placeholders", "components", "i", "string", "placeholder", "template", "Args", "Artifact", "Blob", "Directory", "Error", "File", "Object_", "Package", "Symlink", "System", "Target", "Template", "Value", "assert", "blob", "build", "directory", "download", "encoding_exports", "file", "include", "main", "resolve", "symlink", "system", "target", "unimplemented", "unreachable", "getCurrent"]
}
