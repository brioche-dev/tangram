"use strict";(()=>{var Me=Object.defineProperty;var Le=(t,e)=>{for(var r in e)Me(t,r,{get:e[r],enumerable:!0})};var o=(t,e)=>{if(!t)throw new Error(e??"Failed assertion.")},pe=t=>{throw new Error(t??"Reached unimplemented code.")},d=t=>{throw new Error(t??"Reached unreachable code.")};var E={};Le(E,{base64:()=>we,hex:()=>q,json:()=>N,toml:()=>ge,utf8:()=>V,yaml:()=>be});var ue=async(t,e)=>{try{return await syscall("archive",t,e)}catch(r){throw new Error("The syscall failed.",{cause:r})}},de=async t=>{try{return await syscall("build",t)}catch(e){throw new Error("The syscall failed.",{cause:e})}},me=async t=>{try{return await syscall("bundle",t)}catch(e){throw new Error("The syscall failed.",{cause:e})}};var G=async(t,e)=>{try{return await syscall("compress",t,e)}catch(r){throw new Error("The syscall failed.",{cause:r})}},W=async(t,e)=>{try{return await syscall("decompress",t,e)}catch(r){throw new Error("The syscall failed.",{cause:r})}},ye=async(t,e)=>{try{return await syscall("download",t,e)}catch(r){throw new Error("The syscall failed.",{cause:r})}},h={base64:{decode:t=>{try{return syscall("encoding_base64_decode",t)}catch(e){throw new Error("The syscall failed.",{cause:e})}},encode:t=>{try{return syscall("encoding_base64_encode",t)}catch(e){throw new Error("The syscall failed.",{cause:e})}}},hex:{decode:t=>{try{return syscall("encoding_hex_decode",t)}catch(e){throw new Error("The syscall failed.",{cause:e})}},encode:t=>{try{return syscall("encoding_hex_encode",t)}catch(e){throw new Error("The syscall failed.",{cause:e})}}},json:{decode:t=>{try{return syscall("encoding_json_decode",t)}catch(e){throw new Error("The syscall failed.",{cause:e})}},encode:t=>{try{return syscall("encoding_json_encode",t)}catch(e){throw new Error("The syscall failed.",{cause:e})}}},toml:{decode:t=>{try{return syscall("encoding_toml_decode",t)}catch(e){throw new Error("The syscall failed.",{cause:e})}},encode:t=>{try{return syscall("encoding_toml_encode",t)}catch(e){throw new Error("The syscall failed.",{cause:e})}}},utf8:{decode:t=>{try{return syscall("encoding_utf8_decode",t)}catch(e){throw new Error("The syscall failed.",{cause:e})}},encode:t=>{try{return syscall("encoding_utf8_encode",t)}catch(e){throw new Error("The syscall failed.",{cause:e})}}},yaml:{decode:t=>{try{return syscall("encoding_yaml_decode",t)}catch(e){throw new Error("The syscall failed.",{cause:e})}},encode:t=>{try{return syscall("encoding_yaml_encode",t)}catch(e){throw new Error("The syscall failed.",{cause:e})}}}},H=async(t,e)=>{try{return await syscall("extract",t,e)}catch(r){throw new Error("The syscall failed.",{cause:r})}},fe=t=>{try{return syscall("log",t)}catch(e){throw new Error("The syscall failed.",{cause:e})}},k=async t=>{try{return await syscall("load",t)}catch(e){throw new Error("The syscall failed.",{cause:e})}},K=async t=>{try{return await syscall("read",t)}catch(e){throw new Error("The syscall failed.",{cause:e})}},j=async t=>{try{return await syscall("store",t)}catch(e){throw new Error("The syscall failed.",{cause:e})}},he=async t=>{try{return await syscall("sleep",t)}catch(e){throw new Error("The syscall failed.",{cause:e})}};var we;(r=>(r.decode=n=>h.base64.decode(n),r.encode=n=>h.base64.encode(n)))(we||={});var q;(r=>(r.decode=n=>h.hex.decode(n),r.encode=n=>h.hex.encode(n)))(q||={});var N;(r=>(r.decode=n=>h.json.decode(n),r.encode=n=>h.json.encode(n)))(N||={});var ge;(r=>(r.decode=n=>h.toml.decode(n),r.encode=n=>h.toml.encode(n)))(ge||={});var V;(r=>(r.decode=n=>h.utf8.decode(n),r.encode=n=>h.utf8.encode(n)))(V||={});var be;(r=>(r.decode=n=>h.yaml.decode(n),r.encode=n=>h.yaml.encode(n)))(be||={});var J=async(...t)=>await x.new(...t),x=class t{#e;constructor(e){this.#e=e}get state(){return this.#e}static withId(e){return new t({id:e})}static async new(...e){let{contents:r,executable:n,references:s}=await g(e,async c=>{if(c===void 0)return{};if(typeof c=="string"||c instanceof Uint8Array||M.is(c))return{contents:await p({kind:"array_append",values:[c]})};if(t.is(c))return{contents:await p({kind:"array_append",values:[await c.contents()]}),executable:await p({kind:"array_append",values:[await c.executable()]}),references:await p({kind:"array_append",values:[await c.references()]})};if(typeof c=="object"){let y={};return c.contents!==void 0&&(y.contents=await p({kind:"array_append",values:[c.contents]})),c.executable!==void 0&&(y.executable=await p({kind:"array_append",values:[c.executable]})),c.references!==void 0&&(y.references=await p({kind:"array_append",values:[c.references]})),y}else return d()}),i=await Q(r),a=(n??[]).some(c=>c),l=s??[];return new t({object:{contents:i,executable:a,references:l}})}static is(e){return e instanceof t}static expect(e){return o(t.is(e)),e}static assert(e){o(t.is(e))}async id(){return await this.store(),this.#e.id}async object(){return await this.load(),this.#e.object}async load(){if(this.#e.object===void 0){let e=await k(this.#e.id);o(e.kind==="file"),this.#e.object=e.value}}async store(){this.#e.id===void 0&&(this.#e.id=await j({kind:"file",value:this.#e.object}))}async contents(){return(await this.object()).contents}async executable(){return(await this.object()).executable}async references(){return(await this.object()).references}async size(){return(await this.contents()).size()}async bytes(){return(await this.contents()).bytes()}async text(){return(await this.contents()).text()}};var Ae=async(...t)=>await A.new(...t),A=class t{#e;constructor(e){this.#e=e}get state(){return this.#e}static withId(e){return new t({id:e})}static async new(...e){let{bytes:r}=await g(e,async a=>a===void 0?{}:typeof a=="string"?{bytes:await p({kind:"array_append",values:[V.encode(a)]})}:a instanceof Uint8Array?{bytes:await p({kind:"array_append",values:[a]})}:t.is(a)?{bytes:await p({kind:"array_append",values:[await a.bytes()]})}:typeof a=="object"?{bytes:await p({kind:"array_append",values:[a.bytes??new Uint8Array]})}:d());r??=[];let n=r.reduce((a,l)=>a+l.byteLength,0),s=new Uint8Array(n),i=0;for(let a of r)s.set(a,i),i+=a.byteLength;return new t({object:{bytes:s}})}static is(e){return e instanceof t}static expect(e){return o(t.is(e)),e}static assert(e){o(t.is(e))}async id(){return await this.store(),this.#e.id}async object(){return await this.load(),this.#e.object}async load(){if(this.#e.object===void 0){let e=await k(this.#e.id);o(e.kind==="leaf"),this.#e.object=e.value}}async store(){this.#e.id===void 0&&(this.#e.id=await j({kind:"leaf",value:this.#e.object}))}async size(){return(await this.object()).bytes.byteLength}async bytes(){return(await this.object()).bytes}async text(){return V.decode(await K(this))}async compress(e){return await G(this,e)}async decompress(e){return await W(this,e)}async extract(e){return await H(this,e)}};var B=class t{#e;constructor(e){this.#e=e}get state(){return this.#e}static withId(e){return new t({id:e})}static is(e){return e instanceof t}static expect(e){return o(t.is(e)),e}static assert(e){o(t.is(e))}async id(){return await this.store(),this.#e.id}async object(){return await this.load(),this.#e.object}async load(){if(this.#e.object===void 0){let e=await k(this.#e.id);o(e.kind==="lock"),this.#e.object=e.value}}async store(){this.#e.id===void 0&&(this.#e.id=await j({kind:"lock",value:this.#e.object}))}async dependencies(){return(await this.object()).dependencies}};var $=(...t)=>C.new(...t),L=(...t)=>I.new(...t),C=class t{#e;#t;constructor(e){this.#e=e?.parents??0,this.#t=e?.subpath??new I}static new(...e){return e.reduce(function r(n,s){if(typeof s=="string")for(let i of s.split("/"))i===""||i==="."||(i===".."?n=n.parent():n.#t.push(i));else if(s instanceof t){for(let i=0;i<s.#e;i++)n.parent();n.#t.join(s.#t)}else if(s instanceof I)n.#t.join(s);else if(s instanceof Array)s.forEach(i=>r(n,i));else return d();return n},new t)}isEmpty(){return this.#e==0&&this.#t.isEmpty()}parents(){return this.#e}subpath(){return this.#t}parent(){return this.#t.isEmpty()?this.#e+=1:this.#t.pop(),this}join(e){e=t.new(e);for(let r=0;r<e.#e;r++)this.parent();return this.#t.join(e.#t),this}extension(){return this.#t.extension()}toSubpath(){if(this.#e>0)throw new Error("Cannot convert to subpath.");return this.#t}toString(){let e="";for(let r=0;r<this.#e;r++)e+="../";return e+=this.#t.toString(),e}};(e=>{let t;(i=>(i.is=a=>I.Arg.is(a)||a instanceof e||a instanceof Array&&a.every(e.Arg.is),i.expect=a=>(o((0,i.is)(a)),a),i.assert=a=>{o((0,i.is)(a))}))(t=e.Arg||={})})(C||={});var I=class{#e;constructor(e){this.#e=e??[]}static new(...e){return C.new(...e).toSubpath()}components(){return[...this.#e]}isEmpty(){return this.#e.length==0}join(e){return this.#e.push(...e.#e),this}push(e){this.#e.push(e)}pop(){this.#e.pop()}extension(){return this.#e.at(-1)?.split(".").at(-1)}toRelpath(){return C.new(this)}toString(){return this.#e.join("/")}};(e=>{let t;(i=>(i.is=a=>a===void 0||typeof a=="string"||a instanceof e||a instanceof Array&&a.every(e.Arg.is),i.expect=a=>(o((0,i.is)(a)),a),i.assert=a=>{o((0,i.is)(a))}))(t=e.Arg||={})})(I||={});var T=(...t)=>m.new(...t),m=class t{#e;constructor(e){this.#e=e}static async new(...e){let{components:r}=await g(e,async n=>n===void 0?{}:typeof n=="string"||b.is(n)?{components:await p({kind:"array_append",values:[n]})}:t.is(n)?{components:await p({kind:"array_append",values:n.components})}:d());return r=(r??[]).reduce((n,s)=>{let i=n.at(-1);return s===""||(typeof i=="string"&&typeof s=="string"?n.splice(-1,1,i+s):n.push(s)),n},[]),new t(r)}static is(e){return e instanceof t}static expect(e){return o(t.is(e)),e}static assert(e){o(t.is(e))}static async join(e,...r){let n=await T(e),s=await Promise.all(r.map(a=>T(a)));s=s.filter(a=>a.components.length>0);let i=[];for(let a=0;a<s.length;a++){a>0&&i.push(n);let l=s[a];o(l),i.push(l)}return T(...i)}get components(){return this.#e}};var ne=async(...t)=>await f.new(...t),f=class t{#e;constructor(e){this.#e=e}get state(){return this.#e}static withId(e){return new t({id:e})}static async new(...e){let{artifact:r,path:n}=await g(e,async a=>{if(a===void 0)return{};if(typeof a=="string")return{path:await p({kind:"array_append",values:[a]})};if(b.is(a))return{artifact:a,path:await p({kind:"unset"})};if(m.is(a)){o(a.components.length<=2);let[l,c]=a.components;if(typeof l=="string"&&c===void 0)return{path:await p({kind:"array_append",values:[l]})};if(b.is(l)&&c===void 0)return{artifact:l,path:await p({kind:"unset"})};if(b.is(l)&&typeof c=="string")return o(c.startsWith("/")),{artifact:l,path:[c.slice(1)]};throw new Error("Invalid template.")}else{if(t.is(a))return{artifact:await a.artifact(),path:[(await a.path()).toString()]};if(typeof a=="object"){let l={};return"artifact"in a&&(l.artifact=a.artifact),"path"in a&&(l.path=await p({kind:"set",value:[a.path]})),l}else return d()}}),s=$(n),i;if(r!==void 0&&!s.isEmpty())i=await T(r,"/",s.toString());else if(r!==void 0)i=await T(r);else if(!s.isEmpty())i=await T(s.toString());else throw new Error("Invalid symlink.");return new t({object:{target:i}})}static is(e){return e instanceof t}static expect(e){return o(t.is(e)),e}static assert(e){o(t.is(e))}async id(){return await this.store(),this.#e.id}async object(){return await this.load(),this.#e.object}async load(){if(this.#e.object===void 0){let e=await k(this.#e.id);o(e.kind==="symlink"),this.#e.object=e.value}}async store(){this.#e.id===void 0&&(this.#e.id=await j({kind:"symlink",value:this.#e.object}))}async target(){return(await this.object()).target}async artifact(){let r=(await this.target()).components.at(0);if(b.is(r))return r}async path(){let e=await this.target(),[r,n]=e.components;if(typeof r=="string"&&n===void 0)return $(r);if(b.is(r)&&n===void 0)return $();if(b.is(r)&&typeof n=="string")return $(n.slice(1));throw new Error("Invalid template.")}async resolve(e){e=e?await ne(e):void 0;let r=await e?.artifact();t.is(r)&&(r=await r.resolve());let n=e?.path(),s=await this.artifact();t.is(s)&&(s=await s.resolve());let i=await this.path();if(s!==void 0&&i.isEmpty())return s;if(s===void 0&&!i.isEmpty()){if(!w.is(r))throw new Error("Expected a directory.");return await r.tryGet((await(n??$())).parent().join(i).toSubpath().toString())}else if(s!==void 0&&!i.isEmpty()){if(!w.is(s))throw new Error("Expected a directory.");return await s.tryGet(i.toSubpath().toString())}else throw new Error("Invalid symlink.")}};var F;(r=>(r.toUrl=n=>`tangram://${h.hex.encode(h.utf8.encode(h.json.encode(n)))}/${n.value.path}`,r.fromUrl=n=>{let s=n.match(/^tangram:\/\/([0-9a-f]+)/);o(s);let[i,a]=s;return o(a!==void 0),h.json.decode(h.utf8.decode(h.hex.decode(a)))}))(F||={});var xe,ke={},X=()=>xe,je=t=>{xe=t},Ie=()=>ke,Te=t=>{ke=t},Y={};function ae(...t){if(t.length===1&&typeof t[0]=="object"&&"function"in t[0]){let e=t[0],{url:r,name:n}=e,s=N.encode({url:r,name:n});o(Y[s]===void 0),Y[s]=e.function;let i=F.fromUrl(e.url);o(i.kind==="normal");let a=B.withId(i.value.lock),l=new f({object:{target:new m([w.withId(i.value.package),"/"+i.value.path])}});return new _({object:{host:"js-js",executable:l,lock:a,name:e.name,args:[],env:Ie(),checksum:void 0}})}else return _.new(...t)}var Pe=async(...t)=>await(await ae(...t)).build(),_=class t extends globalThis.Function{#e;constructor(e){super(),this.#e=e;let r=this;return new Proxy(r,{get(n,s,i){return typeof r[s]=="function"?r[s].bind(r):r[s]},apply:async(n,s,i)=>await n.build(...i),getPrototypeOf:n=>Object.getPrototypeOf(r)})}get state(){return this.#e}static withId(e){return new t({id:e})}static async new(...e){let{host:r,executable:n,lock:s,name:i,env:a,args:l,checksum:c}=await g([{env:await X().env()},...e],async u=>{if(typeof u=="string"||b.is(u)||u instanceof m)return{host:(await X().env()).TANGRAM_HOST,executable:new f({object:{target:new m(["/bin/sh"])}}),args:["-c",u]};if(t.is(u))return await u.object();if(typeof u=="object"){let S={};return"env"in u&&(S.env=u.env!==void 0?await p({kind:"array_append",values:[u.env]}):await p({kind:"unset"})),"args"in u&&(S.args=u.args!==void 0?await p({kind:"array_append",values:[...u.args]}):await p({kind:"unset"})),{...u,...S}}else return d()});if(!r)throw new Error("Cannot create a target without a host.");if(!n)throw new Error("Cannot create a target without an executable.");let y=await g(R(a??[]),async u=>u);return l??=[],new t({object:{host:r,executable:n,lock:s,name:i,env:y,args:l,checksum:c}})}static is(e){return e instanceof t}static expect(e){return o(t.is(e)),e}static assert(e){o(t.is(e))}async id(){return await this.store(),this.#e.id}async object(){return await this.load(),this.#e.object}async load(){if(this.#e.object===void 0){let e=await k(this.#e.id);o(e.kind==="target"),this.#e.object=e.value}}async store(){this.#e.id===void 0&&(this.#e.id=await j({kind:"target",value:this.#e.object}))}async host(){return(await this.object()).host}async executable(){return(await this.object()).executable}async lock(){return(await this.object()).lock}async name_(){return(await this.object()).name}async env(){return(await this.object()).env}async args(){return(await this.object()).args}async checksum(){return(await this.object()).checksum}async build(...e){return await de(await t.new(this,{args:e}))}};var O=async t=>{if(t=await t,t===void 0||typeof t=="boolean"||typeof t=="number"||typeof t=="string"||t instanceof Uint8Array||t instanceof A||t instanceof P||t instanceof w||t instanceof x||t instanceof f||t instanceof m||t instanceof U||t instanceof B||t instanceof _)return t;if(t instanceof Array)return await Promise.all(t.map(e=>O(e)));if(typeof t=="object")return Object.fromEntries(await Promise.all(Object.entries(t).map(async([e,r])=>[e,await O(r)])));throw new Error("Invalid value to resolve.")};async function p(t){return await U.new(t)}var g=async(t,e)=>R(await Promise.all(R(await Promise.all(t.map(O))).map(r=>e(r)))).reduce(async(r,n)=>{for(let[s,i]of Object.entries(n))await Ce(await r,s,i);return r},Promise.resolve({})),U=class t{#e;constructor(e){this.#e=e}static async new(e){let r=await O(e);return r.kind==="array_prepend"||r.kind==="array_append"?new t({kind:r.kind,value:R(r.values)}):r.kind==="template_prepend"||r.kind==="template_append"?new t({kind:r.kind,value:await T(r.template),separator:r.separator}):r.kind==="unset"?new t({kind:"unset"}):new t({kind:r.kind,value:r.value})}static is(e){return e instanceof t}static expect(e){return o(t.is(e)),e}static assert(e){o(t.is(e))}get inner(){return this.#e}},R=t=>t instanceof Array?t.flat(1/0):[t],Ce=async(t,e,r)=>{if(!(r instanceof U))t[e]=r;else if(r.inner.kind==="unset")delete t[e];else if(r.inner.kind==="set")t[e]=r.inner.value;else if(r.inner.kind==="set_if_unset")e in t||(t[e]=r.inner.value);else if(r.inner.kind==="array_prepend"){e in t||(t[e]=[]);let n=t[e];o(n instanceof Array),t[e]=[...n,...R(r.inner.value)]}else if(r.inner.kind==="array_append"){e in t||(t[e]=[]);let n=t[e];o(n instanceof Array),t[e]=[...n,...R(r.inner.value)]}else if(r.inner.kind==="template_prepend"){e in t||(t[e]=await T());let n=t[e];o(n===void 0||typeof n=="string"||b.is(n)||n instanceof m),t[e]=await m.join(r.inner.separator,r.inner.value,n)}else if(r.inner.kind==="template_append"){e in t||(t[e]=await T());let n=t[e];o(n===void 0||typeof n=="string"||b.is(n)||n instanceof m),t[e]=await m.join(r.inner.separator,n,r.inner.value)}};var _e=async(...t)=>await P.new(...t),P=class t{#e;constructor(e){this.#e=e}get state(){return this.#e}static withId(e){return new t({id:e})}static async new(...e){let{children:r}=await g(e,async n=>n===void 0?{}:t.is(n)?{children:await p({kind:"array_append",values:[{blob:n,size:await n.size()}]})}:typeof n=="object"?{children:await p({kind:"array_append",values:n.children??[]})}:d());return r??=[],new t({object:{children:r}})}static is(e){return e instanceof t}static expect(e){return o(t.is(e)),e}static assert(e){o(t.is(e))}async id(){return await this.store(),this.#e.id}async object(){return await this.load(),this.#e.object}async load(){if(this.#e.object===void 0){let e=await k(this.#e.id);o(e.kind==="branch"),this.#e.object=e.value}}async store(){this.#e.id===void 0&&(this.#e.id=await j({kind:"branch",value:this.#e.object}))}async children(){return(await this.object()).children}async size(){return(await this.children()).map(({size:e})=>e).reduce((e,r)=>e+r,0)}async bytes(){return await K(this)}async text(){return V.decode(await K(this))}async compress(e){return await G(this,e)}async decompress(e){return await W(this,e)}async extract(e){return await H(this,e)}};var Q=async(...t)=>await M.new(...t),Se=async(t,e)=>await M.download(t,e),M;(i=>(i.new_=async(...a)=>{let{children:l}=await g(a,async c=>{if(c===void 0)return{};if(typeof c=="string"){let y=new A({object:{bytes:V.encode(c)}});return{children:await p({kind:"array_append",values:[y]})}}else if(c instanceof Uint8Array){let y=new A({object:{bytes:c}});return{children:await p({kind:"array_append",values:[y]})}}else return i.is(c)?{children:await p({kind:"array_append",values:[c]})}:d()});if(!l||l.length===0)return new A({object:{bytes:new Uint8Array}});if(l.length===1)return l[0];{let c=await Promise.all(l.map(async y=>({blob:y,size:await y.size()})));return new P({object:{children:c}})}},i.new=i.new_,i.is=a=>A.is(a)||P.is(a),i.expect=a=>(o((0,i.is)(a)),a),i.assert=a=>{o((0,i.is)(a))},i.download=async(a,l)=>await ye(a,l)))(M||={});var ve=async(...t)=>await w.new(...t),w=class t{#e;constructor(e){this.#e=e}get state(){return this.#e}static withId(e){return new t({id:e})}static async new(...e){let r=await(await Promise.all(e.map(O))).reduce(async function n(s,i){let a=await s;if(i!==void 0)if(t.is(i))for(let[l,c]of Object.entries(await i.entries())){let y=a[l];t.is(y)&&t.is(c)&&(c=await t.new(y,c)),a[l]=c}else if(i instanceof Array)for(let l of i)a=await n(Promise.resolve(a),l);else if(typeof i=="object")for(let[l,c]of Object.entries(i)){let[y,...u]=L(l).components();if(y===void 0)throw new Error("The path must have at least one component.");let S=y,z=a[S];if(t.is(z)||(z=void 0),u.length>0){let re=L(u).toString(),Ee=await t.new(z,{[re]:c});a[S]=Ee}else if(c===void 0)delete a[S];else if(typeof c=="string"||c instanceof Uint8Array||M.is(c)){let re=await J(c);a[S]=re}else x.is(c)||f.is(c)?a[S]=c:a[S]=await t.new(z,c)}else return d();return a},Promise.resolve({}));return new t({object:{entries:r}})}static is(e){return e instanceof t}static expect(e){return o(t.is(e)),e}static assert(e){o(t.is(e))}async id(){return await this.store(),this.#e.id}async object(){return await this.load(),this.#e.object}async load(){if(this.#e.object===void 0){let e=await k(this.#e.id);o(e.kind==="directory"),this.#e.object=e.value}}async store(){this.#e.id===void 0&&(this.#e.id=await j({kind:"directory",value:this.#e.object}))}async get(e){let r=await this.tryGet(e);return o(r,`Failed to get the directory entry "${e}".`),r}async tryGet(e){let r=this,n=L();for(let s of L(e).components()){if(!t.is(r))return;n.push(s);let i=(await r.entries())[s];if(i===void 0)return;if(f.is(i)){let a=await i.resolve({artifact:this,path:n.toString()});if(a===void 0)return;r=a}else r=i}return r}async entries(){let e={};for await(let[r,n]of this)e[r]=n;return e}async bundle(){return await me(this)}async*walk(){for await(let[e,r]of this)if(yield[L(e),r],t.is(r))for await(let[n,s]of r.walk())yield[L(e).join(n),s]}async*[Symbol.asyncIterator](){let e=await this.object();for(let[r,n]of Object.entries(e.entries))yield[r,n]}};var b;(s=>(s.is=i=>w.is(i)||x.is(i)||f.is(i),s.expect=i=>(o((0,s.is)(i)),i),s.assert=i=>{o((0,s.is)(i))},s.archive=async(i,a)=>await ue(i,a)))(b||={});var Z=class{message;location;stack;source;constructor(e,r,n,s){this.message=e,this.location=r,this.stack=n,this.source=s}},Be=(t,e)=>({callSites:e.map(n=>({typeName:n.getTypeName(),functionName:n.getFunctionName(),methodName:n.getMethodName(),fileName:n.getFileName(),lineNumber:n.getLineNumber(),columnNumber:n.getColumnNumber(),isEval:n.isEval(),isNative:n.isNative(),isConstructor:n.isConstructor(),isAsync:n.isAsync(),isPromiseAll:n.isPromiseAll(),promiseIndex:n.getPromiseIndex()}))});var Ue=async t=>{let e=F.fromUrl(t.url);o(e.kind==="normal");let r=w.withId(e.value.package),n=L(e.value.path).toRelpath().parent().join(t.path).toSubpath().toString();return await r.get(n)};var se=(...t)=>{let e=t.map(r=>Fe(r)).join(" ")+`
`;fe(e)},Fe=t=>ee(t,new WeakSet),ee=(t,e)=>{switch(typeof t){case"string":return`"${t}"`;case"number":return t.toString();case"boolean":return t?"true":"false";case"undefined":return"undefined";case"object":return t===null?"null":te(t,e);case"function":return _.is(t)?te(t,e):`(function "${t.name??"(anonymous)"}")`;case"symbol":return"(symbol)";case"bigint":return t.toString()}},te=(t,e)=>{if(e.has(t))return"(circular)";if(e.add(t),t instanceof Array)return`[${t.map(r=>ee(r,e)).join(", ")}]`;if(t instanceof Uint8Array)return`(tg.bytes ${q.encode(t)})`;if(t instanceof Error)return t.message;if(t instanceof Promise)return"(promise)";if(A.is(t))return D("leaf",t.state,e);if(P.is(t))return D("branch",t.state,e);if(w.is(t))return D("directory",t.state,e);if(x.is(t))return D("file",t.state,e);if(f.is(t))return D("symlink",t.state,e);if(B.is(t))return D("lock",t.state,e);if(_.is(t))return D("target",t.state,e);if(U.is(t))return`(tg.mutation ${te(t.inner,e)})`;if(m.is(t))return`\`${t.components.map(r=>typeof r=="string"?r:`\${${ee(r,e)}}`).join("")}\``;{let r="";t.constructor!==void 0&&t.constructor.name!=="Object"&&(r+=`${t.constructor.name} `),r+="{";let n=Object.entries(t);return n.length>0&&(r+=" "),r+=n.map(([s,i])=>`"${s}": ${ee(i,e)}`).join(", "),n.length>0&&(r+=" "),r+="}",r}},D=(t,e,r)=>{let{id:n,object:s}=e;return n!==void 0?n:s!==void 0?`(tg.${t} ${te(s,r)})`:d()};var Oe=async t=>{je(t),Te(await t.env());let e=await t.lock();o(e);let r=await e.id(),n=await t.executable();f.assert(n);let s=await n.artifact();o(s);let i=await s.id(),a=await n.path();o(a);let l=F.toUrl({kind:"normal",value:{lock:r,package:i,path:a.toString()}});await import(l);let c=await t.name_();if(!c)throw new Error("The target must have a name.");let y=N.encode({url:l,name:c}),u=Y[y];if(!u)throw new Error("Failed to find the function.");let S=await t.args();return await O(u(...S))};var Ve=async t=>await he(t);var ie=t=>{if(typeof t=="string")return t;{let{arch:e,os:r}=t;return`${e}-${r}`}},oe;(a=>(a.new_=l=>ie(l),a.new=a.new_,a.is=l=>l==="aarch64-darwin"||l==="aarch64-linux"||l==="js-js"||l==="x86_64-darwin"||l==="x86_64-linux",a.expect=l=>(o(a.is(l)),l),a.assert=l=>{o(a.is(l))},a.arch=l=>{switch(l){case"aarch64-darwin":case"aarch64-linux":return"aarch64";case"js-js":return"js";case"x86_64-linux":case"x86_64-darwin":return"x86_64";default:throw new Error("Invalid system.")}},a.os=l=>{switch(l){case"aarch64-darwin":case"x86_64-darwin":return"darwin";case"js-js":return"js";case"x86_64-linux":case"aarch64-linux":return"linux";default:throw new Error("Invalid system.")}}))(oe||={});var le;(n=>(n.is=s=>s===void 0||typeof s=="boolean"||typeof s=="number"||typeof s=="string"||s instanceof Uint8Array||s instanceof A||s instanceof P||s instanceof w||s instanceof x||s instanceof f||s instanceof B||s instanceof _||s instanceof U||s instanceof m||s instanceof Array||typeof s=="object",n.expect=s=>(o((0,n.is)(s)),s),n.assert=s=>{o((0,n.is)(s))}))(le||={});Object.defineProperties(Error,{prepareStackTrace:{value:Be}});Object.defineProperties(globalThis,{console:{value:{log:se}}});async function ce(t,...e){let r=[];for(let n=0;n<t.length-1;n++){let s=t[n];r.push(s);let i=e[n];r.push(i)}return r.push(t[t.length-1]),await T(...r)}Object.assign(ce,{Artifact:b,Blob:M,Branch:P,Directory:w,Error:Z,File:x,Leaf:A,Lock:B,Mutation:U,Symlink:f,System:oe,Target:_,Template:m,Value:le,apply:g,assert:o,blob:Q,branch:_e,build:Pe,directory:ve,download:Se,encoding:E,file:J,include:Ue,leaf:Ae,log:se,main:Oe,mutation:p,resolve:O,sleep:Ve,symlink:ne,system:ie,target:ae,template:T,unimplemented:pe,unreachable:d});Object.defineProperties(ce,{current:{get:X}});Object.defineProperties(globalThis,{tg:{value:ce}});})();
//# sourceMappingURL=runtime.js.map
