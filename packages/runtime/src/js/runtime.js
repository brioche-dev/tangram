"use strict";(()=>{var Se=Object.defineProperty;var Ve=(t,e)=>{for(var r in e)Se(t,r,{get:e[r],enumerable:!0})};var o=(t,e)=>{if(!t)throw new Error(e??"Failed assertion.")},ce=t=>{throw new Error(t??"Reached unimplemented code.")},m=t=>{throw new Error(t??"Reached unreachable code.")};var V={};Ve(V,{base64:()=>he,hex:()=>q,json:()=>N,toml:()=>ge,utf8:()=>S,yaml:()=>we});var pe=async(t,e)=>{try{return await syscall("archive",t,e)}catch(r){throw new Error("The syscall failed.",{cause:r})}},ue=async t=>{try{return await syscall("build",t)}catch(e){throw new Error("The syscall failed.",{cause:e})}},de=async t=>{try{return await syscall("bundle",t)}catch(e){throw new Error("The syscall failed.",{cause:e})}};var K=async(t,e)=>{try{return await syscall("compress",t,e)}catch(r){throw new Error("The syscall failed.",{cause:r})}},G=async(t,e)=>{try{return await syscall("decompress",t,e)}catch(r){throw new Error("The syscall failed.",{cause:r})}},me=async(t,e)=>{try{return await syscall("download",t,e)}catch(r){throw new Error("The syscall failed.",{cause:r})}},h={base64:{decode:t=>{try{return syscall("encoding_base64_decode",t)}catch(e){throw new Error("The syscall failed.",{cause:e})}},encode:t=>{try{return syscall("encoding_base64_encode",t)}catch(e){throw new Error("The syscall failed.",{cause:e})}}},hex:{decode:t=>{try{return syscall("encoding_hex_decode",t)}catch(e){throw new Error("The syscall failed.",{cause:e})}},encode:t=>{try{return syscall("encoding_hex_encode",t)}catch(e){throw new Error("The syscall failed.",{cause:e})}}},json:{decode:t=>{try{return syscall("encoding_json_decode",t)}catch(e){throw new Error("The syscall failed.",{cause:e})}},encode:t=>{try{return syscall("encoding_json_encode",t)}catch(e){throw new Error("The syscall failed.",{cause:e})}}},toml:{decode:t=>{try{return syscall("encoding_toml_decode",t)}catch(e){throw new Error("The syscall failed.",{cause:e})}},encode:t=>{try{return syscall("encoding_toml_encode",t)}catch(e){throw new Error("The syscall failed.",{cause:e})}}},utf8:{decode:t=>{try{return syscall("encoding_utf8_decode",t)}catch(e){throw new Error("The syscall failed.",{cause:e})}},encode:t=>{try{return syscall("encoding_utf8_encode",t)}catch(e){throw new Error("The syscall failed.",{cause:e})}}},yaml:{decode:t=>{try{return syscall("encoding_yaml_decode",t)}catch(e){throw new Error("The syscall failed.",{cause:e})}},encode:t=>{try{return syscall("encoding_yaml_encode",t)}catch(e){throw new Error("The syscall failed.",{cause:e})}}}},W=async(t,e)=>{try{return await syscall("extract",t,e)}catch(r){throw new Error("The syscall failed.",{cause:r})}},ye=t=>{try{return syscall("log",t)}catch(e){throw new Error("The syscall failed.",{cause:e})}};var z=async t=>{try{return await syscall("read",t)}catch(e){throw new Error("The syscall failed.",{cause:e})}};var fe=async t=>{try{return await syscall("sleep",t)}catch(e){throw new Error("The syscall failed.",{cause:e})}};var he;(r=>(r.decode=n=>h.base64.decode(n),r.encode=n=>h.base64.encode(n)))(he||={});var q;(r=>(r.decode=n=>h.hex.decode(n),r.encode=n=>h.hex.encode(n)))(q||={});var N;(r=>(r.decode=n=>h.json.decode(n),r.encode=n=>h.json.encode(n)))(N||={});var ge;(r=>(r.decode=n=>h.toml.decode(n),r.encode=n=>h.toml.encode(n)))(ge||={});var S;(r=>(r.decode=n=>h.utf8.decode(n),r.encode=n=>h.utf8.encode(n)))(S||={});var we;(r=>(r.decode=n=>h.yaml.decode(n),r.encode=n=>h.yaml.encode(n)))(we||={});var u;(e=>{class t{#e;constructor(n){this.#e=n}get state(){return this.#e}static withId(n){return new t({id:n,object:void 0})}static withObject(n){return new t({id:void 0,object:n})}async id(){return await this.store(),this.#e.id}async object(){return await this.load(),this.#e.object}async load(){this.#e.object===void 0&&(this.#e.object=await syscall("load",this.#e.id))}async store(){this.#e.id===void 0&&(this.#e.id=await syscall("store",this.#e.object))}}e.Handle=t})(u||={});var J=async(...t)=>await j.new(...t),j=class t{#e;constructor(e){this.#e=e}static withId(e){return new t(u.Handle.withId(e))}static async new(...e){let{contents:r,executable:n,references:i}=await w(e,async l=>{if(l===void 0)return{};if(typeof l=="string"||l instanceof Uint8Array||I.is(l))return{contents:await p({kind:"array_append",values:[l]})};if(t.is(l))return{contents:await p({kind:"array_append",values:[await l.contents()]}),executable:await p({kind:"array_append",values:[await l.executable()]}),references:await p({kind:"array_append",values:[await l.references()]})};if(typeof l=="object"){let d={};return l.contents!==void 0&&(d.contents=await p({kind:"array_append",values:[l.contents]})),l.executable!==void 0&&(d.executable=await p({kind:"array_append",values:[l.executable]})),l.references!==void 0&&(d.references=await p({kind:"array_append",values:[l.references]})),d}else return m()}),s=await Q(r),a=(n??[]).some(l=>l),c=i??[];return new t(u.Handle.withObject({kind:"file",value:{contents:s,executable:a,references:c}}))}static is(e){return e instanceof t}static expect(e){return o(t.is(e)),e}static assert(e){o(t.is(e))}async id(){return await this.#e.id()}async object(){let e=await this.#e.object();return o(e.kind==="file"),e.value}get handle(){return this.#e}async contents(){return(await this.object()).contents}async executable(){return(await this.object()).executable}async references(){return(await this.object()).references}async size(){return(await this.contents()).size()}async bytes(){return(await this.contents()).bytes()}async text(){return(await this.contents()).text()}};var be=async(...t)=>await x.new(...t),x=class t{#e;constructor(e){this.#e=e}static withId(e){return new t(u.Handle.withId(e))}static async new(...e){let{bytes:r}=await w(e,async a=>a===void 0?{}:typeof a=="string"?{bytes:await p({kind:"array_append",values:[S.encode(a)]})}:a instanceof Uint8Array?{bytes:await p({kind:"array_append",values:[a]})}:t.is(a)?{bytes:await p({kind:"array_append",values:[await a.bytes()]})}:typeof a=="object"?{bytes:await p({kind:"array_append",values:[a.bytes??new Uint8Array]})}:m());r??=[];let n=r.reduce((a,c)=>a+c.byteLength,0),i=new Uint8Array(n),s=0;for(let a of r)i.set(a,s),s+=a.byteLength;return new t(u.Handle.withObject({kind:"leaf",value:{bytes:i}}))}static is(e){return e instanceof t}static expect(e){return o(t.is(e)),e}static assert(e){o(t.is(e))}async id(){return await this.#e.id()}async object(){let e=await this.#e.object();return o(e.kind==="leaf"),e.value}get handle(){return this.#e}async size(){return(await this.object()).bytes.byteLength}async bytes(){return(await this.object()).bytes}async text(){return S.decode(await z(this))}async compress(e){return await K(this,e)}async decompress(e){return await G(this,e)}async extract(e){return await W(this,e)}};var T=class t{#e;constructor(e){this.#e=e}static withId(e){return new t(u.Handle.withId(e))}static is(e){return e instanceof t}static expect(e){return o(t.is(e)),e}static assert(e){o(t.is(e))}async id(){return await this.#e.id()}async object(){let e=await this.#e.object();return o(e.kind==="package"),e.value}get handle(){return this.#e}async artifact(){return(await this.object()).artifact}async dependencies(){return(await this.object()).dependencies}};var $=(...t)=>C.new(...t),E=(...t)=>M.new(...t),C=class t{#e;#t;constructor(e){this.#e=e?.parents??0,this.#t=e?.subpath??new M}static new(...e){return e.reduce(function r(n,i){if(typeof i=="string")for(let s of i.split("/"))s===""||s==="."||(s===".."?n=n.parent():n.#t.push(s));else if(i instanceof t){for(let s=0;s<i.#e;s++)n.parent();n.#t.join(i.#t)}else if(i instanceof M)n.#t.join(i);else if(i instanceof Array)i.forEach(s=>r(n,s));else return m();return n},new t)}isEmpty(){return this.#e==0&&this.#t.isEmpty()}parents(){return this.#e}subpath(){return this.#t}parent(){return this.#t.isEmpty()?this.#e+=1:this.#t.pop(),this}join(e){e=t.new(e);for(let r=0;r<e.#e;r++)this.parent();return this.#t.join(e.#t),this}extension(){return this.#t.extension()}toSubpath(){if(this.#e>0)throw new Error("Cannot convert to subpath.");return this.#t}toString(){let e="";for(let r=0;r<this.#e;r++)e+="../";return e+=this.#t.toString(),e}};(e=>{let t;(s=>(s.is=a=>M.Arg.is(a)||a instanceof e||a instanceof Array&&a.every(e.Arg.is),s.expect=a=>(o((0,s.is)(a)),a),s.assert=a=>{o((0,s.is)(a))}))(t=e.Arg||={})})(C||={});var M=class{#e;constructor(e){this.#e=e??[]}static new(...e){return C.new(...e).toSubpath()}components(){return[...this.#e]}isEmpty(){return this.#e.length==0}join(e){return this.#e.push(...e.#e),this}push(e){this.#e.push(e)}pop(){this.#e.pop()}extension(){return this.#e.at(-1)?.split(".").at(-1)}toRelpath(){return C.new(this)}toString(){return this.#e.join("/")}};(e=>{let t;(s=>(s.is=a=>a===void 0||typeof a=="string"||a instanceof e||a instanceof Array&&a.every(e.Arg.is),s.expect=a=>(o((0,s.is)(a)),a),s.assert=a=>{o((0,s.is)(a))}))(t=e.Arg||={})})(M||={});var b=(...t)=>f.new(...t),f=class t{#e;constructor(e){this.#e=e}static async new(...e){let{components:r}=await w(e,async n=>n===void 0?{}:typeof n=="string"||A.is(n)?{components:await p({kind:"array_append",values:[n]})}:t.is(n)?{components:await p({kind:"array_append",values:n.components})}:m());return r=(r??[]).reduce((n,i)=>{let s=n.at(-1);return i===""||(typeof s=="string"&&typeof i=="string"?n.splice(-1,1,s+i):n.push(i)),n},[]),new t(r)}static is(e){return e instanceof t}static expect(e){return o(t.is(e)),e}static assert(e){o(t.is(e))}static async join(e,...r){let n=await b(e),i=await Promise.all(r.map(a=>b(a)));i=i.filter(a=>a.components.length>0);let s=[];for(let a=0;a<i.length;a++){a>0&&s.push(n);let c=i[a];o(c),s.push(c)}return b(...s)}get components(){return this.#e}};var te=async(...t)=>await k.new(...t),k=class t{#e;constructor(e){this.#e=e}static withId(e){return new t(u.Handle.withId(e))}static async new(...e){let{artifact:r,path:n}=await w(e,async a=>{if(a===void 0)return{};if(typeof a=="string")return{path:await p({kind:"template_append",template:a})};if(A.is(a))return{artifact:a,path:await p({kind:"unset"})};if(f.is(a)){o(a.components.length<=2);let[c,l]=a.components;if(typeof c=="string"&&l===void 0)return{path:await p({kind:"template_append",template:c})};if(A.is(c)&&l===void 0)return{artifact:c,path:await p({kind:"unset"})};if(A.is(c)&&typeof l=="string")return o(l.startsWith("/")),{artifact:c,path:l.slice(1)};throw new Error("Invalid template.")}else return t.is(a)?{artifact:await a.artifact(),path:(await a.path()).toString()}:typeof a=="object"?a:m()}),i=$(n??""),s;if(r!==void 0&&!i.isEmpty())s=await b(r,"/",i.toString());else if(r!==void 0)s=await b(r);else if(!i.isEmpty())s=await b(i.toString());else throw new Error("Invalid symlink.");return new t(u.Handle.withObject({kind:"symlink",value:{target:s}}))}static is(e){return e instanceof t}static expect(e){return o(t.is(e)),e}static assert(e){o(t.is(e))}async id(){return await this.#e.id()}async object(){let e=await this.#e.object();return o(e.kind==="symlink"),e.value}get handle(){return this.#e}async target(){return(await this.object()).target}async artifact(){let r=(await this.target()).components.at(0);if(A.is(r))return r}async path(){let e=await this.target(),[r,n]=e.components;if(typeof r=="string"&&n===void 0)return $(r);if(A.is(r)&&n===void 0)return $();if(A.is(r)&&typeof n=="string")return $(n.slice(1));throw new Error("Invalid template.")}async resolve(e){e=e?await te(e):void 0;let r=await e?.artifact();t.is(r)&&(r=await r.resolve());let n=e?.path(),i=await this.artifact();t.is(i)&&(i=await i.resolve());let s=await this.path();if(i!==void 0&&s.isEmpty())return i;if(i===void 0&&!s.isEmpty()){if(!g.is(r))throw new Error("Expected a directory.");return await r.tryGet((await(n??$())).parent().join(s).toSubpath().toString())}else if(i!==void 0&&!s.isEmpty()){if(!g.is(i))throw new Error("Expected a directory.");return await i.tryGet(s.toSubpath().toString())}else throw new Error("Invalid symlink.")}};var R;(r=>(r.toUrl=n=>`tangram://${h.hex.encode(h.utf8.encode(h.json.encode(n)))}/${n.value.path}`,r.fromUrl=n=>{let i=n.match(/^tangram:\/\/([0-9a-f]+)/);o(i);let[s,a]=i;return o(a!==void 0),h.json.decode(h.utf8.decode(h.hex.decode(a)))}))(R||={});var Ae,re=()=>Ae,xe=t=>{Ae=t},X={};function ne(...t){if(t.length===1&&typeof t[0]=="object"&&"function"in t[0]){let e=t[0],{url:r,name:n}=e,i=N.encode({url:r,name:n});o(X[i]===void 0),X[i]=e.function;let s=R.fromUrl(e.url);o(s.kind==="normal");let a=T.withId(s.value.packageId);return new _(u.Handle.withObject({kind:"target",value:{host:"js-js",executable:new f([s.value.path]),package:a,name:e.name,args:[],env:{},checksum:void 0,unsafe:!1}}))}else return _.new(...t)}var ke=async(...t)=>await(await ne(...t)).build(),_=class t extends globalThis.Function{#e;constructor(e){super(),this.#e=e;let r=this;return new Proxy(r,{get(n,i,s){return typeof r[i]=="function"?r[i].bind(r):r[i]},apply:async(n,i,s)=>await(await t.new(r,{args:await O(s)})).build(),getPrototypeOf:n=>Object.getPrototypeOf(r)})}static withId(e){return new t(u.Handle.withId(e))}static async new(...e){let{host:r,executable:n,package:i,name:s,env:a,args:c,checksum:l,unsafe:d}=await w(e,async y=>{if(typeof y=="string"||A.is(y)||y instanceof f)return{host:(await re().env()).TANGRAM_HOST,executable:"/bin/sh",args:["-c",y]};if(t.is(y))return await y.object();if(typeof y=="object"){let F={};return"env"in y&&(F.env=y.env!==void 0?await p({kind:"array_append",values:[y.env]}):await p({kind:"unset"})),"args"in y&&(F.args=y.args!==void 0?await p({kind:"array_append",values:[...y.args]}):await p({kind:"unset"})),{...y,...F}}else return m()});if(!r)throw new Error("Cannot create a target without a host.");if(!n)throw new Error("Cannot create a target without an executable.");let L=await b(n),B=await w(H(a??[]),async y=>y);return c??=[],d??=!1,new t(u.Handle.withObject({kind:"target",value:{host:r,executable:L,package:i,name:s,env:B,args:c,checksum:l,unsafe:d}}))}static is(e){return e instanceof t}static expect(e){return o(t.is(e)),e}static assert(e){o(t.is(e))}async id(){return await this.#e.id()}async object(){let e=await this.#e.object();return o(e.kind==="target"),e.value}get handle(){return this.#e}async host(){return(await this.object()).host}async executable(){return(await this.object()).executable}async package(){return(await this.object()).package}async name_(){return(await this.object()).name}async env(){return(await this.object()).env}async args(){return(await this.object()).args}async checksum(){return(await this.object()).checksum}async unsafe(){return(await this.object()).unsafe}async build(...e){return await ue(await t.new(this,{args:e}))}};var O=async t=>{if(t=await t,t===void 0||typeof t=="boolean"||typeof t=="number"||typeof t=="string"||t instanceof Uint8Array||t instanceof x||t instanceof P||t instanceof g||t instanceof j||t instanceof k||t instanceof f||t instanceof v||t instanceof T||t instanceof _)return t;if(t instanceof Array)return await Promise.all(t.map(e=>O(e)));if(typeof t=="object")return Object.fromEntries(await Promise.all(Object.entries(t).map(async([e,r])=>[e,await O(r)])));throw new Error("Invalid value to resolve.")};async function p(t){return await v.new(t)}var w=async(t,e)=>H(await Promise.all(H(await Promise.all(t.map(O))).map(r=>e(r)))).reduce(async(r,n)=>{for(let[i,s]of Object.entries(n))await Ie(await r,i,s);return r},Promise.resolve({})),v=class t{#e;constructor(e){this.#e=e}static async new(e){let r=await O(e);return r.kind==="array_prepend"||r.kind==="array_append"?new t({kind:r.kind,value:H(r.values)}):r.kind==="template_prepend"||r.kind==="template_append"?new t({kind:r.kind,value:await b(r.template),separator:await b(r.separator)}):r.kind==="unset"?new t({kind:"unset"}):new t({kind:r.kind,value:r.value})}static is(e){return e instanceof t}static expect(e){return o(t.is(e)),e}static assert(e){o(t.is(e))}get inner(){return this.#e}},H=t=>t instanceof Array?t.flat(1/0):[t],Ie=async(t,e,r)=>{if(!(r instanceof v))t[e]=r;else if(r.inner.kind==="unset")delete t[e];else if(r.inner.kind==="set")t[e]=r.inner.value;else if(r.inner.kind==="set_if_unset")e in t||(t[e]=r.inner.value);else if(r.inner.kind==="array_prepend"){e in t||(t[e]=[]);let n=t[e];o(n instanceof Array),n.unshift(...H(r.inner.value))}else if(r.inner.kind==="array_append"){e in t||(t[e]=[]);let n=t[e];o(n instanceof Array),n.push(...H(r.inner.value))}else if(r.inner.kind==="template_prepend"){e in t||(t[e]=await b());let n=t[e];o(n===void 0||typeof n=="string"||A.is(n)||n instanceof f),t[e]=await f.join(r.inner.separator,r.inner.value,n)}else if(r.inner.kind==="template_append"){e in t||(t[e]=await b());let n=t[e];o(n===void 0||typeof n=="string"||A.is(n)||n instanceof f),t[e]=await f.join(r.inner.separator,n,r.inner.value)}};var je=async(...t)=>await P.new(...t),P=class t{#e;constructor(e){this.#e=e}static withId(e){return new t(u.Handle.withId(e))}static async new(...e){let{children:r}=await w(e,async n=>n===void 0?{}:t.is(n)?{children:await p({kind:"array_append",values:[{blob:n,size:await n.size()}]})}:typeof n=="object"?{children:await p({kind:"array_append",values:n.children??[]})}:m());return r??=[],new t(u.Handle.withObject({kind:"branch",value:{children:r}}))}static is(e){return e instanceof t}static expect(e){return o(t.is(e)),e}static assert(e){o(t.is(e))}async id(){return await this.#e.id()}async object(){let e=await this.#e.object();return o(e.kind==="branch"),e.value}get handle(){return this.#e}async children(){return(await this.object()).children}async size(){return(await this.children()).map(({size:e})=>e).reduce((e,r)=>e+r,0)}async bytes(){return await z(this)}async text(){return S.decode(await z(this))}async compress(e){return await K(this,e)}async decompress(e){return await G(this,e)}async extract(e){return await W(this,e)}};var Q=async(...t)=>await I.new(...t),Te=async(t,e)=>await I.download(t,e),I;(s=>(s.new_=async(...a)=>{let{children:c}=await w(a,async l=>{if(l===void 0)return{};if(typeof l=="string"){let d=new x(u.Handle.withObject({kind:"leaf",value:{bytes:S.encode(l)}}));return{children:await p({kind:"array_append",values:[d]})}}else if(l instanceof Uint8Array){let d=new x(u.Handle.withObject({kind:"leaf",value:{bytes:l}}));return{children:await p({kind:"array_append",values:[d]})}}else return s.is(l)?{children:await p({kind:"array_append",values:[l]})}:m()});if(!c||c.length===0)return new x(u.Handle.withObject({kind:"leaf",value:{bytes:new Uint8Array}}));if(c.length===1)return c[0];{let l=await Promise.all(c.map(async d=>({blob:d,size:await d.size()})));return new P(u.Handle.withObject({kind:"branch",value:{children:l}}))}},s.new=s.new_,s.is=a=>x.is(a)||P.is(a),s.expect=a=>(o((0,s.is)(a)),a),s.assert=a=>{o((0,s.is)(a))},s.download=async(a,c)=>await me(a,c)))(I||={});var Pe=async(...t)=>await g.new(...t),g=class t{#e;constructor(e){this.#e=e}static withId(e){return new t(u.Handle.withId(e))}static async new(...e){let r=await(await Promise.all(e.map(O))).reduce(async function n(i,s){let a=await i;if(s!==void 0)if(t.is(s))for(let[c,l]of Object.entries(await s.entries())){let d=a[c];t.is(d)&&t.is(l)&&(l=await t.new(d,l)),a[c]=l}else if(s instanceof Array)for(let c of s)a=await n(Promise.resolve(a),c);else if(typeof s=="object")for(let[c,l]of Object.entries(s)){let[d,...L]=E(c).components();if(d===void 0)throw new Error("The path must have at least one component.");let B=d,y=a[B];if(t.is(y)||(y=void 0),L.length>0){let F=E(L).toString(),Ue=await t.new(y,{[F]:l});a[B]=Ue}else if(l===void 0)delete a[B];else if(typeof l=="string"||l instanceof Uint8Array||I.is(l)){let F=await J(l);a[B]=F}else j.is(l)||k.is(l)?a[B]=l:a[B]=await t.new(y,l)}else return m();return a},Promise.resolve({}));return new t(u.Handle.withObject({kind:"directory",value:{entries:r}}))}static is(e){return e instanceof t}static expect(e){return o(t.is(e)),e}static assert(e){o(t.is(e))}async id(){return await this.#e.id()}async object(){let e=await this.#e.object();return o(e.kind==="directory"),e.value}get handle(){return this.#e}async get(e){let r=await this.tryGet(e);return o(r,`Failed to get the directory entry "${e}".`),r}async tryGet(e){let r=this,n=E();for(let i of E(e).components()){if(!t.is(r))return;n.push(i);let s=(await r.entries())[i];if(s===void 0)return;if(k.is(s)){let a=await s.resolve({artifact:this,path:n.toString()});if(a===void 0)return;r=a}else r=s}return r}async entries(){let e={};for await(let[r,n]of this)e[r]=n;return e}async bundle(){return await de(this)}async*walk(){for await(let[e,r]of this)if(yield[E(e),r],t.is(r))for await(let[n,i]of r.walk())yield[E(e).join(n),i]}async*[Symbol.asyncIterator](){let e=await this.object();for(let[r,n]of Object.entries(e.entries))yield[r,n]}};var A;(i=>(i.is=s=>g.is(s)||j.is(s)||k.is(s),i.expect=s=>(o((0,i.is)(s)),s),i.assert=s=>{o((0,i.is)(s))},i.archive=async(s,a)=>await pe(s,a)))(A||={});var Y=class{message;location;stack;source;constructor(e,r,n,i){this.message=e,this.location=r,this.stack=n,this.source=i}},_e=(t,e)=>({callSites:e.map(n=>({typeName:n.getTypeName(),functionName:n.getFunctionName(),methodName:n.getMethodName(),fileName:n.getFileName(),lineNumber:n.getLineNumber(),columnNumber:n.getColumnNumber(),isEval:n.isEval(),isNative:n.isNative(),isConstructor:n.isConstructor(),isAsync:n.isAsync(),isPromiseAll:n.isPromiseAll(),promiseIndex:n.getPromiseIndex()}))});var Oe=async t=>{let e=R.fromUrl(t.url);o(e.kind==="normal");let n=await T.withId(e.value.packageId).artifact();g.assert(n);let i=E(e.value.path).toRelpath().parent().join(t.path).toSubpath().toString();return await n.get(i)};var ae=(...t)=>{let e=t.map(r=>Ee(r)).join(" ")+`
`;ye(e)},Ee=t=>Z(t,new WeakSet),Z=(t,e)=>{switch(typeof t){case"string":return`"${t}"`;case"number":return t.toString();case"boolean":return t?"true":"false";case"undefined":return"undefined";case"object":return t===null?"null":ee(t,e);case"function":return _.is(t)?ee(t,e):`(function "${t.name??"(anonymous)"}")`;case"symbol":return"(symbol)";case"bigint":return t.toString()}},ee=(t,e)=>{if(e.has(t))return"(circular)";if(e.add(t),t instanceof Array)return`[${t.map(r=>Z(r,e)).join(", ")}]`;if(t instanceof Uint8Array)return`(tg.bytes ${q.encode(t)})`;if(t instanceof Error)return t.message;if(t instanceof Promise)return"(promise)";if(x.is(t))return D(t.handle,e);if(P.is(t))return D(t.handle,e);if(g.is(t))return D(t.handle,e);if(j.is(t))return D(t.handle,e);if(k.is(t))return D(t.handle,e);if(f.is(t))return`\`${t.components.map(r=>typeof r=="string"?r:`\${${Z(r,e)}}`).join("")}\``;if(v.is(t))return`(tg.mutation ${ee(t.inner,e)})`;if(T.is(t))return D(t.handle,e);if(_.is(t))return D(t.handle,e);{let r="";t.constructor!==void 0&&t.constructor.name!=="Object"&&(r+=`${t.constructor.name} `),r+="{";let n=Object.entries(t);return n.length>0&&(r+=" "),r+=n.map(([i,s])=>`${i}: ${Z(s,e)}`).join(", "),n.length>0&&(r+=" "),r+="}",r}},D=(t,e)=>{let{id:r,object:n}=t.state;return r!==void 0?r:n!==void 0?`(tg.${n.kind} ${ee(n.value,e)})`:m()};var ve=async t=>{let e=await t.package();o(e);let r=await e.id(),i=(await t.executable()).components[0];o(typeof i=="string");let s={kind:"normal",value:{packageId:r,path:i}},a=R.toUrl(s);await import(a);let c=await t.name_();if(!c)throw new Error("The target must have a name.");let l=N.encode({url:a,name:c}),d=X[l];if(!d)throw new Error("Failed to find the function.");xe(t);let L=await t.args();return await O(d(...L))};var Be=async t=>await fe(t);var ie=t=>{if(typeof t=="string")return t;{let{arch:e,os:r}=t;return`${e}-${r}`}},se;(a=>(a.new_=c=>ie(c),a.new=a.new_,a.is=c=>c==="aarch64-darwin"||c==="aarch64-linux"||c==="js-js"||c==="x86_64-darwin"||c==="x86_64-linux",a.expect=c=>(o(a.is(c)),c),a.assert=c=>{o(a.is(c))},a.arch=c=>{switch(c){case"aarch64-darwin":case"aarch64-linux":return"aarch64";case"js-js":return"js";case"x86_64-linux":case"x86_64-darwin":return"x86_64";default:throw new Error("Invalid system.")}},a.os=c=>{switch(c){case"aarch64-darwin":case"x86_64-darwin":return"darwin";case"js-js":return"js";case"x86_64-linux":case"aarch64-linux":return"linux";default:throw new Error("Invalid system.")}}))(se||={});var oe;(n=>(n.is=i=>i===void 0||typeof i=="boolean"||typeof i=="number"||typeof i=="string"||i instanceof Uint8Array||i instanceof x||i instanceof P||i instanceof g||i instanceof j||i instanceof k||i instanceof f||i instanceof T||i instanceof _||i instanceof Array||typeof i=="object",n.expect=i=>(o((0,n.is)(i)),i),n.assert=i=>{o((0,n.is)(i))}))(oe||={});Object.defineProperties(Error,{prepareStackTrace:{value:_e}});Object.defineProperties(globalThis,{console:{value:{log:ae}}});async function le(t,...e){let r=[];for(let n=0;n<t.length-1;n++){let i=t[n];r.push(i);let s=e[n];r.push(s)}return r.push(t[t.length-1]),await b(...r)}Object.assign(le,{Artifact:A,Blob:I,Branch:P,Directory:g,Error:Y,File:j,Leaf:x,Mutation:v,Object_:u,Package:T,Symlink:k,System:se,Target:_,Template:f,Value:oe,apply:w,assert:o,blob:Q,branch:je,build:ke,directory:Pe,download:Te,encoding:V,file:J,include:Oe,leaf:be,log:ae,main:ve,mutation:p,resolve:O,sleep:Be,symlink:te,system:ie,target:ne,template:b,unimplemented:ce,unreachable:m});Object.defineProperties(le,{current:{get:re}});Object.defineProperties(globalThis,{tg:{value:le}});})();
//# sourceMappingURL=runtime.js.map
