"use strict";(()=>{var Oe=Object.defineProperty;var Ie=(t,e)=>{for(var r in e)Oe(t,r,{get:e[r],enumerable:!0})};var o=(t,e)=>{if(!t)throw new Error(e??"Failed assertion.")},le=t=>{throw new Error(t??"Reached unimplemented code.")},d=t=>{throw new Error(t??"Reached unreachable code.")};var I={};Ie(I,{base64:()=>he,hex:()=>G,json:()=>R,toml:()=>we,utf8:()=>O,yaml:()=>ge});var ce=async(t,e)=>{try{return await syscall("archive",t,e)}catch(r){throw new Error("The syscall failed.",{cause:r})}},pe=async t=>{try{return await syscall("build",t)}catch(e){throw new Error("The syscall failed.",{cause:e})}},ue=async t=>{try{return await syscall("bundle",t)}catch(e){throw new Error("The syscall failed.",{cause:e})}},me=(t,e)=>{try{return syscall("checksum",t,e)}catch(r){throw new Error("The syscall failed.",{cause:r})}},$=async(t,e)=>{try{return await syscall("compress",t,e)}catch(r){throw new Error("The syscall failed.",{cause:r})}},K=async(t,e)=>{try{return await syscall("decompress",t,e)}catch(r){throw new Error("The syscall failed.",{cause:r})}},de=async(t,e)=>{try{return await syscall("download",t,e)}catch(r){throw new Error("The syscall failed.",{cause:r})}},h={base64:{decode:t=>{try{return syscall("encoding_base64_decode",t)}catch(e){throw new Error("The syscall failed.",{cause:e})}},encode:t=>{try{return syscall("encoding_base64_encode",t)}catch(e){throw new Error("The syscall failed.",{cause:e})}}},hex:{decode:t=>{try{return syscall("encoding_hex_decode",t)}catch(e){throw new Error("The syscall failed.",{cause:e})}},encode:t=>{try{return syscall("encoding_hex_encode",t)}catch(e){throw new Error("The syscall failed.",{cause:e})}}},json:{decode:t=>{try{return syscall("encoding_json_decode",t)}catch(e){throw new Error("The syscall failed.",{cause:e})}},encode:t=>{try{return syscall("encoding_json_encode",t)}catch(e){throw new Error("The syscall failed.",{cause:e})}}},toml:{decode:t=>{try{return syscall("encoding_toml_decode",t)}catch(e){throw new Error("The syscall failed.",{cause:e})}},encode:t=>{try{return syscall("encoding_toml_encode",t)}catch(e){throw new Error("The syscall failed.",{cause:e})}}},utf8:{decode:t=>{try{return syscall("encoding_utf8_decode",t)}catch(e){throw new Error("The syscall failed.",{cause:e})}},encode:t=>{try{return syscall("encoding_utf8_encode",t)}catch(e){throw new Error("The syscall failed.",{cause:e})}}},yaml:{decode:t=>{try{return syscall("encoding_yaml_decode",t)}catch(e){throw new Error("The syscall failed.",{cause:e})}},encode:t=>{try{return syscall("encoding_yaml_encode",t)}catch(e){throw new Error("The syscall failed.",{cause:e})}}}},W=async(t,e)=>{try{return await syscall("extract",t,e)}catch(r){throw new Error("The syscall failed.",{cause:r})}},ye=t=>{try{return syscall("log",t)}catch(e){throw new Error("The syscall failed.",{cause:e})}},k=async t=>{try{return await syscall("load",t)}catch(e){throw new Error("The syscall failed.",{cause:e})}},D=async t=>{try{return await syscall("read",t)}catch(e){throw new Error("The syscall failed.",{cause:e})}},T=async t=>{try{return await syscall("store",t)}catch(e){throw new Error("The syscall failed.",{cause:e})}},fe=async t=>{try{return await syscall("sleep",t)}catch(e){throw new Error("The syscall failed.",{cause:e})}};var he;(r=>(r.decode=n=>h.base64.decode(n),r.encode=n=>h.base64.encode(n)))(he||={});var G;(r=>(r.decode=n=>h.hex.decode(n),r.encode=n=>h.hex.encode(n)))(G||={});var R;(r=>(r.decode=n=>h.json.decode(n),r.encode=n=>h.json.encode(n)))(R||={});var we;(r=>(r.decode=n=>h.toml.decode(n),r.encode=n=>h.toml.encode(n)))(we||={});var O;(r=>(r.decode=n=>h.utf8.decode(n),r.encode=n=>h.utf8.encode(n)))(O||={});var ge;(r=>(r.decode=n=>h.yaml.decode(n),r.encode=n=>h.yaml.encode(n)))(ge||={});var H=async(...t)=>await A.new(...t),A=class t{#e;constructor(e){this.#e=e}get state(){return this.#e}static withId(e){return new t({id:e})}static async new(...e){let{contents:r,executable:n,references:a}=await g.apply(e,async c=>{if(c===void 0)return{};if(typeof c=="string"||c instanceof Uint8Array||E.is(c))return{contents:await p({kind:"array_append",values:[c]})};if(t.is(c))return{contents:await p({kind:"array_append",values:[await c.contents()]}),executable:await p({kind:"array_append",values:[await c.executable()]}),references:await p({kind:"array_append",values:[await c.references()]})};if(typeof c=="object"){let m={};return c.contents!==void 0&&(m.contents=await p({kind:"array_append",values:[c.contents]})),c.executable!==void 0&&(m.executable=await p({kind:"array_append",values:[c.executable]})),c.references!==void 0&&(m.references=await p({kind:"array_append",values:[c.references]})),m}else return d()}),s=await q(r),i=(n??[]).some(c=>c),l=a??[];return new t({object:{contents:s,executable:i,references:l}})}static is(e){return e instanceof t}static expect(e){return o(t.is(e)),e}static assert(e){o(t.is(e))}async id(){return await this.store(),this.#e.id}async object(){return await this.load(),this.#e.object}async load(){if(this.#e.object===void 0){let e=await k(this.#e.id);o(e.kind==="file"),this.#e.object=e.value}}async store(){this.#e.id===void 0&&(this.#e.id=await T({kind:"file",value:this.#e.object}))}async contents(){return(await this.object()).contents}async executable(){return(await this.object()).executable}async references(){return(await this.object()).references}async size(){return(await this.contents()).size()}async bytes(){return(await this.contents()).bytes()}async text(){return(await this.contents()).text()}};var be=async(...t)=>await x.new(...t),x=class t{#e;constructor(e){this.#e=e}get state(){return this.#e}static withId(e){return new t({id:e})}static async new(...e){let{bytes:r}=await g.apply(e,async i=>i===void 0?{}:typeof i=="string"?{bytes:await p({kind:"array_append",values:[O.encode(i)]})}:i instanceof Uint8Array?{bytes:await p({kind:"array_append",values:[i]})}:t.is(i)?{bytes:await p({kind:"array_append",values:[await i.bytes()]})}:typeof i=="object"?{bytes:await p({kind:"array_append",values:[i.bytes??new Uint8Array]})}:d());r??=[];let n=r.reduce((i,l)=>i+l.byteLength,0),a=new Uint8Array(n),s=0;for(let i of r)a.set(i,s),s+=i.byteLength;return new t({object:{bytes:a}})}static is(e){return e instanceof t}static expect(e){return o(t.is(e)),e}static assert(e){o(t.is(e))}async id(){return await this.store(),this.#e.id}async object(){return await this.load(),this.#e.object}async load(){if(this.#e.object===void 0){let e=await k(this.#e.id);o(e.kind==="leaf"),this.#e.object=e.value}}async store(){this.#e.id===void 0&&(this.#e.id=await T({kind:"leaf",value:this.#e.object}))}async size(){return(await this.object()).bytes.byteLength}async bytes(){return(await this.object()).bytes}async text(){return O.decode(await D(this))}async compress(e){return await $(this,e)}async decompress(e){return await K(this,e)}async extract(e){return await W(this,e)}};var V=class t{#e;constructor(e){this.#e=e}get state(){return this.#e}static withId(e){return new t({id:e})}static is(e){return e instanceof t}static expect(e){return o(t.is(e)),e}static assert(e){o(t.is(e))}async id(){return await this.store(),this.#e.id}async object(){return await this.load(),this.#e.object}async load(){if(this.#e.object===void 0){let e=await k(this.#e.id);o(e.kind==="lock"),this.#e.object=e.value}}async store(){this.#e.id===void 0&&(this.#e.id=await T({kind:"lock",value:this.#e.object}))}async dependencies(){return(await this.object()).dependencies}};var b=class t{#e;static new(...e){return e.reduce(function r(n,a){if(a===void 0)return n;if(typeof a=="string"){a.startsWith("/")&&(n.push(t.Component.Root),a=a.slice(1));for(let s of a.split("/"))s!==""&&(s==="."?n.push("."):s===".."?n.push(".."):n.push(s));return n}else{if(a instanceof t)return n.join(a);if(a instanceof Array){for(let s of a)n=r(n,s);return n}else return t.Component.isRoot(a)?(n.push(t.Component.Root),n):d()}},new t([]))}constructor(e){this.#e=e}isEmpty(){return this.#e.length===0}components(){return this.#e}push(e){e==="."&&!this.isEmpty()||(t.Component.isRoot(e)&&(this.#e.length=0),this.#e.push(e))}parent(){return this.join("..")}join(e){let r=new t(this.components());for(let n of t.new(e).components())r.push(n);return r}normalize(){let e=new t([]);for(let r of this.#e){let n=e.#e.at(-1);r===".."&&n!==void 0&&t.Component.isNormal(n)?e.#e.pop():e.push(r)}return e}toString(){let e="";for(let r=0;r<this.#e.length;r++){let n=this.#e[r];t.Component.isRoot(n)?e+="/":n==="."?(r!==0&&(e+="/"),e+="."):n===".."?(r!==0&&(e+="/"),e+=".."):(r!==0&&(e+="/"),e+=n)}return e}isAbsolute(){let e=this.#e.at(0);return e===void 0?!1:t.Component.isRoot(e)}extension(){let e=this.#e.at(-1);if(e!==void 0&&t.Component.isNormal(e)){let r=e.split(".");if(r.length>1)return r.at(-1)}}};(e=>{let t;(l=>(l.Root={kind:"root"},l.Parent="..",l.Current=".",l.isRoot=c=>typeof c=="object"&&c.kind==="root",l.isNormal=c=>typeof c=="string"&&c!=="."&&c!==".."))(t=e.Component||={})})(b||={});var B=(...t)=>w.new(...t),w=class t{#e;constructor(e){this.#e=e}static async new(...e){let{components:r}=await g.apply(e,async n=>n===void 0?{}:typeof n=="string"||j.is(n)?{components:await p({kind:"array_append",values:[n]})}:t.is(n)?{components:await p({kind:"array_append",values:n.components})}:d());return r=(r??[]).reduce((n,a)=>{let s=n.at(-1);return a===""||(typeof s=="string"&&typeof a=="string"?n.splice(-1,1,s+a):n.push(a)),n},[]),new t(r)}static is(e){return e instanceof t}static expect(e){return o(t.is(e)),e}static assert(e){o(t.is(e))}static async join(e,...r){let n=await B(e),a=await Promise.all(r.map(i=>B(i)));a=a.filter(i=>i.components.length>0);let s=[];for(let i=0;i<a.length;i++){i>0&&s.push(n);let l=a[i];o(l),s.push(l)}return B(...s)}get components(){return this.#e}};var z=async(...t)=>await y.new(...t),y=class t{#e;constructor(e){this.#e=e}get state(){return this.#e}static withId(e){return new t({id:e})}static async new(...e){let{artifact:r,path:n}=await g.apply(e,async s=>{if(s===void 0)return{};if(typeof s=="string")return{path:await p({kind:"array_append",values:[s]})};if(j.is(s))return{artifact:s,path:await p({kind:"unset"})};if(w.is(s)){o(s.components.length<=2);let[i,l]=s.components;if(typeof i=="string"&&l===void 0)return{path:await p({kind:"array_append",values:[i]})};if(j.is(i)&&l===void 0)return{artifact:i,path:await p({kind:"unset"})};if(j.is(i)&&typeof l=="string")return o(l.startsWith("/")),{artifact:i,path:[l.slice(1)]};throw new Error("Invalid template.")}else if(t.is(s)){let i=await s.path();return{artifact:await s.artifact(),path:i!==void 0?[i.toString()]:[]}}else if(typeof s=="object"){let i={};return s.artifact!==void 0&&(i.artifact=s.artifact),s.path!==void 0&&(i.path=await p({kind:"set",value:[s.path]})),i}else return d()}),a=n!==void 0?b.new(n).toString():void 0;return new t({object:{artifact:r,path:a}})}static is(e){return e instanceof t}static expect(e){return o(t.is(e)),e}static assert(e){o(t.is(e))}async id(){return await this.store(),this.#e.id}async object(){return await this.load(),this.#e.object}async load(){if(this.#e.object===void 0){let e=await k(this.#e.id);o(e.kind==="symlink"),this.#e.object=e.value}}async store(){this.#e.id===void 0&&(this.#e.id=await T({kind:"symlink",value:this.#e.object}))}async artifact(){return(await this.object()).artifact}async path(){return(await this.object()).path}async resolve(e){e=e?await z(e):void 0;let r=await e?.artifact();t.is(r)&&(r=await r.resolve());let n=await e?.path(),a=await this.artifact();t.is(a)&&(a=await a.resolve());let s=await this.path();if(a!==void 0&&!s)return a;if(a===void 0&&s){if(!f.is(r))throw new Error("Expected a directory.");return await r.tryGet(b.new(n).join("..").join(s).normalize().toString())}else if(a!==void 0&&s){if(!f.is(a))throw new Error("Expected a directory.");return await a.tryGet(s)}else throw new Error("Invalid symlink.")}};var L;(r=>(r.toUrl=n=>`tangram://${h.hex.encode(h.utf8.encode(h.json.encode(n)))}/${n.value.path}`,r.fromUrl=n=>{let a=n.match(/^tangram:\/\/([0-9a-f]+)/);o(a);let[s,i]=a;return o(i!==void 0),h.json.decode(h.utf8.decode(h.hex.decode(i)))}))(L||={});var C=t=>t instanceof Array?t.flat(1/0):[t];var Ae,xe={},J=()=>Ae,ke=t=>{Ae=t},Ee=()=>xe,Te=t=>{xe=t},Q={};function re(...t){if(t.length===1&&typeof t[0]=="object"&&"function"in t[0]){let e=t[0],{url:r,name:n}=e,a=R.encode({url:r,name:n});o(Q[a]===void 0),Q[a]=e.function;let s=L.fromUrl(e.url);o(s.kind==="normal");let i=V.withId(s.value.lock),l=new y({object:{artifact:f.withId(s.value.package),path:s.value.path}});return new _({object:{host:"js-js",executable:l,lock:i,name:e.name,args:[],env:Ee(),checksum:void 0}})}else return _.new(...t)}var je=async(...t)=>await(await re(...t)).build(),_=class t extends globalThis.Function{#e;constructor(e){super(),this.#e=e;let r=this;return new Proxy(r,{get(n,a,s){return typeof r[a]=="function"?r[a].bind(r):r[a]},apply:async(n,a,s)=>await n.build(...s),getPrototypeOf:n=>Object.getPrototypeOf(r)})}get state(){return this.#e}static withId(e){return new t({id:e})}static async new(...e){let{host:r,executable:n,lock:a,name:s,env:i,args:l,checksum:c}=await g.apply([{env:await J().env()},...e],async u=>{if(typeof u=="string"||j.is(u)||u instanceof w)return{host:(await J().env()).TANGRAM_HOST,executable:await z("/bin/sh"),args:["-c",u]};if(t.is(u))return await u.object();if(typeof u=="object"){let S={};return u.env!==void 0&&(S.env=await p({kind:"array_append",values:C([u.env])})),u.args!==void 0&&(S.args=await p({kind:"array_append",values:[...u.args]})),{...u,...S}}else return d()});if(!r)throw new Error("Cannot create a target without a host.");if(!n)throw new Error("Cannot create a target without an executable.");let m=await g.apply(C(i??[]),async u=>u);return l??=[],new t({object:{host:r,executable:n,lock:a,name:s,env:m,args:l,checksum:c}})}static is(e){return e instanceof t}static expect(e){return o(t.is(e)),e}static assert(e){o(t.is(e))}async id(){return await this.store(),this.#e.id}async object(){return await this.load(),this.#e.object}async load(){if(this.#e.object===void 0){let e=await k(this.#e.id);o(e.kind==="target"),this.#e.object=e.value}}async store(){this.#e.id===void 0&&(this.#e.id=await T({kind:"target",value:this.#e.object}))}async host(){return(await this.object()).host}async executable(){return(await this.object()).executable}async lock(){return(await this.object()).lock}async name_(){return(await this.object()).name}async env(){return(await this.object()).env}async args(){return(await this.object()).args}async checksum(){return(await this.object()).checksum}async build(...e){return await pe(await t.new(this,{args:e}))}};var M=async t=>{if(t=await t,t===void 0||typeof t=="boolean"||typeof t=="number"||typeof t=="string"||t instanceof Uint8Array||t instanceof x||t instanceof P||t instanceof f||t instanceof A||t instanceof y||t instanceof w||t instanceof v||t instanceof V||t instanceof _)return t;if(t instanceof Array)return await Promise.all(t.map(e=>M(e)));if(typeof t=="object")return Object.fromEntries(await Promise.all(Object.entries(t).map(async([e,r])=>[e,await M(r)])));throw new Error("Invalid value to resolve.")};async function p(t){return await v.new(t)}var v=class t{#e;constructor(e){this.#e=e}static async new(e){let r=await M(e);return r.kind==="array_prepend"||r.kind==="array_append"?new t({kind:r.kind,values:C(r.values)}):r.kind==="template_prepend"||r.kind==="template_append"?new t({kind:r.kind,template:await B(r.template),separator:r.separator}):r.kind==="unset"?new t({kind:"unset"}):new t({kind:r.kind,value:r.value})}static set(e){return t.new({kind:"set",value:e})}static unset(){return new t({kind:"unset"})}static setIfUnset(e){return t.new({kind:"set_if_unset",value:e})}static arrayPrepend(e){return t.new({kind:"array_prepend",values:e})}static arrayAppend(e){return t.new({kind:"array_append",values:e})}static templatePrepend(e,r){return t.new({kind:"template_prepend",template:e,separator:r})}static templateAppend(e,r){return t.new({kind:"template_append",template:e,separator:r})}static is(e){return e instanceof t}static expect(e){return o(t.is(e)),e}static assert(e){o(t.is(e))}get inner(){return this.#e}};var Pe=async(...t)=>await P.new(...t),P=class t{#e;constructor(e){this.#e=e}get state(){return this.#e}static withId(e){return new t({id:e})}static async new(...e){let{children:r}=await g.apply(e,async n=>n===void 0?{}:t.is(n)?{children:await p({kind:"array_append",values:[{blob:n,size:await n.size()}]})}:typeof n=="object"?{children:await p({kind:"array_append",values:n.children??[]})}:d());return r??=[],new t({object:{children:r}})}static is(e){return e instanceof t}static expect(e){return o(t.is(e)),e}static assert(e){o(t.is(e))}async id(){return await this.store(),this.#e.id}async object(){return await this.load(),this.#e.object}async load(){if(this.#e.object===void 0){let e=await k(this.#e.id);o(e.kind==="branch"),this.#e.object=e.value}}async store(){this.#e.id===void 0&&(this.#e.id=await T({kind:"branch",value:this.#e.object}))}async children(){return(await this.object()).children}async size(){return(await this.children()).map(({size:e})=>e).reduce((e,r)=>e+r,0)}async bytes(){return await D(this)}async text(){return O.decode(await D(this))}async compress(e){return await $(this,e)}async decompress(e){return await K(this,e)}async extract(e){return await W(this,e)}};var q=async(...t)=>await E.new(...t),_e=async(t,e)=>await E.download(t,e),E;(i=>(i.new_=async(...l)=>{let{children:c}=await g.apply(l,async m=>{if(m===void 0)return{};if(typeof m=="string"){let u=new x({object:{bytes:O.encode(m)}});return{children:await p({kind:"array_append",values:[u]})}}else if(m instanceof Uint8Array){let u=new x({object:{bytes:m}});return{children:await p({kind:"array_append",values:[u]})}}else return i.is(m)?{children:await p({kind:"array_append",values:[m]})}:d()});if(!c||c.length===0)return new x({object:{bytes:new Uint8Array}});if(c.length===1)return c[0];{let m=await Promise.all(c.map(async u=>({blob:u,size:await u.size()})));return new P({object:{children:m}})}},i.new=i.new_,i.is=l=>x.is(l)||P.is(l),i.expect=l=>(o((0,i.is)(l)),l),i.assert=l=>{o((0,i.is)(l))},i.download=async(l,c)=>await de(l,c),i.archive=async(l,c)=>await ce(l,c)))(E||={});var ve=async(...t)=>await f.new(...t),f=class t{#e;constructor(e){this.#e=e}get state(){return this.#e}static withId(e){return new t({id:e})}static async new(...e){let r=await(await Promise.all(e.map(M))).reduce(async function n(a,s){let i=await a;if(s!==void 0)if(t.is(s))for(let[l,c]of Object.entries(await s.entries())){let m=i[l];t.is(m)&&t.is(c)&&(c=await t.new(m,c)),i[l]=c}else if(s instanceof Array)for(let l of s)i=await n(Promise.resolve(i),l);else if(typeof s=="object")for(let[l,c]of Object.entries(s)){let[m,...u]=b.new(l).components();if(m===void 0)throw new Error("The path must have at least one component.");if(!b.Component.isNormal(m))throw new Error("All path components must be normal.");let S=m,N=i[S];if(t.is(N)||(N=void 0),u.length>0){let te=b.new(u).toString(),Ce=await t.new(N,{[te]:c});i[S]=Ce}else if(c===void 0)delete i[S];else if(typeof c=="string"||c instanceof Uint8Array||E.is(c)){let te=await H(c);i[S]=te}else A.is(c)||y.is(c)?i[S]=c:i[S]=await t.new(N,c)}else return d();return i},Promise.resolve({}));return new t({object:{entries:r}})}static is(e){return e instanceof t}static expect(e){return o(t.is(e)),e}static assert(e){o(t.is(e))}async id(){return await this.store(),this.#e.id}async object(){return await this.load(),this.#e.object}async load(){if(this.#e.object===void 0){let e=await k(this.#e.id);o(e.kind==="directory"),this.#e.object=e.value}}async store(){this.#e.id===void 0&&(this.#e.id=await T({kind:"directory",value:this.#e.object}))}async get(e){let r=await this.tryGet(e);return o(r,`Failed to get the directory entry "${e}".`),r}async tryGet(e){let r=this,n=b.new();for(let a of b.new(e).components()){if(!b.Component.isNormal(a))throw new Error("All path components must be normal.");if(!t.is(r))return;n.push(a);let s=(await r.entries())[a];if(s===void 0)return;if(y.is(s)){let i=await s.resolve({artifact:this,path:n.toString()});if(i===void 0)return;r=i}else r=s}return r}async entries(){let e={};for await(let[r,n]of this)e[r]=n;return e}async bundle(){return await ue(this)}async*walk(){for await(let[e,r]of this)if(yield[b.new(e),r],t.is(r))for await(let[n,a]of r.walk())yield[b.new(e).join(n),a]}async*[Symbol.asyncIterator](){let e=await this.object();for(let[r,n]of Object.entries(e.entries))yield[r,n]}};var j;(a=>(a.withId=s=>{let i=s.substring(0,3);if(i==="dir")return f.withId(s);if(i==="fil")return A.withId(s);if(i==="sym")return y.withId(s);throw new Error(`invalid artifact id: ${s}`)},a.is=s=>f.is(s)||A.is(s)||y.is(s),a.expect=s=>(o((0,a.is)(s)),s),a.assert=s=>{o((0,a.is)(s))}))(j||={});var g;(e=>e.apply=async(r,n)=>C(await Promise.all(C(await Promise.all(r.map(M))).map(a=>n(a)))).reduce(async(a,s)=>{for(let[i,l]of Object.entries(s))await Le(await a,i,l);return a},Promise.resolve({})))(g||={});var Le=async(t,e,r)=>{if(!(r instanceof v))t[e]=r;else if(r.inner.kind==="unset")delete t[e];else if(r.inner.kind==="set")t[e]=r.inner.value;else if(r.inner.kind==="set_if_unset")e in t||(t[e]=r.inner.value);else if(r.inner.kind==="array_prepend"){(!(e in t)||t[e]===void 0)&&(t[e]=[]);let n=t[e];o(n instanceof Array),t[e]=[...C(r.inner.values),...n]}else if(r.inner.kind==="array_append"){(!(e in t)||t[e]===void 0)&&(t[e]=[]);let n=t[e];o(n instanceof Array),t[e]=[...n,...C(r.inner.values)]}else if(r.inner.kind==="template_prepend"){e in t||(t[e]=await B());let n=t[e];o(n===void 0||typeof n=="string"||j.is(n)||n instanceof w),t[e]=await w.join(r.inner.separator,r.inner.template,n)}else if(r.inner.kind==="template_append"){e in t||(t[e]=await B());let n=t[e];o(n===void 0||typeof n=="string"||j.is(n)||n instanceof w),t[e]=await w.join(r.inner.separator,n,r.inner.template)}};var Se=(t,e)=>X.new(t,e),X;(e=>(e.new_=(r,n)=>me(r,n),e.new=e.new_))(X||={});var Y=class{message;location;stack;source;constructor(e,r,n,a){this.message=e,this.location=r,this.stack=n,this.source=a}},Ue=(t,e)=>({callSites:e.map(n=>({typeName:n.getTypeName(),functionName:n.getFunctionName(),methodName:n.getMethodName(),fileName:n.getFileName(),lineNumber:n.getLineNumber(),columnNumber:n.getColumnNumber(),isEval:n.isEval(),isNative:n.isNative(),isConstructor:n.isConstructor(),isAsync:n.isAsync(),isPromiseAll:n.isPromiseAll(),promiseIndex:n.getPromiseIndex()}))});var Ve=async t=>{let e=L.fromUrl(t.url);o(e.kind==="normal");let r=f.withId(e.value.package),n=b.new(e.value.path).join("..").join(t.path).normalize().toString();return await r.get(n)};var ne=(...t)=>{let e=t.map(r=>Fe(r)).join(" ")+`
`;ye(e)},Fe=t=>Z(t,new WeakSet),Z=(t,e)=>{switch(typeof t){case"string":return`"${t}"`;case"number":return t.toString();case"boolean":return t?"true":"false";case"undefined":return"undefined";case"object":return t===null?"null":ee(t,e);case"function":return _.is(t)?ee(t,e):`(function "${t.name??"(anonymous)"}")`;case"symbol":return"(symbol)";case"bigint":return t.toString()}},ee=(t,e)=>{if(e.has(t))return"(circular)";if(e.add(t),t instanceof Array)return`[${t.map(r=>Z(r,e)).join(", ")}]`;if(t instanceof Uint8Array)return`(tg.bytes ${G.encode(t)})`;if(t instanceof Error)return t.message;if(t instanceof Promise)return"(promise)";if(x.is(t))return F("leaf",t.state,e);if(P.is(t))return F("branch",t.state,e);if(f.is(t))return F("directory",t.state,e);if(A.is(t))return F("file",t.state,e);if(y.is(t))return F("symlink",t.state,e);if(V.is(t))return F("lock",t.state,e);if(_.is(t))return F("target",t.state,e);if(v.is(t))return`(tg.mutation ${ee(t.inner,e)})`;if(w.is(t))return`\`${t.components.map(r=>typeof r=="string"?r:`\${${Z(r,e)}}`).join("")}\``;{let r="";t.constructor!==void 0&&t.constructor.name!=="Object"&&(r+=`${t.constructor.name} `),r+="{";let n=Object.entries(t);return n.length>0&&(r+=" "),r+=n.map(([a,s])=>`"${a}": ${Z(s,e)}`).join(", "),n.length>0&&(r+=" "),r+="}",r}},F=(t,e,r)=>{let{id:n,object:a}=e;return n!==void 0?n:a!==void 0?`(tg.${t} ${ee(a,r)})`:d()};var Me=async t=>await fe(t);var Be=async t=>{ke(t),Te(await t.env());let e=await t.lock();o(e);let r=await e.id(),n=await t.executable();y.assert(n);let a=await n.artifact();o(a);let s=await a.id(),i=await n.path();o(i);let l=L.toUrl({kind:"normal",value:{lock:r,package:s,path:i.toString()}});await import(l);let c=await t.name_();if(!c)throw new Error("The target must have a name.");let m=R.encode({url:l,name:c}),u=Q[m];if(!u)throw new Error("Failed to find the function.");let S=await t.args();return await M(u(...S))};var ae=t=>{if(typeof t=="string")return t;{let{arch:e,os:r}=t;return`${e}-${r}`}},ie;(i=>(i.new_=l=>ae(l),i.new=i.new_,i.is=l=>l==="aarch64-darwin"||l==="aarch64-linux"||l==="js-js"||l==="x86_64-darwin"||l==="x86_64-linux",i.expect=l=>(o(i.is(l)),l),i.assert=l=>{o(i.is(l))},i.arch=l=>{switch(l){case"aarch64-darwin":case"aarch64-linux":return"aarch64";case"js-js":return"js";case"x86_64-linux":case"x86_64-darwin":return"x86_64";default:throw new Error("Invalid system.")}},i.os=l=>{switch(l){case"aarch64-darwin":case"x86_64-darwin":return"darwin";case"js-js":return"js";case"x86_64-linux":case"aarch64-linux":return"linux";default:throw new Error("Invalid system.")}}))(ie||={});var se;(n=>(n.is=a=>a===void 0||typeof a=="boolean"||typeof a=="number"||typeof a=="string"||a instanceof Uint8Array||a instanceof x||a instanceof P||a instanceof f||a instanceof A||a instanceof y||a instanceof V||a instanceof _||a instanceof v||a instanceof w||a instanceof Array||typeof a=="object",n.expect=a=>(o((0,n.is)(a)),a),n.assert=a=>{o((0,n.is)(a))}))(se||={});Object.defineProperties(Error,{prepareStackTrace:{value:Ue}});Object.defineProperties(globalThis,{console:{value:{log:ne}}});async function oe(t,...e){let r=[];for(let n=0;n<t.length-1;n++){let a=t[n];r.push(a);let s=e[n];r.push(s)}return r.push(t[t.length-1]),await B(...r)}Object.assign(oe,{Args:g,Artifact:j,Blob:E,Branch:P,Checksum:X,Directory:f,Error:Y,File:A,Leaf:x,Lock:V,Mutation:v,Symlink:y,System:ie,Target:_,Template:w,Value:se,assert:o,blob:q,branch:Pe,build:je,checksum:Se,directory:ve,download:_e,encoding:I,file:H,include:Ve,leaf:be,log:ne,mutation:p,resolve:M,sleep:Me,start:Be,symlink:z,system:ae,target:re,template:B,unimplemented:le,unreachable:d});Object.defineProperties(oe,{current:{get:J}});Object.defineProperties(globalThis,{tg:{value:oe}});})();
//# sourceMappingURL=main.js.map
