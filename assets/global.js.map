{
  "version": 3,
  "sources": ["../src/global/assert.ts", "../src/global/encoding.ts", "../src/global/syscall.ts", "../src/global/util.ts", "../src/global/file.ts", "../src/global/path.ts", "../src/global/placeholder.ts", "../src/global/env.ts", "../src/global/template.ts", "../src/global/symlink.ts", "../src/global/task.ts", "../src/global/value.ts", "../src/global/target.ts", "../src/global/operation.ts", "../src/global/resource.ts", "../src/global/resolve.ts", "../src/global/block.ts", "../src/global/blob.ts", "../src/global/directory.ts", "../src/global/artifact.ts", "../src/global/error.ts", "../src/global/include.ts", "../src/global/log.ts", "../src/global/system.ts", "../src/global/main.ts"],
  "sourcesContent": ["export let assert: (\n\tcondition: unknown,\n\tmessage?: string,\n) => asserts condition = (condition, message) => {\n\tif (!condition) {\n\t\tthrow new Error(message ?? \"Failed assertion.\");\n\t}\n};\n\nexport let unimplemented = (message?: string): never => {\n\tthrow new Error(message ?? \"Reached unimplemented code.\");\n};\n\nexport let unreachable = (message?: string): never => {\n\tthrow new Error(message ?? \"Reached unreachable code.\");\n};\n", "import * as syscall from \"./syscall.ts\";\n\nexport namespace base64 {\n\texport let decode = (value: string): Uint8Array => {\n\t\treturn syscall.encoding.base64.decode(value);\n\t};\n\n\texport let encode = (value: Uint8Array): string => {\n\t\treturn syscall.encoding.base64.encode(value);\n\t};\n}\n\nexport namespace hex {\n\texport let decode = (value: string): Uint8Array => {\n\t\treturn syscall.encoding.hex.decode(value);\n\t};\n\n\texport let encode = (value: Uint8Array): string => {\n\t\treturn syscall.encoding.hex.encode(value);\n\t};\n}\n\nexport namespace json {\n\texport let decode = (value: string): unknown => {\n\t\treturn syscall.encoding.json.decode(value);\n\t};\n\n\texport let encode = (value: any): string => {\n\t\treturn syscall.encoding.json.encode(value);\n\t};\n}\n\nexport namespace toml {\n\texport let decode = (value: string): unknown => {\n\t\treturn syscall.encoding.toml.decode(value);\n\t};\n\n\texport let encode = (value: any): string => {\n\t\treturn syscall.encoding.toml.encode(value);\n\t};\n}\n\nexport namespace utf8 {\n\texport let decode = (value: Uint8Array): string => {\n\t\treturn syscall.encoding.utf8.decode(value);\n\t};\n\n\texport let encode = (value: string): Uint8Array => {\n\t\treturn syscall.encoding.utf8.encode(value);\n\t};\n}\n\nexport namespace yaml {\n\texport let decode = (value: string): unknown => {\n\t\treturn syscall.encoding.yaml.decode(value);\n\t};\n\n\texport let encode = (value: any): string => {\n\t\treturn syscall.encoding.yaml.encode(value);\n\t};\n}\n", "declare global {\n\tfunction syscall(\n\t\tsyscall: \"artifact_bundle\",\n\t\tartifact: Artifact,\n\t): Promise<Artifact>;\n\n\tfunction syscall(syscall: \"artifact_get\", block: Block): Promise<Artifact>;\n\n\tfunction syscall(syscall: \"blob_bytes\", blob: Blob): Promise<Uint8Array>;\n\n\tfunction syscall(syscall: \"blob_get\", block: Block): Promise<Blob>;\n\n\tfunction syscall(syscall: \"blob_new\", arg: Blob.Arg): Promise<Blob>;\n\n\tfunction syscall(syscall: \"blob_text\", blob: Blob): Promise<string>;\n\n\tfunction syscall(syscall: \"block_bytes\", block: Block): Promise<Uint8Array>;\n\n\tfunction syscall(\n\t\tsyscall: \"block_children\",\n\t\tblock: Block,\n\t): Promise<Array<Block>>;\n\n\tfunction syscall(syscall: \"block_data\", block: Block): Promise<Uint8Array>;\n\n\tfunction syscall(syscall: \"block_new\", arg: Block.Arg): Block;\n\n\tfunction syscall(\n\t\tsyscall: \"checksum\",\n\t\talgorithm: ChecksumAlgorithm,\n\t\tbytes: string | Uint8Array,\n\t): Checksum;\n\n\tfunction syscall(syscall: \"directory_new\", arg: Directory.Arg): Directory;\n\n\tfunction syscall(\n\t\tsyscall: \"encoding_base64_decode\",\n\t\tvalue: string,\n\t): Uint8Array;\n\n\tfunction syscall(\n\t\tsyscall: \"encoding_base64_encode\",\n\t\tvalue: Uint8Array,\n\t): string;\n\n\tfunction syscall(syscall: \"encoding_hex_decode\", value: string): Uint8Array;\n\n\tfunction syscall(syscall: \"encoding_hex_encode\", value: Uint8Array): string;\n\n\tfunction syscall(syscall: \"encoding_json_decode\", value: string): unknown;\n\n\tfunction syscall(syscall: \"encoding_json_encode\", value: any): string;\n\n\tfunction syscall(syscall: \"encoding_toml_decode\", value: string): unknown;\n\n\tfunction syscall(syscall: \"encoding_toml_encode\", value: any): string;\n\n\tfunction syscall(syscall: \"encoding_utf8_decode\", value: Uint8Array): string;\n\n\tfunction syscall(syscall: \"encoding_utf8_encode\", value: string): Uint8Array;\n\n\tfunction syscall(syscall: \"encoding_yaml_decode\", value: string): unknown;\n\n\tfunction syscall(syscall: \"encoding_yaml_encode\", value: any): string;\n\n\tfunction syscall(syscall: \"file_new\", arg: File.Arg): File;\n\n\tfunction syscall(syscall: \"log\", value: string): void;\n\n\tfunction syscall(syscall: \"operation_get\", block: Block): Promise<Operation>;\n\n\tfunction syscall(\n\t\tsyscall: \"operation_evaluate\",\n\t\toperation: Operation,\n\t): Promise<Value>;\n\n\tfunction syscall(syscall: \"resource_new\", arg: Resource.Arg): Resource;\n\n\tfunction syscall(syscall: \"symlink_new\", arg: Symlink.Arg): Symlink;\n\n\tfunction syscall(syscall: \"target_new\", arg: Target.Arg): Target;\n\n\tfunction syscall(syscall: \"task_new\", arg: Task.Arg): Task;\n}\n\nexport type Artifact =\n\t| { kind: \"directory\"; value: Directory }\n\t| { kind: \"file\"; value: File }\n\t| { kind: \"symlink\"; value: Symlink };\n\nexport type Blob = {\n\tblock: Block;\n\tkind: Blob.Kind;\n};\n\nexport namespace Blob {\n\texport type Arg = {\n\t\tchildren: Array<Block>;\n\t};\n\n\texport type Kind =\n\t\t| { kind: \"branch\"; value: Array<[Block, number]> }\n\t\t| { kind: \"leaf\"; value: number };\n}\n\nexport type Block = {\n\tid: Id;\n};\n\nexport namespace Block {\n\texport type Arg = {\n\t\tchildren: Array<Block>;\n\t\tdata: Uint8Array | string;\n\t};\n}\n\nexport type Checksum = string;\n\nexport type ChecksumAlgorithm = \"blake3\" | \"sha256\" | \"sha512\";\n\nexport type Directory = {\n\tblock: Block;\n\tentries: Record<string, Block>;\n};\n\nexport namespace Directory {\n\texport type Arg = {\n\t\tentries: Record<string, Artifact>;\n\t};\n}\n\nexport type File = {\n\tblock: Block;\n\tcontents: Block;\n\texecutable: boolean;\n\treferences: Array<Block>;\n};\n\nexport namespace File {\n\texport type Arg = {\n\t\tcontents: Blob;\n\t\texecutable: boolean;\n\t\treferences: Array<Artifact>;\n\t};\n}\n\nexport type Id = string;\n\nexport type Module =\n\t| { kind: \"library\"; value: LibraryModule }\n\t| { kind: \"document\"; value: DocumentModule }\n\t| { kind: \"normal\"; value: NormalModule };\n\nexport type LibraryModule = {\n\tmodulePath: Subpath;\n};\n\nexport type DocumentModule = {\n\tpackagePath: string;\n\tmodulePath: Subpath;\n};\n\nexport type NormalModule = {\n\tpackage: Block;\n\tmodulePath: Subpath;\n};\n\nexport type Package = {\n\tartifact: Artifact;\n};\n\nexport type Position = {\n\tline: number;\n\tcharacter: number;\n};\n\nexport type Operation =\n\t| { kind: \"resource\"; value: Resource }\n\t| { kind: \"target\"; value: Target }\n\t| { kind: \"task\"; value: Task };\n\nexport type Relpath = string;\n\nexport type Subpath = string;\n\nexport type Placeholder = {\n\tname: string;\n};\n\nexport type Resource = {\n\tblock: Block;\n\turl: string;\n\tunpack?: UnpackFormat;\n\tchecksum?: Checksum;\n\tunsafe: boolean;\n};\n\nexport namespace Resource {\n\texport type Arg = {\n\t\turl: string;\n\t\tunpack?: UnpackFormat;\n\t\tchecksum?: Checksum;\n\t\tunsafe: boolean;\n\t};\n}\n\nexport type UnpackFormat =\n\t| \".tar\"\n\t| \".tar.bz2\"\n\t| \".tar.gz\"\n\t| \".tar.lz\"\n\t| \".tar.xz\"\n\t| \".tar.zstd\"\n\t| \".zip\";\n\nexport type Symlink = {\n\tblock: Block;\n\ttarget: Template;\n};\n\nexport namespace Symlink {\n\texport type Arg = { target: Template };\n}\n\nexport type Target = {\n\tblock: Block;\n\tpackage: Block;\n\tmodulePath: Subpath;\n\tname: string;\n\tenv?: Record<string, Value>;\n\targs?: Array<Value>;\n};\n\nexport namespace Target {\n\texport type Arg = {\n\t\tpackage: Block;\n\t\tmodulePath: Subpath;\n\t\tname: string;\n\t\tenv: Record<string, Value>;\n\t\targs: Array<Value>;\n\t};\n}\n\nexport type Task = {\n\tblock: Block;\n\tsystem: System;\n\texecutable: Template;\n\tenv: Record<string, Template>;\n\targs: Array<Template>;\n\tchecksum: Checksum | undefined;\n\tunsafe: boolean;\n\tnetwork: boolean;\n};\n\nexport namespace Task {\n\texport type Arg = {\n\t\tsystem: System;\n\t\texecutable: Template;\n\t\tenv?: Record<string, Template>;\n\t\targs?: Array<Template>;\n\t\tchecksum?: Checksum;\n\t\tunsafe?: boolean;\n\t\tnetwork?: boolean;\n\t};\n}\n\nexport type Template = {\n\tcomponents: Array<Template.Component>;\n};\n\nexport namespace Template {\n\texport type Component =\n\t\t| { kind: \"string\"; value: string }\n\t\t| { kind: \"artifact\"; value: Artifact }\n\t\t| { kind: \"placeholder\"; value: Placeholder };\n}\n\nexport type System =\n\t| \"amd64_linux\"\n\t| \"arm64_linux\"\n\t| \"amd64_macos\"\n\t| \"arm64_macos\";\n\nexport type Value =\n\t| { kind: \"null\" }\n\t| { kind: \"bool\"; value: boolean }\n\t| { kind: \"number\"; value: number }\n\t| { kind: \"string\"; value: string }\n\t| { kind: \"bytes\"; value: Uint8Array }\n\t| { kind: \"subpath\"; value: Subpath }\n\t| { kind: \"relpath\"; value: Relpath }\n\t| { kind: \"block\"; value: Block }\n\t| { kind: \"blob\"; value: Blob }\n\t| { kind: \"artifact\"; value: Artifact }\n\t| { kind: \"placeholder\"; value: Placeholder }\n\t| { kind: \"template\"; value: Template }\n\t| { kind: \"operation\"; value: Operation }\n\t| { kind: \"array\"; value: Array<Value> }\n\t| { kind: \"object\"; value: Record<string, Value> };\n\nexport let artifact = {\n\tbundle: async (artifact: Artifact): Promise<Artifact> => {\n\t\ttry {\n\t\t\treturn await syscall(\"artifact_bundle\", artifact);\n\t\t} catch (cause) {\n\t\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t\t}\n\t},\n\n\tget: async (block: Block): Promise<Artifact> => {\n\t\ttry {\n\t\t\treturn await syscall(\"artifact_get\", block);\n\t\t} catch (cause) {\n\t\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t\t}\n\t},\n};\n\nexport let blob = {\n\tbytes: async (blob: Blob): Promise<Uint8Array> => {\n\t\ttry {\n\t\t\treturn await syscall(\"blob_bytes\", blob);\n\t\t} catch (cause) {\n\t\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t\t}\n\t},\n\n\tget: async (arg: Block): Promise<Blob> => {\n\t\ttry {\n\t\t\treturn await syscall(\"blob_get\", arg);\n\t\t} catch (cause) {\n\t\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t\t}\n\t},\n\n\tnew: async (arg: Blob.Arg): Promise<Blob> => {\n\t\ttry {\n\t\t\treturn await syscall(\"blob_new\", arg);\n\t\t} catch (cause) {\n\t\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t\t}\n\t},\n\n\ttext: async (blob: Blob): Promise<string> => {\n\t\ttry {\n\t\t\treturn await syscall(\"blob_text\", blob);\n\t\t} catch (cause) {\n\t\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t\t}\n\t},\n};\n\nexport let block = {\n\tbytes: async (block: Block): Promise<Uint8Array> => {\n\t\ttry {\n\t\t\treturn await syscall(\"block_bytes\", block);\n\t\t} catch (cause) {\n\t\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t\t}\n\t},\n\n\tchildren: async (block: Block): Promise<Array<Block>> => {\n\t\ttry {\n\t\t\treturn syscall(\"block_children\", block);\n\t\t} catch (cause) {\n\t\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t\t}\n\t},\n\n\tdata: async (block: Block): Promise<Uint8Array> => {\n\t\ttry {\n\t\t\treturn await syscall(\"block_data\", block);\n\t\t} catch (cause) {\n\t\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t\t}\n\t},\n\n\tnew: async (arg: Block.Arg): Promise<Block> => {\n\t\ttry {\n\t\t\treturn syscall(\"block_new\", arg);\n\t\t} catch (cause) {\n\t\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t\t}\n\t},\n};\n\nexport let checksum = (\n\talgorithm: ChecksumAlgorithm,\n\tbytes: string | Uint8Array,\n): Checksum => {\n\ttry {\n\t\treturn syscall(\"checksum\", algorithm, bytes);\n\t} catch (cause) {\n\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t}\n};\n\nexport let directory = {\n\tnew: (arg: Directory.Arg): Directory => {\n\t\ttry {\n\t\t\treturn syscall(\"directory_new\", arg);\n\t\t} catch (cause) {\n\t\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t\t}\n\t},\n};\n\nexport namespace encoding {\n\texport let base64 = {\n\t\tdecode: (value: string): Uint8Array => {\n\t\t\ttry {\n\t\t\t\treturn syscall(\"encoding_base64_decode\", value);\n\t\t\t} catch (cause) {\n\t\t\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t\t\t}\n\t\t},\n\n\t\tencode: (value: Uint8Array): string => {\n\t\t\ttry {\n\t\t\t\treturn syscall(\"encoding_base64_encode\", value);\n\t\t\t} catch (cause) {\n\t\t\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t\t\t}\n\t\t},\n\t};\n\n\texport let hex = {\n\t\tdecode: (value: string): Uint8Array => {\n\t\t\ttry {\n\t\t\t\treturn syscall(\"encoding_hex_decode\", value);\n\t\t\t} catch (cause) {\n\t\t\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t\t\t}\n\t\t},\n\n\t\tencode: (value: Uint8Array): string => {\n\t\t\ttry {\n\t\t\t\treturn syscall(\"encoding_hex_encode\", value);\n\t\t\t} catch (cause) {\n\t\t\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t\t\t}\n\t\t},\n\t};\n\n\texport let json = {\n\t\tdecode: (value: string): unknown => {\n\t\t\ttry {\n\t\t\t\treturn syscall(\"encoding_json_decode\", value);\n\t\t\t} catch (cause) {\n\t\t\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t\t\t}\n\t\t},\n\n\t\tencode: (value: any): string => {\n\t\t\ttry {\n\t\t\t\treturn syscall(\"encoding_json_encode\", value);\n\t\t\t} catch (cause) {\n\t\t\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t\t\t}\n\t\t},\n\t};\n\n\texport let toml = {\n\t\tdecode: (value: string): unknown => {\n\t\t\ttry {\n\t\t\t\treturn syscall(\"encoding_toml_decode\", value);\n\t\t\t} catch (cause) {\n\t\t\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t\t\t}\n\t\t},\n\n\t\tencode: (value: any): string => {\n\t\t\ttry {\n\t\t\t\treturn syscall(\"encoding_toml_encode\", value);\n\t\t\t} catch (cause) {\n\t\t\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t\t\t}\n\t\t},\n\t};\n\n\texport let utf8 = {\n\t\tdecode: (value: Uint8Array): string => {\n\t\t\ttry {\n\t\t\t\treturn syscall(\"encoding_utf8_decode\", value);\n\t\t\t} catch (cause) {\n\t\t\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t\t\t}\n\t\t},\n\n\t\tencode: (value: string): Uint8Array => {\n\t\t\ttry {\n\t\t\t\treturn syscall(\"encoding_utf8_encode\", value);\n\t\t\t} catch (cause) {\n\t\t\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t\t\t}\n\t\t},\n\t};\n\n\texport let yaml = {\n\t\tdecode: (value: string): unknown => {\n\t\t\ttry {\n\t\t\t\treturn syscall(\"encoding_yaml_decode\", value);\n\t\t\t} catch (cause) {\n\t\t\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t\t\t}\n\t\t},\n\n\t\tencode: (value: any): string => {\n\t\t\ttry {\n\t\t\t\treturn syscall(\"encoding_yaml_encode\", value);\n\t\t\t} catch (cause) {\n\t\t\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t\t\t}\n\t\t},\n\t};\n}\n\nexport let file = {\n\tnew: (arg: File.Arg): File => {\n\t\ttry {\n\t\t\treturn syscall(\"file_new\", arg);\n\t\t} catch (cause) {\n\t\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t\t}\n\t},\n};\n\nexport let log = (value: string) => {\n\ttry {\n\t\treturn syscall(\"log\", value);\n\t} catch (cause) {\n\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t}\n};\n\nexport let operation = {\n\tget: async (block: Block): Promise<Operation> => {\n\t\ttry {\n\t\t\treturn await syscall(\"operation_get\", block);\n\t\t} catch (cause) {\n\t\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t\t}\n\t},\n\n\tevaluation: async (operation: Operation): Promise<Value> => {\n\t\ttry {\n\t\t\treturn await syscall(\"operation_evaluate\", operation);\n\t\t} catch (cause) {\n\t\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t\t}\n\t},\n};\n\nexport let resource = {\n\tnew: (arg: Resource.Arg): Resource => {\n\t\ttry {\n\t\t\treturn syscall(\"resource_new\", arg);\n\t\t} catch (cause) {\n\t\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t\t}\n\t},\n};\n\nexport let target = {\n\tnew: (arg: Target.Arg): Target => {\n\t\ttry {\n\t\t\treturn syscall(\"target_new\", arg);\n\t\t} catch (cause) {\n\t\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t\t}\n\t},\n};\n\nexport let task = {\n\tnew: (arg: Task.Arg): Task => {\n\t\ttry {\n\t\t\treturn syscall(\"task_new\", arg);\n\t\t} catch (cause) {\n\t\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t\t}\n\t},\n};\n\nexport let symlink = {\n\tnew: (arg: Symlink.Arg): Symlink => {\n\t\ttry {\n\t\t\treturn syscall(\"symlink_new\", arg);\n\t\t} catch (cause) {\n\t\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t\t}\n\t},\n};\n", "export type MaybeArray<T> = T | Array<T>;\n\nexport type NestedArray<T> = Array<MaybeNestedArray<T>>;\n\nexport type MaybeNestedArray<T> = T | Array<MaybeNestedArray<T>>;\n\nexport let flatten = <T>(value: NestedArray<T>): Array<T> => {\n\t// @ts-ignore\n\treturn value.flat(Infinity);\n};\n", "import { Artifact } from \"./artifact.ts\";\nimport { assert as assert_, unreachable } from \"./assert.ts\";\nimport { Blob, blob } from \"./blob.ts\";\nimport { Block } from \"./block.ts\";\nimport { Unresolved, resolve } from \"./resolve.ts\";\nimport * as syscall from \"./syscall.ts\";\nimport { MaybeNestedArray, flatten } from \"./util.ts\";\n\nexport let file = async (...args: Array<Unresolved<File.Arg>>) => {\n\treturn await File.new(...args);\n};\n\ntype ConstructorArg = {\n\tblock: Block;\n\tcontents: Block;\n\texecutable: boolean;\n\treferences: Array<Block>;\n};\n\nexport class File {\n\t#block: Block;\n\t#contents: Block;\n\t#executable: boolean;\n\t#references: Array<Block>;\n\n\tstatic async new(...args: Array<Unresolved<File.Arg>>): Promise<File> {\n\t\tlet {\n\t\t\tcontents: contentsArgs,\n\t\t\texecutable,\n\t\t\treferences,\n\t\t} = flatten(\n\t\t\tawait Promise.all(\n\t\t\t\targs.map(async function map(\n\t\t\t\t\tunresolvedArg: Unresolved<File.Arg>,\n\t\t\t\t): Promise<\n\t\t\t\t\tMaybeNestedArray<{\n\t\t\t\t\t\tcontents: Blob.Arg;\n\t\t\t\t\t\texecutable?: boolean;\n\t\t\t\t\t\treferences?: Array<Artifact>;\n\t\t\t\t\t}>\n\t\t\t\t> {\n\t\t\t\t\tlet arg = await resolve(unresolvedArg);\n\t\t\t\t\tif (Blob.Arg.is(arg)) {\n\t\t\t\t\t\treturn { contents: arg };\n\t\t\t\t\t} else if (File.is(arg)) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tcontents: arg.#contents,\n\t\t\t\t\t\t\texecutable: arg.#executable,\n\t\t\t\t\t\t\treferences: await arg.references(),\n\t\t\t\t\t\t};\n\t\t\t\t\t} else if (arg instanceof Array) {\n\t\t\t\t\t\treturn await Promise.all(arg.map(map));\n\t\t\t\t\t} else if (arg instanceof Object) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tcontents: arg.contents,\n\t\t\t\t\t\t\texecutable: arg.executable,\n\t\t\t\t\t\t\treferences: arg.references,\n\t\t\t\t\t\t};\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn unreachable();\n\t\t\t\t\t}\n\t\t\t\t}),\n\t\t\t),\n\t\t).reduce<{\n\t\t\tcontents: Array<Blob.Arg>;\n\t\t\texecutable: boolean;\n\t\t\treferences: Array<Artifact>;\n\t\t}>(\n\t\t\t(value, { contents, executable, references }) => {\n\t\t\t\tvalue.contents.push(contents);\n\t\t\t\tvalue.executable =\n\t\t\t\t\texecutable !== undefined ? executable : value.executable;\n\t\t\t\tvalue.references.push(...(references ?? []));\n\t\t\t\treturn value;\n\t\t\t},\n\t\t\t{ contents: [], executable: false, references: [] },\n\t\t);\n\t\tlet contents = await blob(...contentsArgs);\n\t\treturn File.fromSyscall(\n\t\t\tsyscall.file.new({\n\t\t\t\tcontents: contents.toSyscall(),\n\t\t\t\texecutable,\n\t\t\t\treferences: references.map((reference) =>\n\t\t\t\t\tArtifact.toSyscall(reference),\n\t\t\t\t),\n\t\t\t}),\n\t\t);\n\t}\n\n\tconstructor(arg: ConstructorArg) {\n\t\tthis.#block = arg.block;\n\t\tthis.#contents = arg.contents;\n\t\tthis.#executable = arg.executable;\n\t\tthis.#references = arg.references;\n\t}\n\n\tstatic is(value: unknown): value is File {\n\t\treturn value instanceof File;\n\t}\n\n\tstatic expect(value: unknown): File {\n\t\tassert_(File.is(value));\n\t\treturn value;\n\t}\n\n\tstatic assert(value: unknown): asserts value is File {\n\t\tassert_(File.is(value));\n\t}\n\n\ttoSyscall(): syscall.File {\n\t\tlet block = this.#block.toSyscall();\n\t\tlet contents = this.#contents.toSyscall();\n\t\tlet executable = this.#executable;\n\t\tlet references = this.#references.map((block) => block.toSyscall());\n\t\treturn {\n\t\t\tblock,\n\t\t\tcontents,\n\t\t\texecutable,\n\t\t\treferences,\n\t\t};\n\t}\n\n\tstatic fromSyscall(value: syscall.File): File {\n\t\tlet block = Block.fromSyscall(value.block);\n\t\tlet contents = Block.fromSyscall(value.contents);\n\t\tlet executable = value.executable;\n\t\tlet references = value.references.map((block) => Block.fromSyscall(block));\n\t\treturn new File({\n\t\t\tblock,\n\t\t\tcontents,\n\t\t\texecutable,\n\t\t\treferences,\n\t\t});\n\t}\n\n\tblock(): Block {\n\t\treturn this.#block;\n\t}\n\n\tasync contents(): Promise<Blob> {\n\t\treturn await Blob.get(this.#contents);\n\t}\n\n\texecutable(): boolean {\n\t\treturn this.#executable;\n\t}\n\n\tasync references(): Promise<Array<Artifact>> {\n\t\treturn await Promise.all(this.#references.map(Artifact.get));\n\t}\n\n\tasync bytes(): Promise<Uint8Array> {\n\t\treturn await (await this.contents()).bytes();\n\t}\n\n\tasync text(): Promise<string> {\n\t\treturn await (await this.contents()).text();\n\t}\n}\n\nexport namespace File {\n\texport type Arg = Blob.Arg | File | Array<Arg> | ArgObject;\n\n\texport type ArgObject = {\n\t\tcontents: Blob.Arg;\n\t\texecutable?: boolean;\n\t\treferences?: Array<Artifact>;\n\t};\n}\n", "import { assert as assert_, unreachable } from \"./assert.ts\";\nimport * as syscall from \"./syscall.ts\";\n\nexport let relpath = (...args: Array<Relpath.Arg>): Relpath => {\n\treturn Relpath.new(...args);\n};\n\nexport let subpath = (...args: Array<Subpath.Arg>): Subpath => {\n\treturn Subpath.new(...args);\n};\n\ntype RelpathConstructorArg = {\n\tparents?: number;\n\tsubpath?: Subpath;\n};\n\nexport class Relpath {\n\t#parents: number;\n\t#subpath: Subpath;\n\n\tstatic new(...args: Array<Relpath.Arg>): Relpath {\n\t\treturn args.reduce(function reduce(path: Relpath, arg: Relpath.Arg) {\n\t\t\tif (typeof arg === \"string\") {\n\t\t\t\tfor (let component of arg.split(\"/\")) {\n\t\t\t\t\tif (component === \"\" || component === \".\") {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else if (component === \"..\") {\n\t\t\t\t\t\tpath = path.parent();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpath.#subpath.push(component);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (arg instanceof Relpath) {\n\t\t\t\tfor (let i = 0; i < arg.#parents; i++) {\n\t\t\t\t\tpath.parent();\n\t\t\t\t}\n\t\t\t\tpath.#subpath.join(arg.#subpath);\n\t\t\t} else if (arg instanceof Subpath) {\n\t\t\t\tpath.#subpath.join(arg);\n\t\t\t} else if (arg instanceof Array) {\n\t\t\t\targ.forEach((arg) => reduce(path, arg));\n\t\t\t} else {\n\t\t\t\treturn unreachable();\n\t\t\t}\n\t\t\treturn path;\n\t\t}, new Relpath());\n\t}\n\n\tconstructor(arg?: RelpathConstructorArg) {\n\t\tthis.#parents = arg?.parents ?? 0;\n\t\tthis.#subpath = arg?.subpath ?? new Subpath();\n\t}\n\n\tstatic is(value: unknown): value is Relpath {\n\t\treturn value instanceof Relpath;\n\t}\n\n\ttoSyscall(): syscall.Relpath {\n\t\treturn this.toString();\n\t}\n\n\tstatic fromSyscall(value: syscall.Relpath): Relpath {\n\t\treturn Relpath.new(value);\n\t}\n\n\tisEmpty(): boolean {\n\t\treturn this.#parents == 0 && this.#subpath.isEmpty();\n\t}\n\n\tparents(): number {\n\t\treturn this.#parents;\n\t}\n\n\tsubpath(): Subpath {\n\t\treturn this.#subpath;\n\t}\n\n\tparent(): Relpath {\n\t\tif (this.#subpath.isEmpty()) {\n\t\t\tthis.#parents += 1;\n\t\t} else {\n\t\t\tthis.#subpath.pop();\n\t\t}\n\t\treturn this;\n\t}\n\n\tjoin(other: Relpath.Arg): Relpath {\n\t\tother = Relpath.new(other);\n\t\tfor (let i = 0; i < other.#parents; i++) {\n\t\t\tthis.parent();\n\t\t}\n\t\tthis.#subpath.join(other.#subpath);\n\t\treturn this;\n\t}\n\n\textension(): string | undefined {\n\t\treturn this.#subpath.extension();\n\t}\n\n\ttoSubpath(): Subpath {\n\t\tif (this.#parents > 0) {\n\t\t\tthrow new Error(\"Cannot convert to subpath.\");\n\t\t}\n\t\treturn this.#subpath;\n\t}\n\n\ttoString(): string {\n\t\tlet string = \"\";\n\t\tfor (let i = 0; i < this.#parents; i++) {\n\t\t\tstring += \"../\";\n\t\t}\n\t\tstring += this.#subpath.toString();\n\t\treturn string;\n\t}\n}\n\nexport namespace Relpath {\n\texport type Arg = undefined | string | Subpath | Relpath | Array<Arg>;\n\n\texport namespace Arg {\n\t\texport let is = (value: unknown): value is Relpath.Arg => {\n\t\t\treturn (\n\t\t\t\tvalue === undefined ||\n\t\t\t\ttypeof value === \"string\" ||\n\t\t\t\tvalue instanceof Subpath ||\n\t\t\t\tvalue instanceof Relpath ||\n\t\t\t\t(value instanceof Array && value.every(Relpath.Arg.is))\n\t\t\t);\n\t\t};\n\n\t\texport let expect = (value: unknown): Relpath.Arg => {\n\t\t\tassert_(is(value));\n\t\t\treturn value;\n\t\t};\n\n\t\texport let assert = (value: unknown): asserts value is Relpath.Arg => {\n\t\t\tassert_(is(value));\n\t\t};\n\t}\n}\n\nexport class Subpath {\n\t#components: Array<string>;\n\n\tstatic new(...args: Array<Subpath.Arg>): Subpath {\n\t\treturn Relpath.new(...args).toSubpath();\n\t}\n\n\tconstructor(components?: Array<string>) {\n\t\tthis.#components = components ?? [];\n\t}\n\n\tstatic is(value: unknown): value is Subpath {\n\t\treturn value instanceof Subpath;\n\t}\n\n\ttoSyscall(): syscall.Subpath {\n\t\treturn this.toString();\n\t}\n\n\tstatic fromSyscall(value: syscall.Subpath): Subpath {\n\t\treturn subpath(value);\n\t}\n\n\tcomponents(): Array<string> {\n\t\treturn [...this.#components];\n\t}\n\n\tisEmpty(): boolean {\n\t\treturn this.#components.length == 0;\n\t}\n\n\tjoin(other: Subpath): Subpath {\n\t\tthis.#components.push(...other.#components);\n\t\treturn this;\n\t}\n\n\tpush(component: string) {\n\t\tthis.#components.push(component);\n\t}\n\n\tpop() {\n\t\tthis.#components.pop();\n\t}\n\n\textension(): string | undefined {\n\t\treturn this.#components.at(-1)?.split(\".\").at(-1);\n\t}\n\n\ttoRelpath(): Relpath {\n\t\treturn Relpath.new(this);\n\t}\n\n\ttoString(): string {\n\t\treturn this.#components.join(\"/\");\n\t}\n}\n\nexport namespace Subpath {\n\texport type Arg = undefined | string | Subpath | Array<Arg>;\n}\n", "import * as syscall from \"./syscall.ts\";\n\nexport let placeholder = (name: string) => {\n\treturn Placeholder.new(name);\n};\n\nexport class Placeholder {\n\t#name: string;\n\n\tstatic new(name: string): Placeholder {\n\t\treturn new Placeholder(name);\n\t}\n\n\tconstructor(name: string) {\n\t\tthis.#name = name;\n\t}\n\n\tstatic is(value: unknown): value is Placeholder {\n\t\treturn value instanceof Placeholder;\n\t}\n\n\ttoSyscall(): syscall.Placeholder {\n\t\treturn {\n\t\t\tname: this.#name,\n\t\t};\n\t}\n\n\tstatic fromSyscall(placeholder: syscall.Placeholder): Placeholder {\n\t\tlet name = placeholder.name;\n\t\treturn new Placeholder(name);\n\t}\n\n\tname(): string {\n\t\treturn this.#name;\n\t}\n}\n", "import { assert } from \"./assert\";\nimport { Value } from \"./value\";\n\nexport namespace env {\n\texport let value: Record<string, Value> | undefined;\n\n\texport let get = (): Record<string, Value> => {\n\t\tassert(value);\n\t\treturn value;\n\t};\n}\n", "import { Artifact } from \"./artifact.ts\";\nimport { assert as assert_, unreachable } from \"./assert.ts\";\nimport { Relpath, Subpath } from \"./path.ts\";\nimport { Placeholder } from \"./placeholder.ts\";\nimport { Unresolved, resolve } from \"./resolve.ts\";\nimport * as syscall from \"./syscall.ts\";\nimport { MaybeNestedArray, flatten } from \"./util.ts\";\n\nexport let t = async (\n\tstrings: TemplateStringsArray,\n\t...placeholders: Array<Unresolved<Template.Arg>>\n): Promise<Template> => {\n\t// Collect the strings and placeholders.\n\tlet components: Array<Unresolved<Template.Arg>> = [];\n\tfor (let i = 0; i < strings.length - 1; i++) {\n\t\tlet string = strings[i]!;\n\t\tcomponents.push(string);\n\t\tlet placeholder = placeholders[i]!;\n\t\tcomponents.push(placeholder);\n\t}\n\tcomponents.push(strings[strings.length - 1]!);\n\treturn await template(...components);\n};\n\nexport let template = (\n\t...args: Array<Unresolved<Template.Arg>>\n): Promise<Template> => {\n\treturn Template.new(...args);\n};\n\nexport class Template {\n\t#components: Array<Template.Component>;\n\n\tstatic async new(\n\t\t...args: Array<Unresolved<Template.Arg>>\n\t): Promise<Template> {\n\t\t// Collect the components.\n\t\tlet components = flatten(\n\t\t\tawait Promise.all(\n\t\t\t\targs.map(async function map(\n\t\t\t\t\targ,\n\t\t\t\t): Promise<MaybeNestedArray<Template.Component>> {\n\t\t\t\t\targ = await resolve(arg);\n\t\t\t\t\tif (Template.Component.is(arg)) {\n\t\t\t\t\t\treturn arg;\n\t\t\t\t\t} else if (arg instanceof Relpath || arg instanceof Subpath) {\n\t\t\t\t\t\treturn arg.toString();\n\t\t\t\t\t} else if (arg instanceof Template) {\n\t\t\t\t\t\treturn arg.components();\n\t\t\t\t\t} else if (arg instanceof Array) {\n\t\t\t\t\t\treturn await Promise.all(arg.map(map));\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn unreachable();\n\t\t\t\t\t}\n\t\t\t\t}),\n\t\t\t),\n\t\t).reduce<Array<Template.Component>>((components, component) => {\n\t\t\tcomponents.push(component);\n\t\t\treturn components;\n\t\t}, []);\n\n\t\t// Normalize the components.\n\t\tcomponents = components.reduce<Array<Template.Component>>(\n\t\t\t(components, component) => {\n\t\t\t\tlet lastComponent = components.at(-1);\n\t\t\t\tif (component === \"\") {\n\t\t\t\t\t// Ignore empty string components.\n\t\t\t\t} else if (\n\t\t\t\t\ttypeof lastComponent === \"string\" &&\n\t\t\t\t\ttypeof component === \"string\"\n\t\t\t\t) {\n\t\t\t\t\t// Merge adjacent string components.\n\t\t\t\t\tcomponents.splice(-1, 1, lastComponent + component);\n\t\t\t\t} else {\n\t\t\t\t\tcomponents.push(component);\n\t\t\t\t}\n\t\t\t\treturn components;\n\t\t\t},\n\t\t\t[],\n\t\t);\n\n\t\treturn new Template(components);\n\t}\n\n\tconstructor(components: Array<Template.Component>) {\n\t\tthis.#components = components;\n\t}\n\n\tstatic is(value: unknown): value is Template {\n\t\treturn value instanceof Template;\n\t}\n\n\tstatic expect(value: unknown): Template {\n\t\tassert_(Template.is(value));\n\t\treturn value;\n\t}\n\n\tstatic assert(value: unknown): asserts value is Template {\n\t\tassert_(Template.is(value));\n\t}\n\n\t/** Join an array of templates with a separator. */\n\tstatic async join(\n\t\tseparator: Unresolved<Template.Arg>,\n\t\t...args: Array<Unresolved<Template.Arg>>\n\t): Promise<Template> {\n\t\tlet separatorTemplate = await template(separator);\n\t\tlet argTemplates = await Promise.all(args.map((arg) => template(arg)));\n\t\targTemplates = argTemplates.filter((arg) => arg.components().length > 0);\n\t\tlet templates = [];\n\t\tfor (let i = 0; i < argTemplates.length; i++) {\n\t\t\tif (i > 0) {\n\t\t\t\ttemplates.push(separatorTemplate);\n\t\t\t}\n\t\t\tlet argTemplate = argTemplates[i];\n\t\t\tassert_(argTemplate);\n\t\t\ttemplates.push(argTemplate);\n\t\t}\n\t\treturn template(...templates);\n\t}\n\n\ttoSyscall(): syscall.Template {\n\t\tlet components = this.#components.map((component) =>\n\t\t\tTemplate.Component.toSyscall(component),\n\t\t);\n\t\treturn {\n\t\t\tcomponents,\n\t\t};\n\t}\n\n\tstatic fromSyscall(value: syscall.Template): Template {\n\t\tlet components = value.components.map((component) =>\n\t\t\tTemplate.Component.fromSyscall(component),\n\t\t);\n\t\treturn new Template(components);\n\t}\n\n\tcomponents(): Array<Template.Component> {\n\t\treturn [...this.#components];\n\t}\n}\n\nexport namespace Template {\n\texport type Component = string | Artifact | Placeholder;\n\n\texport namespace Component {\n\t\texport let is = (value: unknown): value is Component => {\n\t\t\treturn (\n\t\t\t\ttypeof value === \"string\" ||\n\t\t\t\tArtifact.is(value) ||\n\t\t\t\tvalue instanceof Placeholder\n\t\t\t);\n\t\t};\n\n\t\texport let toSyscall = (\n\t\t\tcomponent: Component,\n\t\t): syscall.Template.Component => {\n\t\t\tif (typeof component === \"string\") {\n\t\t\t\treturn {\n\t\t\t\t\tkind: \"string\",\n\t\t\t\t\tvalue: component,\n\t\t\t\t};\n\t\t\t} else if (Artifact.is(component)) {\n\t\t\t\treturn {\n\t\t\t\t\tkind: \"artifact\",\n\t\t\t\t\tvalue: Artifact.toSyscall(component),\n\t\t\t\t};\n\t\t\t} else if (component instanceof Placeholder) {\n\t\t\t\treturn {\n\t\t\t\t\tkind: \"placeholder\",\n\t\t\t\t\tvalue: component.toSyscall(),\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\treturn unreachable();\n\t\t\t}\n\t\t};\n\n\t\texport let fromSyscall = (\n\t\t\tcomponent: syscall.Template.Component,\n\t\t): Component => {\n\t\t\tswitch (component.kind) {\n\t\t\t\tcase \"string\": {\n\t\t\t\t\treturn component.value;\n\t\t\t\t}\n\t\t\t\tcase \"artifact\": {\n\t\t\t\t\treturn Artifact.fromSyscall(component.value);\n\t\t\t\t}\n\t\t\t\tcase \"placeholder\": {\n\t\t\t\t\treturn Placeholder.fromSyscall(component.value);\n\t\t\t\t}\n\t\t\t\tdefault: {\n\t\t\t\t\treturn unreachable();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n}\n\nexport namespace Template {\n\texport type Arg =\n\t\t| undefined\n\t\t| Component\n\t\t| Relpath\n\t\t| Subpath\n\t\t| Template\n\t\t| Array<Arg>;\n}\n", "import { Artifact } from \"./artifact.ts\";\nimport { assert as assert_, unreachable } from \"./assert.ts\";\nimport { Block } from \"./block.ts\";\nimport { Directory } from \"./directory.ts\";\nimport { File } from \"./file.ts\";\nimport { Relpath, Subpath, relpath } from \"./path.ts\";\nimport { Unresolved, resolve } from \"./resolve.ts\";\nimport * as syscall from \"./syscall.ts\";\nimport { Template, t } from \"./template.ts\";\nimport { MaybeNestedArray, flatten } from \"./util.ts\";\n\nexport let symlink = async (\n\t...args: Array<Unresolved<Symlink.Arg>>\n): Promise<Symlink> => {\n\treturn await Symlink.new(...args);\n};\n\ntype ConstructorArg = {\n\tblock: Block;\n\ttarget: Template;\n};\n\nexport class Symlink {\n\t#block: Block;\n\t#target: Template;\n\n\tstatic async new(...args: Array<Unresolved<Symlink.Arg>>): Promise<Symlink> {\n\t\t// Get the artifact and path.\n\t\tlet { artifact, path } = flatten(\n\t\t\tawait Promise.all(\n\t\t\t\targs.map(async function map(\n\t\t\t\t\tunresolvedArg,\n\t\t\t\t): Promise<MaybeNestedArray<{ artifact?: Artifact; path?: Relpath }>> {\n\t\t\t\t\tlet arg = await resolve(unresolvedArg);\n\t\t\t\t\tif (typeof arg === \"string\") {\n\t\t\t\t\t\treturn { path: relpath(arg) };\n\t\t\t\t\t} else if (Relpath.is(arg)) {\n\t\t\t\t\t\treturn { path: relpath(arg) };\n\t\t\t\t\t} else if (Subpath.is(arg)) {\n\t\t\t\t\t\treturn { path: arg.toRelpath() };\n\t\t\t\t\t} else if (Artifact.is(arg)) {\n\t\t\t\t\t\treturn { artifact: arg };\n\t\t\t\t\t} else if (arg instanceof Template) {\n\t\t\t\t\t\tassert_(arg.components().length <= 2);\n\t\t\t\t\t\tlet [firstComponent, secondComponent] = arg.components();\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\ttypeof firstComponent === \"string\" &&\n\t\t\t\t\t\t\tsecondComponent === undefined\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\treturn { path: relpath(firstComponent) };\n\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\tArtifact.is(firstComponent) &&\n\t\t\t\t\t\t\tsecondComponent === undefined\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\treturn { artifact: firstComponent };\n\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\tArtifact.is(firstComponent) &&\n\t\t\t\t\t\t\ttypeof secondComponent === \"string\"\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tassert_(secondComponent.startsWith(\"/\"));\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tartifact: firstComponent,\n\t\t\t\t\t\t\t\tpath: relpath(secondComponent.slice(1)),\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthrow new Error(\"Invalid template.\");\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (arg instanceof Symlink) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tartifact: arg.artifact(),\n\t\t\t\t\t\t\tpath: arg.path(),\n\t\t\t\t\t\t};\n\t\t\t\t\t} else if (arg instanceof Array) {\n\t\t\t\t\t\treturn await Promise.all(arg.map(map));\n\t\t\t\t\t} else if (typeof arg === \"object\") {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tartifact: arg.artifact,\n\t\t\t\t\t\t\tpath: relpath(arg.path),\n\t\t\t\t\t\t};\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn unreachable();\n\t\t\t\t\t}\n\t\t\t\t}),\n\t\t\t),\n\t\t).reduce<{ artifact: Artifact | undefined; path: Relpath }>(\n\t\t\t(value, { artifact, path }) => {\n\t\t\t\tif (artifact !== undefined) {\n\t\t\t\t\tvalue.artifact = artifact;\n\t\t\t\t\tvalue.path = path ?? relpath();\n\t\t\t\t} else {\n\t\t\t\t\tvalue.path = value.path.join(path);\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t},\n\t\t\t{ artifact: undefined, path: relpath() },\n\t\t);\n\n\t\t// Create the target.\n\t\tlet target;\n\t\tif (artifact !== undefined && !path.isEmpty()) {\n\t\t\ttarget = await t`${artifact}/${path}`;\n\t\t} else if (artifact !== undefined) {\n\t\t\ttarget = await t`${artifact}`;\n\t\t} else if (!path.isEmpty()) {\n\t\t\ttarget = await t`${path}`;\n\t\t} else {\n\t\t\tthrow new Error(\"Invalid symlink.\");\n\t\t}\n\n\t\treturn Symlink.fromSyscall(\n\t\t\tsyscall.symlink.new({ target: target.toSyscall() }),\n\t\t);\n\t}\n\n\tconstructor(arg: ConstructorArg) {\n\t\tthis.#block = arg.block;\n\t\tthis.#target = arg.target;\n\t}\n\n\tstatic is(value: unknown): value is Symlink {\n\t\treturn value instanceof Symlink;\n\t}\n\n\tstatic expect(value: unknown): Symlink {\n\t\tassert_(Symlink.is(value));\n\t\treturn value;\n\t}\n\n\tstatic assert(value: unknown): asserts value is Symlink {\n\t\tassert_(Symlink.is(value));\n\t}\n\n\ttoSyscall(): syscall.Symlink {\n\t\tlet block = this.#block.toSyscall();\n\t\tlet target = this.#target.toSyscall();\n\t\treturn {\n\t\t\tblock,\n\t\t\ttarget,\n\t\t};\n\t}\n\n\tstatic fromSyscall(symlink: syscall.Symlink): Symlink {\n\t\tlet block = Block.fromSyscall(symlink.block);\n\t\tlet target = Template.fromSyscall(symlink.target);\n\t\treturn new Symlink({\n\t\t\tblock,\n\t\t\ttarget,\n\t\t});\n\t}\n\n\tblock(): Block {\n\t\treturn this.#block;\n\t}\n\n\ttarget(): Template {\n\t\treturn this.#target;\n\t}\n\n\tartifact(): Artifact | undefined {\n\t\tlet firstComponent = this.#target.components().at(0);\n\t\tif (Artifact.is(firstComponent)) {\n\t\t\treturn firstComponent;\n\t\t} else {\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\tpath(): Relpath {\n\t\tlet [firstComponent, secondComponent] = this.#target.components();\n\t\tif (typeof firstComponent === \"string\" && secondComponent === undefined) {\n\t\t\treturn relpath(firstComponent);\n\t\t} else if (Artifact.is(firstComponent) && secondComponent === undefined) {\n\t\t\treturn relpath();\n\t\t} else if (\n\t\t\tArtifact.is(firstComponent) &&\n\t\t\ttypeof secondComponent === \"string\"\n\t\t) {\n\t\t\treturn relpath(secondComponent.slice(1));\n\t\t} else {\n\t\t\tthrow new Error(\"Invalid template.\");\n\t\t}\n\t}\n\n\tasync resolve(\n\t\tfrom?: Unresolved<Symlink.Arg>,\n\t): Promise<Directory | File | undefined> {\n\t\tfrom = from ? await symlink(from) : undefined;\n\t\tlet fromArtifact = from?.artifact();\n\t\tif (fromArtifact instanceof Symlink) {\n\t\t\tfromArtifact = await fromArtifact.resolve();\n\t\t}\n\t\tlet fromPath = from?.path();\n\t\tlet artifact = this.artifact();\n\t\tif (artifact instanceof Symlink) {\n\t\t\tartifact = await artifact.resolve();\n\t\t}\n\t\tlet path = this.path();\n\t\tif (artifact !== undefined && path.isEmpty()) {\n\t\t\treturn artifact;\n\t\t} else if (artifact === undefined && !path.isEmpty()) {\n\t\t\tif (!(fromArtifact instanceof Directory)) {\n\t\t\t\tthrow new Error(\"Expected a directory.\");\n\t\t\t}\n\t\t\treturn await fromArtifact.tryGet(\n\t\t\t\t(fromPath ?? relpath()).parent().join(path).toSubpath(),\n\t\t\t);\n\t\t} else if (artifact !== undefined && !path.isEmpty()) {\n\t\t\tif (!(artifact instanceof Directory)) {\n\t\t\t\tthrow new Error(\"Expected a directory.\");\n\t\t\t}\n\t\t\treturn await artifact.tryGet(path.toSubpath());\n\t\t} else {\n\t\t\tthrow new Error(\"Invalid symlink.\");\n\t\t}\n\t}\n}\n\nexport namespace Symlink {\n\texport type Arg =\n\t\t| string\n\t\t| Relpath\n\t\t| Subpath\n\t\t| Artifact\n\t\t| Template\n\t\t| Symlink\n\t\t| Array<Arg>\n\t\t| ArgObject;\n\n\texport type ArgObject = {\n\t\tartifact?: Artifact;\n\t\tpath?: string | Subpath;\n\t};\n}\n", "import { Artifact } from \"./artifact.ts\";\nimport { Block } from \"./block.ts\";\nimport { Checksum } from \"./checksum.ts\";\nimport { Operation } from \"./operation.ts\";\nimport { placeholder } from \"./placeholder.ts\";\nimport { Unresolved, resolve } from \"./resolve.ts\";\nimport * as syscall from \"./syscall.ts\";\nimport { System } from \"./system.ts\";\nimport { Template, template } from \"./template.ts\";\nimport { Value } from \"./value.ts\";\n\nexport let task = async (arg: Unresolved<Task.Arg>): Promise<Task> => {\n\treturn await Task.new(arg);\n};\n\nexport let run = async (\n\targ: Unresolved<Task.Arg>,\n): Promise<Artifact | undefined> => {\n\tlet task = await Task.new(arg);\n\tlet output = await task.run();\n\treturn output;\n};\n\nexport let output = placeholder(\"output\");\n\ntype ConstructorArg = {\n\tblock: Block;\n\tsystem: System;\n\texecutable: Template;\n\tenv: Record<string, Template>;\n\targs: Array<Template>;\n\tchecksum?: Checksum;\n\tunsafe: boolean;\n\tnetwork: boolean;\n};\n\nexport class Task {\n\t#block: Block;\n\t#system: System;\n\t#executable: Template;\n\t#env: Record<string, Template>;\n\t#args: Array<Template>;\n\t#checksum?: Checksum;\n\t#unsafe: boolean;\n\t#network: boolean;\n\n\tstatic async new(arg: Unresolved<Task.Arg>): Promise<Task> {\n\t\tlet resolvedArg = await resolve(arg);\n\t\tlet system = resolvedArg.system;\n\t\tlet executable = await template(resolvedArg.executable);\n\t\tlet env: Record<string, Template> = Object.fromEntries(\n\t\t\tawait Promise.all(\n\t\t\t\tObject.entries(resolvedArg.env ?? {}).map(async ([key, value]) => [\n\t\t\t\t\tkey,\n\t\t\t\t\tawait template(value),\n\t\t\t\t]),\n\t\t\t),\n\t\t);\n\t\tlet env_ = Object.fromEntries(\n\t\t\tObject.entries(env).map(([key, value]) => [key, value.toSyscall()]),\n\t\t);\n\t\tlet args_ = await Promise.all(\n\t\t\t(resolvedArg.args ?? []).map(async (arg) =>\n\t\t\t\t(await template(arg)).toSyscall(),\n\t\t\t),\n\t\t);\n\t\tlet checksum = resolvedArg.checksum ?? undefined;\n\t\tlet unsafe = resolvedArg.unsafe ?? false;\n\t\tlet network = resolvedArg.network ?? false;\n\t\treturn Task.fromSyscall(\n\t\t\tsyscall.task.new({\n\t\t\t\tsystem,\n\t\t\t\texecutable: executable.toSyscall(),\n\t\t\t\tenv: env_,\n\t\t\t\targs: args_,\n\t\t\t\tchecksum,\n\t\t\t\tunsafe,\n\t\t\t\tnetwork,\n\t\t\t}),\n\t\t);\n\t}\n\n\tconstructor(arg: ConstructorArg) {\n\t\tthis.#block = arg.block;\n\t\tthis.#system = arg.system;\n\t\tthis.#executable = arg.executable;\n\t\tthis.#env = arg.env;\n\t\tthis.#args = arg.args;\n\t\tthis.#checksum = arg.checksum;\n\t\tthis.#unsafe = arg.unsafe;\n\t\tthis.#network = arg.network;\n\t}\n\n\ttoSyscall(): syscall.Task {\n\t\tlet block = this.#block.toSyscall();\n\t\tlet system = this.#system;\n\t\tlet executable = this.#executable.toSyscall();\n\t\tlet env = Object.fromEntries(\n\t\t\tObject.entries(this.#env).map(([key, value]) => [key, value.toSyscall()]),\n\t\t);\n\t\tlet args = this.#args.map((arg) => arg.toSyscall());\n\t\tlet checksum = this.#checksum;\n\t\tlet unsafe = this.#unsafe;\n\t\tlet network = this.#network;\n\t\treturn {\n\t\t\tblock,\n\t\t\tsystem,\n\t\t\texecutable,\n\t\t\tenv,\n\t\t\targs,\n\t\t\tchecksum,\n\t\t\tunsafe,\n\t\t\tnetwork,\n\t\t};\n\t}\n\n\tstatic fromSyscall(task: syscall.Task): Task {\n\t\tlet block = Block.fromSyscall(task.block);\n\t\tlet system = task.system;\n\t\tlet executable = Template.fromSyscall(task.executable);\n\t\tlet env = Object.fromEntries(\n\t\t\tObject.entries(task.env).map(([key, value]) => [\n\t\t\t\tkey,\n\t\t\t\tTemplate.fromSyscall(value),\n\t\t\t]),\n\t\t);\n\t\tlet args = task.args.map((arg) => Template.fromSyscall(arg));\n\t\tlet checksum = task.checksum;\n\t\tlet unsafe = task.unsafe;\n\t\tlet network = task.network;\n\t\treturn new Task({\n\t\t\tblock,\n\t\t\tsystem,\n\t\t\texecutable,\n\t\t\tenv,\n\t\t\targs,\n\t\t\tchecksum,\n\t\t\tunsafe,\n\t\t\tnetwork,\n\t\t});\n\t}\n\n\tblock(): Block {\n\t\treturn this.#block;\n\t}\n\n\tasync run(): Promise<Artifact | undefined> {\n\t\tlet outputFromSyscall = await syscall.operation.evaluation(\n\t\t\tOperation.toSyscall(this),\n\t\t);\n\t\tlet output = Value.fromSyscall(outputFromSyscall);\n\t\treturn output as Artifact;\n\t}\n}\n\nexport namespace Task {\n\texport type Arg = {\n\t\tsystem: System;\n\t\texecutable: Template.Arg;\n\t\tenv?: Record<string, Template.Arg>;\n\t\targs?: Array<Template.Arg>;\n\t\tchecksum?: Checksum;\n\t\tunsafe?: boolean;\n\t\tnetwork?: boolean;\n\t};\n}\n", "import { Artifact } from \"./artifact.ts\";\nimport { assert as assert_, unreachable } from \"./assert.ts\";\nimport { Blob } from \"./blob.ts\";\nimport { Block } from \"./block.ts\";\nimport { Directory } from \"./directory.ts\";\nimport { File } from \"./file.ts\";\nimport { Operation } from \"./operation.ts\";\nimport { Relpath, Subpath } from \"./path.ts\";\nimport { Placeholder } from \"./placeholder.ts\";\nimport { Resource } from \"./resource.ts\";\nimport { Symlink } from \"./symlink.ts\";\nimport * as syscall from \"./syscall.ts\";\nimport { Target } from \"./target.ts\";\nimport { Task } from \"./task.ts\";\nimport { Template } from \"./template.ts\";\n\nexport type Value =\n\t| undefined\n\t| boolean\n\t| number\n\t| string\n\t| Uint8Array\n\t| Relpath\n\t| Subpath\n\t| Block\n\t| Blob\n\t| Artifact\n\t| Placeholder\n\t| Template\n\t| Operation\n\t| Array<Value>\n\t| { [key: string]: Value };\n\nexport namespace Value {\n\texport let is = (value: unknown): value is Value => {\n\t\treturn (\n\t\t\tvalue === undefined ||\n\t\t\ttypeof value === \"boolean\" ||\n\t\t\ttypeof value === \"number\" ||\n\t\t\ttypeof value === \"string\" ||\n\t\t\tvalue instanceof Uint8Array ||\n\t\t\tvalue instanceof Relpath ||\n\t\t\tvalue instanceof Subpath ||\n\t\t\tvalue instanceof Blob ||\n\t\t\tvalue instanceof Block ||\n\t\t\tvalue instanceof Directory ||\n\t\t\tvalue instanceof File ||\n\t\t\tvalue instanceof Symlink ||\n\t\t\tvalue instanceof Placeholder ||\n\t\t\tvalue instanceof Template ||\n\t\t\tvalue instanceof Resource ||\n\t\t\tvalue instanceof Target ||\n\t\t\tvalue instanceof Task ||\n\t\t\tvalue instanceof Array ||\n\t\t\ttypeof value === \"object\"\n\t\t);\n\t};\n\n\texport let expect = (value: unknown): Value => {\n\t\tassert_(is(value));\n\t\treturn value;\n\t};\n\n\texport let assert = (value: unknown): asserts value is Value => {\n\t\tassert_(is(value));\n\t};\n\n\texport let toSyscall = <T extends Value>(value: T): syscall.Value => {\n\t\tif (value === undefined) {\n\t\t\treturn {\n\t\t\t\tkind: \"null\",\n\t\t\t};\n\t\t} else if (typeof value === \"boolean\") {\n\t\t\treturn {\n\t\t\t\tkind: \"bool\",\n\t\t\t\tvalue,\n\t\t\t};\n\t\t} else if (typeof value === \"number\") {\n\t\t\treturn {\n\t\t\t\tkind: \"number\",\n\t\t\t\tvalue,\n\t\t\t};\n\t\t} else if (typeof value === \"string\") {\n\t\t\treturn {\n\t\t\t\tkind: \"string\",\n\t\t\t\tvalue,\n\t\t\t};\n\t\t} else if (value instanceof Uint8Array) {\n\t\t\treturn {\n\t\t\t\tkind: \"bytes\",\n\t\t\t\tvalue,\n\t\t\t};\n\t\t} else if (value instanceof Relpath) {\n\t\t\treturn {\n\t\t\t\tkind: \"relpath\",\n\t\t\t\tvalue: value.toSyscall(),\n\t\t\t};\n\t\t} else if (value instanceof Subpath) {\n\t\t\treturn {\n\t\t\t\tkind: \"subpath\",\n\t\t\t\tvalue: value.toSyscall(),\n\t\t\t};\n\t\t} else if (value instanceof Block) {\n\t\t\treturn {\n\t\t\t\tkind: \"block\",\n\t\t\t\tvalue: value.toSyscall(),\n\t\t\t};\n\t\t} else if (value instanceof Blob) {\n\t\t\treturn {\n\t\t\t\tkind: \"blob\",\n\t\t\t\tvalue: value.toSyscall(),\n\t\t\t};\n\t\t} else if (Artifact.is(value)) {\n\t\t\treturn {\n\t\t\t\tkind: \"artifact\",\n\t\t\t\tvalue: Artifact.toSyscall(value),\n\t\t\t};\n\t\t} else if (value instanceof Placeholder) {\n\t\t\treturn {\n\t\t\t\tkind: \"placeholder\",\n\t\t\t\tvalue: value.toSyscall(),\n\t\t\t};\n\t\t} else if (value instanceof Template) {\n\t\t\treturn {\n\t\t\t\tkind: \"template\",\n\t\t\t\tvalue: value.toSyscall(),\n\t\t\t};\n\t\t} else if (Operation.is(value)) {\n\t\t\treturn {\n\t\t\t\tkind: \"operation\",\n\t\t\t\tvalue: Operation.toSyscall(value),\n\t\t\t};\n\t\t} else if (value instanceof Array) {\n\t\t\tlet syscallValue = value.map((value) => Value.toSyscall(value));\n\t\t\treturn {\n\t\t\t\tkind: \"array\",\n\t\t\t\tvalue: syscallValue,\n\t\t\t};\n\t\t} else if (typeof value === \"object\") {\n\t\t\tlet syscallValue = Object.fromEntries(\n\t\t\t\tObject.entries(value).map(([key, value]) => [\n\t\t\t\t\tkey,\n\t\t\t\t\tValue.toSyscall(value),\n\t\t\t\t]),\n\t\t\t);\n\t\t\treturn {\n\t\t\t\tkind: \"object\",\n\t\t\t\tvalue: syscallValue,\n\t\t\t};\n\t\t} else {\n\t\t\treturn unreachable();\n\t\t}\n\t};\n\n\texport let fromSyscall = (value: syscall.Value): Value => {\n\t\tswitch (value.kind) {\n\t\t\tcase \"null\": {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\tcase \"bool\": {\n\t\t\t\treturn value.value;\n\t\t\t}\n\t\t\tcase \"number\": {\n\t\t\t\treturn value.value;\n\t\t\t}\n\t\t\tcase \"string\": {\n\t\t\t\treturn value.value;\n\t\t\t}\n\t\t\tcase \"bytes\": {\n\t\t\t\treturn value.value;\n\t\t\t}\n\t\t\tcase \"relpath\": {\n\t\t\t\treturn Relpath.fromSyscall(value.value);\n\t\t\t}\n\t\t\tcase \"subpath\": {\n\t\t\t\treturn Subpath.fromSyscall(value.value);\n\t\t\t}\n\t\t\tcase \"block\": {\n\t\t\t\treturn Block.fromSyscall(value.value);\n\t\t\t}\n\t\t\tcase \"blob\": {\n\t\t\t\treturn Blob.fromSyscall(value.value);\n\t\t\t}\n\t\t\tcase \"artifact\": {\n\t\t\t\treturn Artifact.fromSyscall(value.value);\n\t\t\t}\n\t\t\tcase \"placeholder\": {\n\t\t\t\treturn Placeholder.fromSyscall(value.value);\n\t\t\t}\n\t\t\tcase \"template\": {\n\t\t\t\treturn Template.fromSyscall(value.value);\n\t\t\t}\n\t\t\tcase \"operation\": {\n\t\t\t\treturn Operation.fromSyscall(value.value);\n\t\t\t}\n\t\t\tcase \"array\": {\n\t\t\t\treturn value.value.map((value) => Value.fromSyscall(value));\n\t\t\t}\n\t\t\tcase \"object\": {\n\t\t\t\treturn Object.fromEntries(\n\t\t\t\t\tObject.entries(value.value).map(([key, value]) => [\n\t\t\t\t\t\tkey,\n\t\t\t\t\t\tValue.fromSyscall(value),\n\t\t\t\t\t]),\n\t\t\t\t);\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\treturn unreachable();\n\t\t\t}\n\t\t}\n\t};\n}\n", "import { assert as assert_ } from \"./assert.ts\";\nimport { Block } from \"./block.ts\";\nimport { json } from \"./encoding.ts\";\nimport { env } from \"./env.ts\";\nimport { Operation } from \"./operation.ts\";\nimport { Subpath, subpath } from \"./path.ts\";\nimport { MaybePromise, Unresolved, resolve } from \"./resolve.ts\";\nimport * as syscall from \"./syscall.ts\";\nimport { Value } from \"./value.ts\";\n\nexport let targets: Record<string, Target<any, any>> = {};\n\nexport type TargetArg<\n\tA extends Array<Value> = Array<Value>,\n\tR extends Value = Value,\n> = {\n\tf: (...args: A) => MaybePromise<R>;\n\tmodule: syscall.Module;\n\tname: string;\n};\n\nexport let target = <\n\tA extends Array<Value> = Array<Value>,\n\tR extends Value = Value,\n>(\n\targ: TargetArg<A, R>,\n) => {\n\t// Create the target.\n\tassert_(arg.module.kind === \"normal\");\n\tlet target = Target.fromSyscall<A, R>(\n\t\tsyscall.target.new({\n\t\t\tpackage: arg.module.value.package,\n\t\t\tmodulePath: arg.module.value.modulePath,\n\t\t\tname: arg.name,\n\t\t\tenv: {},\n\t\t\targs: [],\n\t\t}),\n\t);\n\ttarget.f = arg.f;\n\n\t// Register the target.\n\tlet key = json.encode({ module: arg.module, name: arg.name });\n\tassert_(targets[key] === undefined);\n\ttargets[key] = target;\n\n\treturn target;\n};\n\nexport let entrypoint = async <A extends Array<Value>, R extends Value>(\n\tf: (...args: A) => MaybePromise<R>,\n\tsyscallEnv: Record<string, syscall.Value>,\n\tsyscallArgs: Array<syscall.Value>,\n): Promise<syscall.Value> => {\n\t// Set the env.\n\tenv.value = Object.fromEntries(\n\t\tObject.entries(syscallEnv).map(([key, value]) => [\n\t\t\tkey,\n\t\t\tValue.fromSyscall(value),\n\t\t]),\n\t);\n\n\t// Get the args.\n\tlet args = syscallArgs.map((value) => Value.fromSyscall(value)) as A;\n\n\t// Call the target's function.\n\tlet output = await f(...args);\n\n\t// Get the output.\n\tlet syscallOutput = Value.toSyscall(output);\n\n\treturn syscallOutput;\n};\n\ntype NewArg<A extends Array<Value> = Array<Value>, R extends Value = Value> = {\n\ttarget: Target<A, R>;\n\tenv?: Record<string, Value>;\n\targs?: A;\n};\n\ntype ConstructorArg<\n\tA extends Array<Value> = Array<Value>,\n\tR extends Value = Value,\n> = {\n\tf?: (...args: A) => MaybePromise<R>;\n\tblock: Block;\n\tpackage: Block;\n\tmodulePath: Subpath.Arg;\n\tname: string;\n\tenv?: Record<string, Value>;\n\targs?: A;\n};\n\nexport interface Target<\n\tA extends Array<Value> = Array<Value>,\n\tR extends Value = Value,\n> extends globalThis.Function {\n\t(...args: { [K in keyof A]: Unresolved<A[K]> }): Promise<R>;\n}\n\nexport class Target<\n\tA extends Array<Value> = Array<Value>,\n\tR extends Value = Value,\n> extends globalThis.Function {\n\tf?: (...args: A) => MaybePromise<R>;\n\tblock: Block;\n\tpackage: Block;\n\tmodulePath: Subpath;\n\tname: string;\n\tenv?: Record<string, Value>;\n\targs?: A;\n\n\tstatic new<A extends Array<Value> = Array<Value>, R extends Value = Value>(\n\t\targ: NewArg<A, R>,\n\t): Target<A, R> {\n\t\tlet env_ = Object.fromEntries(\n\t\t\tObject.entries(arg.env ?? {}).map(([key, value]) => [\n\t\t\t\tkey,\n\t\t\t\tValue.toSyscall(value),\n\t\t\t]),\n\t\t);\n\t\tlet args_ = (arg.args ?? []).map((value) => Value.toSyscall(value));\n\t\tlet target = Target.fromSyscall<A, R>(\n\t\t\tsyscall.target.new({\n\t\t\t\tpackage: arg.target.package.toSyscall(),\n\t\t\t\tmodulePath: arg.target.modulePath.toSyscall(),\n\t\t\t\tname: arg.target.name,\n\t\t\t\tenv: env_,\n\t\t\t\targs: args_,\n\t\t\t}),\n\t\t);\n\t\ttarget.f = arg.target.f;\n\t\treturn target;\n\t}\n\n\tconstructor(arg: ConstructorArg<A, R>) {\n\t\tsuper();\n\n\t\tthis.f = arg.f;\n\t\tthis.block = arg.block;\n\t\tthis.package = arg.package;\n\t\tthis.modulePath = subpath(arg.modulePath);\n\t\tthis.name = arg.name;\n\t\tthis.env = arg.env;\n\t\tthis.args = arg.args;\n\n\t\t// Proxy this object so that it is callable.\n\t\treturn new Proxy(this, {\n\t\t\tapply: async (target, _, args) => {\n\t\t\t\tlet target_ = Target.new({\n\t\t\t\t\ttarget,\n\t\t\t\t\targs: (await Promise.all(args.map(resolve))) as A,\n\t\t\t\t\tenv: env.value,\n\t\t\t\t});\n\t\t\t\tlet syscallOutput = await syscall.operation.evaluation(\n\t\t\t\t\tOperation.toSyscall(target_ as Operation),\n\t\t\t\t);\n\t\t\t\tlet output = Value.fromSyscall(syscallOutput) as R;\n\t\t\t\treturn output;\n\t\t\t},\n\t\t});\n\t}\n\n\tstatic is(value: unknown): value is Target {\n\t\treturn value instanceof Target;\n\t}\n\n\tstatic expect(value: unknown): Target {\n\t\tassert_(Target.is(value));\n\t\treturn value;\n\t}\n\n\tstatic assert(value: unknown): asserts value is Target {\n\t\tassert_(Target.is(value));\n\t}\n\n\ttoSyscall(): syscall.Target {\n\t\tlet block = this.block.toSyscall();\n\t\tlet package_ = this.package.toSyscall();\n\t\tlet modulePath = this.modulePath.toString();\n\t\tlet name = this.name;\n\t\tlet env = this.env\n\t\t\t? Object.fromEntries(\n\t\t\t\t\tObject.entries(this.env).map(([key, value]) => [\n\t\t\t\t\t\tkey,\n\t\t\t\t\t\tValue.toSyscall(value),\n\t\t\t\t\t]),\n\t\t\t  )\n\t\t\t: undefined;\n\t\tlet args = this.args\n\t\t\t? this.args.map((arg) => Value.toSyscall(arg))\n\t\t\t: undefined;\n\t\treturn {\n\t\t\tblock,\n\t\t\tpackage: package_,\n\t\t\tmodulePath,\n\t\t\tname,\n\t\t\tenv,\n\t\t\targs,\n\t\t};\n\t}\n\n\tstatic fromSyscall<\n\t\tA extends Array<Value> = Array<Value>,\n\t\tR extends Value = Value,\n\t>(target: syscall.Target): Target<A, R> {\n\t\tlet block = Block.fromSyscall(target.block);\n\t\tlet package_ = Block.fromSyscall(target.package);\n\t\tlet modulePath = target.modulePath;\n\t\tlet name = target.name;\n\t\tlet env =\n\t\t\ttarget.env !== undefined\n\t\t\t\t? Object.fromEntries(\n\t\t\t\t\t\tObject.entries(target.env).map(([key, value]) => [\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tValue.fromSyscall(value),\n\t\t\t\t\t\t]),\n\t\t\t\t  )\n\t\t\t\t: undefined;\n\t\tlet args =\n\t\t\ttarget.args !== undefined\n\t\t\t\t? (target.args.map((arg) => Value.fromSyscall(arg)) as A)\n\t\t\t\t: undefined;\n\t\treturn new Target({\n\t\t\tblock,\n\t\t\tpackage: package_,\n\t\t\tmodulePath,\n\t\t\tname,\n\t\t\tenv,\n\t\t\targs,\n\t\t});\n\t}\n}\n", "import { unreachable } from \"./assert.ts\";\nimport { Resource } from \"./resource.ts\";\nimport * as syscall from \"./syscall.ts\";\nimport { Target } from \"./target.ts\";\nimport { Task } from \"./task.ts\";\n\nexport type Operation = Resource | Target | Task;\n\nexport namespace Operation {\n\texport let is = (value: unknown): value is Operation => {\n\t\treturn (\n\t\t\tvalue instanceof Resource ||\n\t\t\tvalue instanceof Target ||\n\t\t\tvalue instanceof Task\n\t\t);\n\t};\n\n\texport let toSyscall = (operation: Operation): syscall.Operation => {\n\t\tif (operation instanceof Resource) {\n\t\t\treturn {\n\t\t\t\tkind: \"resource\",\n\t\t\t\tvalue: operation.toSyscall(),\n\t\t\t};\n\t\t} else if (operation instanceof Target) {\n\t\t\treturn {\n\t\t\t\tkind: \"target\",\n\t\t\t\tvalue: operation.toSyscall(),\n\t\t\t};\n\t\t} else if (operation instanceof Task) {\n\t\t\treturn {\n\t\t\t\tkind: \"task\",\n\t\t\t\tvalue: operation.toSyscall(),\n\t\t\t};\n\t\t} else {\n\t\t\treturn unreachable();\n\t\t}\n\t};\n\n\texport let fromSyscall = (operation: syscall.Operation): Operation => {\n\t\tswitch (operation.kind) {\n\t\t\tcase \"resource\": {\n\t\t\t\treturn Resource.fromSyscall(operation.value);\n\t\t\t}\n\t\t\tcase \"target\": {\n\t\t\t\treturn Target.fromSyscall(operation.value);\n\t\t\t}\n\t\t\tcase \"task\": {\n\t\t\t\treturn Task.fromSyscall(operation.value);\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\treturn unreachable();\n\t\t\t}\n\t\t}\n\t};\n}\n", "import { Artifact } from \"./artifact.ts\";\nimport { assert as assert_ } from \"./assert.ts\";\nimport { Block } from \"./block.ts\";\nimport { Checksum } from \"./checksum.ts\";\nimport { Operation } from \"./operation.ts\";\nimport * as syscall from \"./syscall.ts\";\nimport { Value } from \"./value.ts\";\n\nexport let resource = async (arg: Resource.Arg): Promise<Resource> => {\n\treturn await Resource.new(arg);\n};\n\nexport let download = async (arg: Resource.Arg): Promise<Artifact> => {\n\tlet resource = await Resource.new(arg);\n\tlet output = await resource.download();\n\treturn output;\n};\n\ntype ConstructorArg = {\n\tblock: Block;\n\turl: string;\n\tunpack?: Resource.UnpackFormat;\n\tchecksum?: Checksum;\n\tunsafe?: boolean;\n};\n\nexport class Resource {\n\t#block: Block;\n\t#url: string;\n\t#unpack?: Resource.UnpackFormat;\n\t#checksum?: Checksum;\n\t#unsafe: boolean;\n\n\tstatic async new(arg: Resource.Arg): Promise<Resource> {\n\t\treturn Resource.fromSyscall(\n\t\t\tsyscall.resource.new({\n\t\t\t\turl: arg.url,\n\t\t\t\tunpack: arg.unpack ?? undefined,\n\t\t\t\tchecksum: arg.checksum ?? undefined,\n\t\t\t\tunsafe: arg.unsafe ?? false,\n\t\t\t}),\n\t\t);\n\t}\n\n\tconstructor(arg: ConstructorArg) {\n\t\tthis.#block = arg.block;\n\t\tthis.#url = arg.url;\n\t\tthis.#unpack = arg.unpack ?? undefined;\n\t\tthis.#checksum = arg.checksum ?? undefined;\n\t\tthis.#unsafe = arg.unsafe ?? false;\n\t}\n\n\tstatic is(value: unknown): value is Resource {\n\t\treturn value instanceof Resource;\n\t}\n\n\tstatic expect(value: unknown): Resource {\n\t\tassert_(Resource.is(value));\n\t\treturn value;\n\t}\n\n\tstatic assert(value: unknown): asserts value is Resource {\n\t\tassert_(Resource.is(value));\n\t}\n\n\tblock(): Block {\n\t\treturn this.#block;\n\t}\n\n\ttoSyscall(): syscall.Resource {\n\t\treturn {\n\t\t\tblock: this.#block.toSyscall(),\n\t\t\turl: this.#url,\n\t\t\tunpack: this.#unpack,\n\t\t\tchecksum: this.#checksum,\n\t\t\tunsafe: this.#unsafe,\n\t\t};\n\t}\n\n\tstatic fromSyscall(download: syscall.Resource): Resource {\n\t\treturn new Resource({\n\t\t\tblock: Block.fromSyscall(download.block),\n\t\t\turl: download.url,\n\t\t\tunpack: download.unpack,\n\t\t\tchecksum: download.checksum,\n\t\t\tunsafe: download.unsafe,\n\t\t});\n\t}\n\n\tasync download(): Promise<Artifact> {\n\t\tlet outputFromSyscall = await syscall.operation.evaluation(\n\t\t\tOperation.toSyscall(this),\n\t\t);\n\t\tlet output = Value.fromSyscall(outputFromSyscall);\n\t\treturn output as Artifact;\n\t}\n}\n\nexport namespace Resource {\n\texport type Arg = {\n\t\turl: string;\n\t\tunpack?: UnpackFormat;\n\t\tchecksum?: Checksum;\n\t\tunsafe?: boolean;\n\t};\n\n\texport type UnpackFormat =\n\t\t| \".tar\"\n\t\t| \".tar.bz2\"\n\t\t| \".tar.gz\"\n\t\t| \".tar.lz\"\n\t\t| \".tar.xz\"\n\t\t| \".tar.zstd\"\n\t\t| \".zip\";\n}\n", "import { Artifact } from \"./artifact.ts\";\nimport { Blob } from \"./blob.ts\";\nimport { Block } from \"./block.ts\";\nimport { Directory } from \"./directory.ts\";\nimport { File } from \"./file.ts\";\nimport { Operation } from \"./operation.ts\";\nimport { Relpath, Subpath } from \"./path.ts\";\nimport { Placeholder } from \"./placeholder.ts\";\nimport { Resource } from \"./resource.ts\";\nimport { Symlink } from \"./symlink.ts\";\nimport { Target } from \"./target.ts\";\nimport { Task } from \"./task.ts\";\nimport { Template } from \"./template.ts\";\nimport { Value } from \"./value.ts\";\n\nexport type Unresolved<T extends Value> = MaybePromise<\n\tT extends\n\t\t| undefined\n\t\t| boolean\n\t\t| number\n\t\t| string\n\t\t| Uint8Array\n\t\t| Relpath\n\t\t| Subpath\n\t\t| Blob\n\t\t| Block\n\t\t| Artifact\n\t\t| Placeholder\n\t\t| Template\n\t\t| Operation\n\t\t? T\n\t\t: T extends Array<infer U extends Value>\n\t\t? Array<Unresolved<U>>\n\t\t: T extends { [key: string]: Value }\n\t\t? { [K in keyof T]: Unresolved<T[K]> }\n\t\t: never\n>;\n\nexport type Resolved<T extends Unresolved<Value>> = T extends\n\t| undefined\n\t| boolean\n\t| number\n\t| string\n\t| Uint8Array\n\t| Relpath\n\t| Subpath\n\t| Blob\n\t| Block\n\t| Artifact\n\t| Placeholder\n\t| Template\n\t| Operation\n\t? T\n\t: T extends Promise<infer U extends Unresolved<Value>>\n\t? Resolved<U>\n\t: T extends Array<infer U extends Unresolved<Value>>\n\t? Array<Resolved<U>>\n\t: T extends { [key: string]: Unresolved<Value> }\n\t? { [K in keyof T]: Resolved<T[K]> }\n\t: never;\n\nexport type MaybePromise<T> = T | Promise<T>;\n\nexport let resolve = async <T extends Unresolved<Value>>(\n\tvalue: T,\n): Promise<Resolved<T>> => {\n\tvalue = await value;\n\tif (\n\t\tvalue === undefined ||\n\t\ttypeof value === \"boolean\" ||\n\t\ttypeof value === \"number\" ||\n\t\ttypeof value === \"string\" ||\n\t\tvalue instanceof Uint8Array ||\n\t\tvalue instanceof Relpath ||\n\t\tvalue instanceof Subpath ||\n\t\tvalue instanceof Blob ||\n\t\tvalue instanceof Directory ||\n\t\tvalue instanceof File ||\n\t\tvalue instanceof Symlink ||\n\t\tvalue instanceof Placeholder ||\n\t\tvalue instanceof Template ||\n\t\tvalue instanceof Resource ||\n\t\tvalue instanceof Target ||\n\t\tvalue instanceof Task\n\t) {\n\t\treturn value as unknown as Resolved<T>;\n\t} else if (value instanceof Array) {\n\t\treturn (await Promise.all(\n\t\t\tvalue.map((value) => resolve(value)),\n\t\t)) as Resolved<T>;\n\t} else if (typeof value === \"object\") {\n\t\treturn Object.fromEntries(\n\t\t\tawait Promise.all(\n\t\t\t\tObject.entries(value).map(async ([key, value]) => [\n\t\t\t\t\tkey,\n\t\t\t\t\tawait resolve(value),\n\t\t\t\t]),\n\t\t\t),\n\t\t) as Resolved<T>;\n\t} else {\n\t\tthrow new Error(\"Invalid value to resolve.\");\n\t}\n};\n", "import { assert as assert_, unreachable } from \"./assert.ts\";\nimport * as encoding from \"./encoding.ts\";\nimport { Id } from \"./id.ts\";\nimport { Unresolved, resolve } from \"./resolve.ts\";\nimport * as syscall from \"./syscall.ts\";\nimport { MaybeNestedArray, flatten } from \"./util.ts\";\n\nexport let block = async (...args: Array<Unresolved<Block.Arg>>) => {\n\treturn await Block.new(...args);\n};\n\ntype ConstructorArg = {\n\tid: Id;\n};\n\nexport class Block {\n\t#id: Id;\n\n\tstatic async new(...args: Array<Unresolved<Block.Arg>>): Promise<Block> {\n\t\t// Collect the children and data from the args.\n\t\tlet { children, data: dataEntries } = flatten(\n\t\t\tawait Promise.all(\n\t\t\t\targs.map(async function map(unresolvedArg): Promise<\n\t\t\t\t\tMaybeNestedArray<{\n\t\t\t\t\t\tchildren?: Array<Block>;\n\t\t\t\t\t\tdata?: Array<Uint8Array>;\n\t\t\t\t\t}>\n\t\t\t\t> {\n\t\t\t\t\tlet arg = await resolve(unresolvedArg);\n\t\t\t\t\tif (arg === undefined) {\n\t\t\t\t\t\treturn {};\n\t\t\t\t\t} else if (typeof arg === \"string\") {\n\t\t\t\t\t\treturn { data: [encoding.utf8.encode(arg)] };\n\t\t\t\t\t} else if (arg instanceof Uint8Array) {\n\t\t\t\t\t\treturn { data: [arg] };\n\t\t\t\t\t} else if (arg instanceof Block) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tchildren: await arg.children(),\n\t\t\t\t\t\t\tdata: [await arg.bytes()],\n\t\t\t\t\t\t};\n\t\t\t\t\t} else if (arg instanceof Array) {\n\t\t\t\t\t\treturn await Promise.all(arg.map(map));\n\t\t\t\t\t} else if (typeof arg === \"object\") {\n\t\t\t\t\t\tlet children = await Promise.all(\n\t\t\t\t\t\t\t(arg.children ?? []).map((child) => Block.new(child)),\n\t\t\t\t\t\t);\n\t\t\t\t\t\tlet data =\n\t\t\t\t\t\t\ttypeof arg.data === \"string\"\n\t\t\t\t\t\t\t\t? [encoding.utf8.encode(arg.data)]\n\t\t\t\t\t\t\t\t: arg.data instanceof Uint8Array\n\t\t\t\t\t\t\t\t? [arg.data]\n\t\t\t\t\t\t\t\t: [];\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tchildren,\n\t\t\t\t\t\t\tdata,\n\t\t\t\t\t\t};\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn unreachable();\n\t\t\t\t\t}\n\t\t\t\t}),\n\t\t\t),\n\t\t).reduce<{\n\t\t\tchildren: Array<Block>;\n\t\t\tdata: Array<Uint8Array>;\n\t\t}>(\n\t\t\t(value, { children, data }) => {\n\t\t\t\tif (children !== undefined) {\n\t\t\t\t\tvalue.children.push(...children);\n\t\t\t\t}\n\t\t\t\tif (data !== undefined) {\n\t\t\t\t\tvalue.data.push(...data);\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t},\n\t\t\t{ children: [], data: [] },\n\t\t);\n\n\t\t// Collect the data entries.\n\t\tlet length = dataEntries.reduce(\n\t\t\t(length, dataEntry) => length + dataEntry.length,\n\t\t\t0,\n\t\t);\n\t\tlet data = new Uint8Array(length);\n\t\tlet position = 0;\n\t\tfor (let dataEntry of dataEntries) {\n\t\t\tdata.set(dataEntry, position);\n\t\t\tposition += dataEntry.length;\n\t\t}\n\n\t\treturn Block.fromSyscall(\n\t\t\tawait syscall.block.new({\n\t\t\t\tdata,\n\t\t\t\tchildren: children.map((block) => block.toSyscall()),\n\t\t\t}),\n\t\t);\n\t}\n\n\tconstructor(arg: ConstructorArg) {\n\t\tthis.#id = arg.id;\n\t}\n\n\tstatic is(value: unknown): value is Block {\n\t\treturn value instanceof Block;\n\t}\n\n\tstatic expect(value: unknown): Block {\n\t\tassert_(Block.is(value));\n\t\treturn value;\n\t}\n\n\tstatic assert(value: unknown): asserts value is Block {\n\t\tassert_(Block.is(value));\n\t}\n\n\ttoSyscall(): syscall.Block {\n\t\treturn {\n\t\t\tid: this.#id,\n\t\t};\n\t}\n\n\tstatic fromSyscall(value: syscall.Block): Block {\n\t\tlet id = value.id;\n\t\treturn new Block({ id });\n\t}\n\n\tid(): Id {\n\t\treturn this.#id;\n\t}\n\n\tasync bytes(): Promise<Uint8Array> {\n\t\treturn await syscall.block.bytes(this.toSyscall());\n\t}\n\n\tasync children(): Promise<Array<Block>> {\n\t\treturn (await syscall.block.children(this.toSyscall())).map((block) =>\n\t\t\tBlock.fromSyscall(block),\n\t\t);\n\t}\n\n\tasync data(): Promise<Uint8Array> {\n\t\treturn await syscall.block.data(this.toSyscall());\n\t}\n}\n\nexport namespace Block {\n\texport type Arg =\n\t\t| undefined\n\t\t| string\n\t\t| Uint8Array\n\t\t| Block\n\t\t| Array<Arg>\n\t\t| ArgObject;\n\n\texport type ArgObject = {\n\t\tchildren?: Array<Arg>;\n\t\tdata?: string | Uint8Array;\n\t};\n\n\texport namespace Arg {\n\t\texport let is = (value: unknown): value is Arg => {\n\t\t\treturn (\n\t\t\t\tvalue === undefined ||\n\t\t\t\ttypeof value === \"string\" ||\n\t\t\t\tvalue instanceof Uint8Array ||\n\t\t\t\tvalue instanceof Block ||\n\t\t\t\t(value instanceof Array && value.every(Arg.is))\n\t\t\t);\n\t\t};\n\n\t\texport let expect = (value: unknown): Arg => {\n\t\t\tassert_(is(value));\n\t\t\treturn value;\n\t\t};\n\n\t\texport let assert = (value: unknown): asserts value is Arg => {\n\t\t\tassert_(is(value));\n\t\t};\n\t}\n}\n", "import { assert as assert_, unreachable } from \"./assert.ts\";\nimport { Block, block } from \"./block.ts\";\nimport { Unresolved, resolve } from \"./resolve.ts\";\nimport * as syscall from \"./syscall.ts\";\nimport { MaybeNestedArray, flatten } from \"./util.ts\";\n\nexport let blob = async (...args: Array<Unresolved<Blob.Arg>>) => {\n\treturn await Blob.new(...args);\n};\n\ntype ConstructorArg = {\n\tblock: Block;\n\tkind: syscall.Blob.Kind;\n};\n\nexport class Blob {\n\t#block: Block;\n\t#kind: syscall.Blob.Kind;\n\n\tstatic async get(block: Block): Promise<Blob> {\n\t\treturn Blob.fromSyscall(await syscall.blob.get(block.toSyscall()));\n\t}\n\n\tstatic async new(...args: Array<Unresolved<Blob.Arg>>): Promise<Blob> {\n\t\tlet blocks = flatten(\n\t\t\tawait Promise.all(\n\t\t\t\targs.map(async function map(\n\t\t\t\t\tunresolvedArg: Unresolved<Blob.Arg>,\n\t\t\t\t): Promise<MaybeNestedArray<Block>> {\n\t\t\t\t\tlet arg = await resolve(unresolvedArg);\n\t\t\t\t\tif (Block.Arg.is(arg)) {\n\t\t\t\t\t\treturn await block(arg);\n\t\t\t\t\t} else if (arg instanceof Blob) {\n\t\t\t\t\t\treturn arg.block();\n\t\t\t\t\t} else if (arg instanceof Array) {\n\t\t\t\t\t\treturn await Promise.all(arg.map(map));\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn unreachable();\n\t\t\t\t\t}\n\t\t\t\t}),\n\t\t\t),\n\t\t).reduce<Array<Block>>((blocks, block) => {\n\t\t\tblocks.push(block);\n\t\t\treturn blocks;\n\t\t}, []);\n\t\treturn Blob.fromSyscall(\n\t\t\tawait syscall.blob.new({\n\t\t\t\tchildren: blocks.map((block) => block.toSyscall()),\n\t\t\t}),\n\t\t);\n\t}\n\n\tconstructor(arg: ConstructorArg) {\n\t\tthis.#block = arg.block;\n\t\tthis.#kind = arg.kind;\n\t}\n\n\tstatic is(value: unknown): value is Blob {\n\t\treturn value instanceof Blob;\n\t}\n\n\tstatic expect(value: unknown): Blob {\n\t\tassert_(Blob.is(value));\n\t\treturn value;\n\t}\n\n\tstatic assert(value: unknown): asserts value is Blob {\n\t\tassert_(Blob.is(value));\n\t}\n\n\ttoSyscall(): syscall.Blob {\n\t\treturn {\n\t\t\tblock: this.#block.toSyscall(),\n\t\t\tkind: this.#kind,\n\t\t};\n\t}\n\n\tstatic fromSyscall(value: syscall.Blob): Blob {\n\t\tlet block = Block.fromSyscall(value.block);\n\t\tlet kind = value.kind;\n\t\treturn new Blob({ block, kind });\n\t}\n\n\tblock(): Block {\n\t\treturn this.#block;\n\t}\n\n\tasync bytes(): Promise<Uint8Array> {\n\t\treturn await syscall.blob.bytes(this.toSyscall());\n\t}\n\n\tasync text(): Promise<string> {\n\t\treturn await syscall.blob.text(this.toSyscall());\n\t}\n}\n\nexport namespace Blob {\n\texport type Arg = Block.Arg | Blob | Array<Arg>;\n\n\texport namespace Arg {\n\t\texport let is = (value: unknown): value is Arg => {\n\t\t\treturn (\n\t\t\t\tBlock.Arg.is(value) ||\n\t\t\t\tvalue instanceof Blob ||\n\t\t\t\t(value instanceof Array && value.every(Arg.is))\n\t\t\t);\n\t\t};\n\n\t\texport let expect = (value: unknown): Arg => {\n\t\t\tassert_(is(value));\n\t\t\treturn value;\n\t\t};\n\n\t\texport let assert = (value: unknown): asserts value is Arg => {\n\t\t\tassert_(is(value));\n\t\t};\n\t}\n}\n", "import { Artifact } from \"./artifact.ts\";\nimport { assert as assert_, unreachable } from \"./assert.ts\";\nimport { Blob } from \"./blob.ts\";\nimport { Block } from \"./block.ts\";\nimport { File, file } from \"./file.ts\";\nimport { Subpath, subpath } from \"./path.ts\";\nimport { Unresolved, resolve } from \"./resolve.ts\";\nimport { Symlink } from \"./symlink.ts\";\nimport * as syscall from \"./syscall.ts\";\n\nexport let directory = async (...args: Array<Unresolved<Directory.Arg>>) => {\n\treturn await Directory.new(...args);\n};\n\ntype ConstructorArg = {\n\tblock: Block;\n\tentries: Record<string, Block>;\n};\n\nexport class Directory {\n\t#block: Block;\n\t#entries: Record<string, Block>;\n\n\tstatic async new(\n\t\t...args: Array<Unresolved<Directory.Arg>>\n\t): Promise<Directory> {\n\t\tlet entries = await (\n\t\t\tawait Promise.all(args.map(resolve))\n\t\t).reduce<Promise<Record<string, Artifact>>>(async function reduce(\n\t\t\tpromiseEntries,\n\t\t\targ,\n\t\t) {\n\t\t\tlet entries = await promiseEntries;\n\t\t\tif (arg === undefined) {\n\t\t\t\t// If the arg is undefined, then continue.\n\t\t\t} else if (arg instanceof Directory) {\n\t\t\t\t// If the arg is a directory, then apply each entry.\n\t\t\t\tfor (let [name, entry] of Object.entries(await arg.entries())) {\n\t\t\t\t\t// Get an existing entry.\n\t\t\t\t\tlet existingEntry = entries[name];\n\n\t\t\t\t\t// Merge the existing entry with the entry if they are both directories.\n\t\t\t\t\tif (\n\t\t\t\t\t\texistingEntry instanceof Directory &&\n\t\t\t\t\t\tentry instanceof Directory\n\t\t\t\t\t) {\n\t\t\t\t\t\tentry = await Directory.new(existingEntry, entry);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Set the entry.\n\t\t\t\t\tentries[name] = entry;\n\t\t\t\t}\n\t\t\t} else if (arg instanceof Array) {\n\t\t\t\tfor (let argEntry of arg) {\n\t\t\t\t\tentries = await reduce(Promise.resolve(entries), argEntry);\n\t\t\t\t}\n\t\t\t} else if (typeof arg === \"object\") {\n\t\t\t\t// If the arg is an object, then apply each entry.\n\t\t\t\tfor (let [key, value] of Object.entries(arg)) {\n\t\t\t\t\t// Separate the first path component from the trailing path components.\n\t\t\t\t\tlet [firstComponent, ...trailingComponents] =\n\t\t\t\t\t\tsubpath(key).components();\n\t\t\t\t\tif (firstComponent === undefined) {\n\t\t\t\t\t\tthrow new Error(\"The path must have at least one component.\");\n\t\t\t\t\t}\n\t\t\t\t\tlet name = firstComponent;\n\n\t\t\t\t\t// Get an existing entry.\n\t\t\t\t\tlet existingEntry = entries[name];\n\n\t\t\t\t\t// Remove the entry if it is not a directory.\n\t\t\t\t\tif (!(existingEntry instanceof Directory)) {\n\t\t\t\t\t\texistingEntry = undefined;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (trailingComponents.length > 0) {\n\t\t\t\t\t\t// If there are trailing path components, then recurse.\n\t\t\t\t\t\tlet trailingPath = subpath(trailingComponents).toString();\n\n\t\t\t\t\t\t// Merge the entry with the trailing path.\n\t\t\t\t\t\tlet newEntry = await Directory.new(existingEntry, {\n\t\t\t\t\t\t\t[trailingPath]: value,\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\t// Add the entry.\n\t\t\t\t\t\tentries[name] = newEntry;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// If there are no trailing path components, then create the artifact specified by the value.\n\t\t\t\t\t\tif (value === undefined) {\n\t\t\t\t\t\t\tdelete entries[name];\n\t\t\t\t\t\t} else if (Blob.Arg.is(value)) {\n\t\t\t\t\t\t\tlet newEntry = await file(value);\n\t\t\t\t\t\t\tentries[name] = newEntry;\n\t\t\t\t\t\t} else if (File.is(value) || Symlink.is(value)) {\n\t\t\t\t\t\t\tentries[name] = value;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlet newEntry = await Directory.new(existingEntry, value);\n\t\t\t\t\t\t\tentries[name] = newEntry;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn unreachable();\n\t\t\t}\n\t\t\treturn entries;\n\t\t},\n\t\tPromise.resolve({}));\n\t\treturn Directory.fromSyscall(\n\t\t\tsyscall.directory.new({\n\t\t\t\tentries: Object.fromEntries(\n\t\t\t\t\tObject.entries(entries).map(([name, entry]) => [\n\t\t\t\t\t\tname,\n\t\t\t\t\t\tArtifact.toSyscall(entry),\n\t\t\t\t\t]),\n\t\t\t\t),\n\t\t\t}),\n\t\t);\n\t}\n\n\tconstructor(arg: ConstructorArg) {\n\t\tthis.#block = arg.block;\n\t\tthis.#entries = arg.entries;\n\t}\n\n\tstatic is(value: unknown): value is Directory {\n\t\treturn value instanceof Directory;\n\t}\n\n\tstatic expect(value: unknown): Directory {\n\t\tassert_(Directory.is(value));\n\t\treturn value;\n\t}\n\n\tstatic assert(value: unknown): asserts value is Directory {\n\t\tassert_(Directory.is(value));\n\t}\n\n\ttoSyscall(): syscall.Directory {\n\t\tlet block = this.#block.toSyscall();\n\t\tlet entries = Object.fromEntries(\n\t\t\tObject.entries(this.#entries).map(([name, entry]) => [\n\t\t\t\tname,\n\t\t\t\tentry.toSyscall(),\n\t\t\t]),\n\t\t);\n\t\treturn {\n\t\t\tblock,\n\t\t\tentries,\n\t\t};\n\t}\n\n\tstatic fromSyscall(directory: syscall.Directory): Directory {\n\t\tlet block = Block.fromSyscall(directory.block);\n\t\tlet entries = Object.fromEntries(\n\t\t\tObject.entries(directory.entries).map(([name, entry]) => [\n\t\t\t\tname,\n\t\t\t\tBlock.fromSyscall(entry),\n\t\t\t]),\n\t\t);\n\t\treturn new Directory({ block, entries });\n\t}\n\n\tblock(): Block {\n\t\treturn this.#block;\n\t}\n\n\tasync get(arg: Subpath.Arg): Promise<Directory | File> {\n\t\tlet artifact = await this.tryGet(arg);\n\t\tassert_(artifact, `Failed to get the directory entry \"${arg}\".`);\n\t\treturn artifact;\n\t}\n\n\tasync tryGet(arg: Subpath.Arg): Promise<Directory | File | undefined> {\n\t\tlet artifact: Directory | File = this;\n\t\tlet currentSubpath = subpath();\n\t\targ = subpath(arg);\n\t\tfor (let component of arg.components()) {\n\t\t\tif (!(artifact instanceof Directory)) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\tcurrentSubpath.push(component);\n\t\t\tlet entryBlock = artifact.#entries[component];\n\t\t\tif (entryBlock === undefined) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\tlet entry = await Artifact.get(entryBlock);\n\t\t\tif (entry instanceof Symlink) {\n\t\t\t\tlet resolved = await entry.resolve({\n\t\t\t\t\tartifact: this,\n\t\t\t\t\tpath: currentSubpath,\n\t\t\t\t});\n\t\t\t\tif (resolved === undefined) {\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\t\t\t\tartifact = resolved;\n\t\t\t} else {\n\t\t\t\tartifact = entry;\n\t\t\t}\n\t\t}\n\t\treturn artifact;\n\t}\n\n\tasync entries(): Promise<Record<string, Artifact>> {\n\t\tlet entries: Record<string, Artifact> = {};\n\t\tfor await (let [name, artifact] of this) {\n\t\t\tentries[name] = artifact;\n\t\t}\n\t\treturn entries;\n\t}\n\n\tasync bundle(): Promise<Directory> {\n\t\tlet bundledArtifact = Artifact.fromSyscall(\n\t\t\tawait syscall.artifact.bundle(Artifact.toSyscall(this)),\n\t\t);\n\t\tassert_(Directory.is(bundledArtifact));\n\t\treturn bundledArtifact;\n\t}\n\n\tasync *walk(): AsyncIterableIterator<[Subpath, Artifact]> {\n\t\tfor await (let [name, artifact] of this) {\n\t\t\tyield [subpath(name), artifact];\n\t\t\tif (Directory.is(artifact)) {\n\t\t\t\tfor await (let [entryName, entryArtifact] of artifact.walk()) {\n\t\t\t\t\tyield [subpath(name).join(entryName), entryArtifact];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t*[Symbol.iterator](): Iterator<[string, Block]> {\n\t\tfor (let [name, entry] of Object.entries(this.#entries)) {\n\t\t\tyield [name, entry];\n\t\t}\n\t}\n\n\tasync *[Symbol.asyncIterator](): AsyncIterator<[string, Artifact]> {\n\t\tfor (let [name, entry] of this) {\n\t\t\tyield [name, await Artifact.get(entry)];\n\t\t}\n\t}\n}\n\nexport namespace Directory {\n\texport type Arg = undefined | Directory | Array<Arg> | ArgObject;\n\n\texport type ArgObject = { [name: string]: ArgObjectValue };\n\n\texport type ArgObjectValue = undefined | Blob.Arg | Artifact | ArgObject;\n}\n", "import { assert as assert_, unreachable } from \"./assert.ts\";\nimport { Block } from \"./block.ts\";\nimport { Directory } from \"./directory.ts\";\nimport { File } from \"./file.ts\";\nimport { Symlink } from \"./symlink.ts\";\nimport * as syscall from \"./syscall.ts\";\n\nexport type Artifact = Directory | File | Symlink;\n\nexport namespace Artifact {\n\texport let is = (value: unknown): value is Artifact => {\n\t\treturn (\n\t\t\tvalue instanceof Directory ||\n\t\t\tvalue instanceof File ||\n\t\t\tvalue instanceof Symlink\n\t\t);\n\t};\n\n\texport let expect = (value: unknown): Artifact => {\n\t\tassert_(is(value));\n\t\treturn value;\n\t};\n\n\texport let assert = (value: unknown): asserts value is Artifact => {\n\t\tassert_(is(value));\n\t};\n\n\texport let get = async (block: Block): Promise<Artifact> => {\n\t\treturn Artifact.fromSyscall(await syscall.artifact.get(block.toSyscall()));\n\t};\n\n\texport let toSyscall = (artifact: Artifact): syscall.Artifact => {\n\t\tif (artifact instanceof Directory) {\n\t\t\treturn {\n\t\t\t\tkind: \"directory\",\n\t\t\t\tvalue: artifact.toSyscall(),\n\t\t\t};\n\t\t} else if (artifact instanceof File) {\n\t\t\treturn {\n\t\t\t\tkind: \"file\",\n\t\t\t\tvalue: artifact.toSyscall(),\n\t\t\t};\n\t\t} else if (artifact instanceof Symlink) {\n\t\t\treturn {\n\t\t\t\tkind: \"symlink\",\n\t\t\t\tvalue: artifact.toSyscall(),\n\t\t\t};\n\t\t} else {\n\t\t\treturn unreachable();\n\t\t}\n\t};\n\n\texport let fromSyscall = (artifact: syscall.Artifact): Artifact => {\n\t\tswitch (artifact.kind) {\n\t\t\tcase \"directory\": {\n\t\t\t\treturn Directory.fromSyscall(artifact.value);\n\t\t\t}\n\t\t\tcase \"file\": {\n\t\t\t\treturn File.fromSyscall(artifact.value);\n\t\t\t}\n\t\t\tcase \"symlink\": {\n\t\t\t\treturn Symlink.fromSyscall(artifact.value);\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\treturn unreachable();\n\t\t\t}\n\t\t}\n\t};\n}\n", "export let prepareStackTrace = (\n\t_error: unknown,\n\tstructuredStackTrace: Array<CallSite>,\n) => {\n\tlet callSites = structuredStackTrace.map((callSite) => {\n\t\treturn {\n\t\t\ttypeName: callSite.getTypeName(),\n\t\t\tfunctionName: callSite.getFunctionName(),\n\t\t\tmethodName: callSite.getMethodName(),\n\t\t\tfileName: callSite.getFileName(),\n\t\t\tlineNumber: callSite.getLineNumber(),\n\t\t\tcolumnNumber: callSite.getColumnNumber(),\n\t\t\tisEval: callSite.isEval(),\n\t\t\tisNative: callSite.isNative(),\n\t\t\tisConstructor: callSite.isConstructor(),\n\t\t\tisAsync: callSite.isAsync(),\n\t\t\tisPromiseAll: callSite.isPromiseAll(),\n\t\t\t// isPromiseAny: callSite.isPromiseAny(),\n\t\t\tpromiseIndex: callSite.getPromiseIndex(),\n\t\t};\n\t});\n\treturn { callSites };\n};\n\n/** This type is derived from <https://v8.dev/docs/stack-trace-api#customizing-stack-traces>. */\ntype CallSite = {\n\t/** Returns the type of this as a string. This is the name of the function stored in the constructor field of this, if available, otherwise the object\u2019s [[Class]] internal property. **/\n\tgetTypeName(): string;\n\n\t/** Returns the name of the current function, typically its name property. If a name property is not available an attempt is made to infer a name from the function\u2019s context. **/\n\tgetFunctionName(): string;\n\n\t/** Returns the name of the property of this or one of its prototypes that holds the current function. **/\n\tgetMethodName(): string;\n\n\t/** If this function was defined in a script returns the name of the script. **/\n\tgetFileName(): string | undefined;\n\n\t/** If this function was defined in a script returns the current line number. **/\n\tgetLineNumber(): number | undefined;\n\n\t/** If this function was defined in a script returns the current column number. **/\n\tgetColumnNumber(): number | undefined;\n\n\t/** If this function was created using a call to eval returns a string representing the location where eval was called. **/\n\tgetEvalOrigin(): unknown | undefined;\n\n\t/** does this call take place in code defined by a call to eval? **/\n\tisEval(): boolean;\n\n\t/** is this call in native V8 code? **/\n\tisNative(): boolean;\n\n\t/** is this a constructor call? **/\n\tisConstructor(): boolean;\n\n\t/** Is this an async call (i.e. await, Promise.all(), or Promise.any())? **/\n\tisAsync(): boolean;\n\n\t/** Is this an async call to Promise.all()? **/\n\tisPromiseAll(): boolean;\n\n\t// /** Is this an async call to Promise.any()? **/\n\t// isPromiseAny(): boolean;\n\n\t/** Returns the index of the promise element that was followed in Promise.all() or Promise.any() for async stack traces, or null if the CallSite is not an async Promise.all() or Promise.any() call. **/\n\tgetPromiseIndex(): number | null;\n};\n", "import { Artifact } from \"./artifact.ts\";\nimport { assert } from \"./assert.ts\";\nimport { Block } from \"./block.ts\";\nimport { Directory } from \"./directory.ts\";\nimport { Relpath, subpath } from \"./path.ts\";\nimport * as syscall from \"./syscall.ts\";\n\ntype Arg = {\n\tmodule: syscall.Module;\n\tpath: Relpath.Arg;\n};\n\nexport let include = async (arg: Arg): Promise<Artifact> => {\n\tassert(arg.module.kind === \"normal\");\n\tlet artifact = await Artifact.get(\n\t\tBlock.fromSyscall(arg.module.value.package),\n\t);\n\tDirectory.assert(artifact);\n\tlet path = subpath(arg.module.value.modulePath)\n\t\t.toRelpath()\n\t\t.parent()\n\t\t.join(arg.path)\n\t\t.toSubpath();\n\tlet includedArtifact = artifact.get(path);\n\treturn includedArtifact;\n};\n", "import { Blob } from \"./blob.ts\";\nimport { Block } from \"./block.ts\";\nimport { Directory } from \"./directory.ts\";\nimport { File } from \"./file.ts\";\nimport { Relpath, Subpath } from \"./path.ts\";\nimport { Placeholder } from \"./placeholder.ts\";\nimport { Resource } from \"./resource.ts\";\nimport { Symlink } from \"./symlink.ts\";\nimport * as syscall from \"./syscall.ts\";\nimport { Target } from \"./target.ts\";\nimport { Task } from \"./task.ts\";\nimport { Template } from \"./template.ts\";\n\n/** Write to the log. */\nexport let log = (...args: Array<unknown>) => {\n\tlet string = args.map((arg) => stringify(arg)).join(\" \");\n\tsyscall.log(string);\n};\n\nlet stringify = (value: unknown): string => {\n\treturn stringifyInner(value, new WeakSet());\n};\n\nlet stringifyInner = (value: unknown, visited: WeakSet<object>): string => {\n\tswitch (typeof value) {\n\t\tcase \"string\": {\n\t\t\treturn `\"${value}\"`;\n\t\t}\n\t\tcase \"number\": {\n\t\t\treturn value.toString();\n\t\t}\n\t\tcase \"boolean\": {\n\t\t\treturn value ? \"true\" : \"false\";\n\t\t}\n\t\tcase \"undefined\": {\n\t\t\treturn \"undefined\";\n\t\t}\n\t\tcase \"object\": {\n\t\t\tif (value === null) {\n\t\t\t\treturn \"null\";\n\t\t\t} else {\n\t\t\t\treturn stringifyObject(value, visited);\n\t\t\t}\n\t\t}\n\t\tcase \"function\": {\n\t\t\treturn `(function \"${value.name ?? \"(anonymous)\"}\")`;\n\t\t}\n\t\tcase \"symbol\": {\n\t\t\treturn \"(symbol)\";\n\t\t}\n\t\tcase \"bigint\": {\n\t\t\treturn value.toString();\n\t\t}\n\t}\n};\n\nlet stringifyObject = (value: object, visited: WeakSet<object>): string => {\n\t// If the value is in the visited set, then indicate that this is a circular reference.\n\tif (visited.has(value)) {\n\t\treturn \"(circular)\";\n\t}\n\n\t// Add the value to the visited set.\n\tvisited.add(value);\n\n\tif (value instanceof Array) {\n\t\t// Handle an array.\n\t\treturn `[${value\n\t\t\t.map((value) => stringifyInner(value, visited))\n\t\t\t.join(\", \")}]`;\n\t} else if (value instanceof Error) {\n\t\t// Handle an error.\n\t\treturn value.stack ?? \"\";\n\t} else if (value instanceof Promise) {\n\t\t// Handle a promise.\n\t\treturn \"(promise)\";\n\t} else if (value instanceof Relpath) {\n\t\treturn `(tg.relpath ${value.toString()})`;\n\t} else if (value instanceof Subpath) {\n\t\treturn `(tg.subpath ${value.toString()})`;\n\t} else if (value instanceof Blob) {\n\t\treturn `(tg.blob ${value.block().id()})`;\n\t} else if (value instanceof Block) {\n\t\treturn `(tg.block ${value.id()})`;\n\t} else if (value instanceof Directory) {\n\t\treturn `(tg.directory ${value.block().id()})`;\n\t} else if (value instanceof File) {\n\t\treturn `(tg.file ${value.block().id()})`;\n\t} else if (value instanceof Symlink) {\n\t\treturn `(tg.symlink ${value.block().id()})`;\n\t} else if (value instanceof Placeholder) {\n\t\treturn `(tg.placeholder \"${value.name()}\")`;\n\t} else if (value instanceof Template) {\n\t\tlet string = value\n\t\t\t.components()\n\t\t\t.map((component) => {\n\t\t\t\tif (typeof component === \"string\") {\n\t\t\t\t\treturn component;\n\t\t\t\t} else {\n\t\t\t\t\treturn `\\${${stringifyInner(component, visited)}}`;\n\t\t\t\t}\n\t\t\t})\n\t\t\t.join(\"\");\n\t\treturn `(tg.template \"${string}\")`;\n\t} else if (value instanceof Resource) {\n\t\treturn `(tg.resource \"${value.block().id()}\")`;\n\t} else if (value instanceof Target) {\n\t\treturn `(tg.target \"${value.block.id()}\")`;\n\t} else if (value instanceof Task) {\n\t\treturn `(tg.task \"${value.block().id()}\")`;\n\t} else {\n\t\t// Handle any other object.\n\t\tlet constructorName = \"\";\n\t\tif (\n\t\t\tvalue.constructor !== undefined &&\n\t\t\tvalue.constructor.name !== \"Object\"\n\t\t) {\n\t\t\tconstructorName = `${value.constructor.name} `;\n\t\t}\n\t\tlet entries = Object.entries(value).map(\n\t\t\t([key, value]) => `${key}: ${stringifyInner(value, visited)}`,\n\t\t);\n\t\treturn `${constructorName}{ ${entries.join(\", \")} }`;\n\t}\n};\n", "export namespace System {\n\texport type Arg = System | ArgObject;\n\n\texport type ArgObject = {\n\t\tarch: Arch;\n\t\tos: Os;\n\t};\n}\n\nexport let system = (arg: System.Arg): System => {\n\tif (typeof arg === \"string\") {\n\t\treturn arg;\n\t} else {\n\t\tlet { arch, os } = arg;\n\t\treturn `${arch}_${os}` as System;\n\t}\n};\n\nexport type System =\n\t| \"amd64_linux\"\n\t| \"arm64_linux\"\n\t| \"amd64_macos\"\n\t| \"arm64_macos\";\n\nexport namespace System {\n\texport type Arch = \"amd64\" | \"arm64\";\n\n\texport type Os = \"linux\" | \"macos\";\n\n\texport let is = (value: unknown): value is System => {\n\t\treturn (\n\t\t\tvalue === \"amd64_linux\" ||\n\t\t\tvalue === \"arm64_linux\" ||\n\t\t\tvalue === \"amd64_macos\" ||\n\t\t\tvalue === \"arm64_macos\"\n\t\t);\n\t};\n\n\texport let arch = (system: System): Arch => {\n\t\tswitch (system) {\n\t\t\tcase \"amd64_linux\":\n\t\t\tcase \"amd64_macos\": {\n\t\t\t\treturn \"amd64\";\n\t\t\t}\n\t\t\tcase \"arm64_linux\":\n\t\t\tcase \"arm64_macos\": {\n\t\t\t\treturn \"arm64\";\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\tthrow new Error(\"Invalid system.\");\n\t\t\t}\n\t\t}\n\t};\n\n\texport let os = (system: System): Os => {\n\t\tswitch (system) {\n\t\t\tcase \"amd64_linux\":\n\t\t\tcase \"arm64_linux\": {\n\t\t\t\treturn \"linux\";\n\t\t\t}\n\t\t\tcase \"amd64_macos\":\n\t\t\tcase \"arm64_macos\": {\n\t\t\t\treturn \"macos\";\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\tthrow new Error(\"Invalid system.\");\n\t\t\t}\n\t\t}\n\t};\n}\n", "import { Artifact } from \"./artifact.ts\";\nimport { assert, unimplemented, unreachable } from \"./assert.ts\";\nimport { Blob, blob } from \"./blob.ts\";\nimport { Directory, directory } from \"./directory.ts\";\nimport * as encoding from \"./encoding.ts\";\nimport { env } from \"./env.ts\";\nimport { prepareStackTrace } from \"./error.ts\";\nimport { File, file } from \"./file.ts\";\nimport { include } from \"./include.ts\";\nimport { log } from \"./log.ts\";\nimport { Relpath, Subpath, relpath, subpath } from \"./path.ts\";\nimport { Placeholder, placeholder } from \"./placeholder.ts\";\nimport { resolve } from \"./resolve.ts\";\nimport { download, resource } from \"./resource.ts\";\nimport { Symlink, symlink } from \"./symlink.ts\";\nimport { System, system } from \"./system.ts\";\nimport { Target, entrypoint, target, targets } from \"./target.ts\";\nimport { Task, output, run, task } from \"./task.ts\";\nimport { Template, t, template } from \"./template.ts\";\nimport { Value } from \"./value.ts\";\n\n// Set `Error.prepareStackTrace`.\nObject.defineProperties(Error, {\n\tprepareStackTrace: { value: prepareStackTrace },\n});\n\n// Create the console global.\nlet console = {\n\tlog,\n};\nObject.defineProperties(globalThis, {\n\tconsole: { value: console },\n});\n\n// Create the tg global.\nlet tg = {\n\tArtifact,\n\tBlob,\n\tDirectory,\n\tFile,\n\tPlaceholder,\n\tRelpath,\n\tSubpath,\n\tSymlink,\n\tSystem,\n\tTarget,\n\tTask,\n\tTemplate,\n\tValue,\n\tassert,\n\tblob,\n\tdirectory,\n\tdownload,\n\tencoding,\n\tentrypoint,\n\tenv,\n\tfile,\n\tinclude,\n\tlog,\n\toutput,\n\tplaceholder,\n\trelpath,\n\tresolve,\n\tresource,\n\trun,\n\tsubpath,\n\tsymlink,\n\tsystem,\n\ttarget,\n\ttargets,\n\ttask,\n\ttemplate,\n\tunimplemented,\n\tunreachable,\n};\nObject.defineProperties(globalThis, {\n\ttg: { value: tg },\n\tt: { value: t },\n});\n"],
  "mappings": "gHAAO,IAAIA,EAGc,CAACC,EAAWC,IAAY,CAChD,GAAI,CAACD,EACJ,MAAM,IAAI,MAAMC,GAAW,mBAAmB,CAEhD,EAEWC,GAAiBD,GAA4B,CACvD,MAAM,IAAI,MAAMA,GAAW,6BAA6B,CACzD,EAEWE,EAAeF,GAA4B,CACrD,MAAM,IAAI,MAAMA,GAAW,2BAA2B,CACvD,ECfA,IAAAG,EAAA,GAAAC,GAAAD,EAAA,YAAAE,GAAA,QAAAC,GAAA,SAAAC,EAAA,SAAAC,GAAA,SAAAC,EAAA,SAAAC,KC4SO,IAAIC,EAAW,CACrB,OAAQ,MAAOA,GAA0C,CACxD,GAAI,CACH,OAAO,MAAM,QAAQ,kBAAmBA,CAAQ,CACjD,OAASC,EAAO,CACf,MAAM,IAAI,MAAM,sBAAuB,CAAE,MAAAA,CAAM,CAAC,CACjD,CACD,EAEA,IAAK,MAAOC,GAAoC,CAC/C,GAAI,CACH,OAAO,MAAM,QAAQ,eAAgBA,CAAK,CAC3C,OAASD,EAAO,CACf,MAAM,IAAI,MAAM,sBAAuB,CAAE,MAAAA,CAAM,CAAC,CACjD,CACD,CACD,EAEWE,EAAO,CACjB,MAAO,MAAOA,GAAoC,CACjD,GAAI,CACH,OAAO,MAAM,QAAQ,aAAcA,CAAI,CACxC,OAASF,EAAO,CACf,MAAM,IAAI,MAAM,sBAAuB,CAAE,MAAAA,CAAM,CAAC,CACjD,CACD,EAEA,IAAK,MAAOG,GAA8B,CACzC,GAAI,CACH,OAAO,MAAM,QAAQ,WAAYA,CAAG,CACrC,OAASH,EAAO,CACf,MAAM,IAAI,MAAM,sBAAuB,CAAE,MAAAA,CAAM,CAAC,CACjD,CACD,EAEA,IAAK,MAAOG,GAAiC,CAC5C,GAAI,CACH,OAAO,MAAM,QAAQ,WAAYA,CAAG,CACrC,OAASH,EAAO,CACf,MAAM,IAAI,MAAM,sBAAuB,CAAE,MAAAA,CAAM,CAAC,CACjD,CACD,EAEA,KAAM,MAAOE,GAAgC,CAC5C,GAAI,CACH,OAAO,MAAM,QAAQ,YAAaA,CAAI,CACvC,OAASF,EAAO,CACf,MAAM,IAAI,MAAM,sBAAuB,CAAE,MAAAA,CAAM,CAAC,CACjD,CACD,CACD,EAEWC,EAAQ,CAClB,MAAO,MAAOA,GAAsC,CACnD,GAAI,CACH,OAAO,MAAM,QAAQ,cAAeA,CAAK,CAC1C,OAASD,EAAO,CACf,MAAM,IAAI,MAAM,sBAAuB,CAAE,MAAAA,CAAM,CAAC,CACjD,CACD,EAEA,SAAU,MAAOC,GAAwC,CACxD,GAAI,CACH,OAAO,QAAQ,iBAAkBA,CAAK,CACvC,OAASD,EAAO,CACf,MAAM,IAAI,MAAM,sBAAuB,CAAE,MAAAA,CAAM,CAAC,CACjD,CACD,EAEA,KAAM,MAAOC,GAAsC,CAClD,GAAI,CACH,OAAO,MAAM,QAAQ,aAAcA,CAAK,CACzC,OAASD,EAAO,CACf,MAAM,IAAI,MAAM,sBAAuB,CAAE,MAAAA,CAAM,CAAC,CACjD,CACD,EAEA,IAAK,MAAOG,GAAmC,CAC9C,GAAI,CACH,OAAO,QAAQ,YAAaA,CAAG,CAChC,OAASH,EAAO,CACf,MAAM,IAAI,MAAM,sBAAuB,CAAE,MAAAA,CAAM,CAAC,CACjD,CACD,CACD,EAaO,IAAII,GAAY,CACtB,IAAMC,GAAkC,CACvC,GAAI,CACH,OAAO,QAAQ,gBAAiBA,CAAG,CACpC,OAASC,EAAO,CACf,MAAM,IAAI,MAAM,sBAAuB,CAAE,MAAAA,CAAM,CAAC,CACjD,CACD,CACD,EAEiBC,OACLA,EAAA,OAAS,CACnB,OAASC,GAA8B,CACtC,GAAI,CACH,OAAO,QAAQ,yBAA0BA,CAAK,CAC/C,OAASF,EAAO,CACf,MAAM,IAAI,MAAM,sBAAuB,CAAE,MAAAA,CAAM,CAAC,CACjD,CACD,EAEA,OAASE,GAA8B,CACtC,GAAI,CACH,OAAO,QAAQ,yBAA0BA,CAAK,CAC/C,OAASF,EAAO,CACf,MAAM,IAAI,MAAM,sBAAuB,CAAE,MAAAA,CAAM,CAAC,CACjD,CACD,CACD,EAEWC,EAAA,IAAM,CAChB,OAASC,GAA8B,CACtC,GAAI,CACH,OAAO,QAAQ,sBAAuBA,CAAK,CAC5C,OAASF,EAAO,CACf,MAAM,IAAI,MAAM,sBAAuB,CAAE,MAAAA,CAAM,CAAC,CACjD,CACD,EAEA,OAASE,GAA8B,CACtC,GAAI,CACH,OAAO,QAAQ,sBAAuBA,CAAK,CAC5C,OAASF,EAAO,CACf,MAAM,IAAI,MAAM,sBAAuB,CAAE,MAAAA,CAAM,CAAC,CACjD,CACD,CACD,EAEWC,EAAA,KAAO,CACjB,OAASC,GAA2B,CACnC,GAAI,CACH,OAAO,QAAQ,uBAAwBA,CAAK,CAC7C,OAASF,EAAO,CACf,MAAM,IAAI,MAAM,sBAAuB,CAAE,MAAAA,CAAM,CAAC,CACjD,CACD,EAEA,OAASE,GAAuB,CAC/B,GAAI,CACH,OAAO,QAAQ,uBAAwBA,CAAK,CAC7C,OAASF,EAAO,CACf,MAAM,IAAI,MAAM,sBAAuB,CAAE,MAAAA,CAAM,CAAC,CACjD,CACD,CACD,EAEWC,EAAA,KAAO,CACjB,OAASC,GAA2B,CACnC,GAAI,CACH,OAAO,QAAQ,uBAAwBA,CAAK,CAC7C,OAASF,EAAO,CACf,MAAM,IAAI,MAAM,sBAAuB,CAAE,MAAAA,CAAM,CAAC,CACjD,CACD,EAEA,OAASE,GAAuB,CAC/B,GAAI,CACH,OAAO,QAAQ,uBAAwBA,CAAK,CAC7C,OAASF,EAAO,CACf,MAAM,IAAI,MAAM,sBAAuB,CAAE,MAAAA,CAAM,CAAC,CACjD,CACD,CACD,EAEWC,EAAA,KAAO,CACjB,OAASC,GAA8B,CACtC,GAAI,CACH,OAAO,QAAQ,uBAAwBA,CAAK,CAC7C,OAASF,EAAO,CACf,MAAM,IAAI,MAAM,sBAAuB,CAAE,MAAAA,CAAM,CAAC,CACjD,CACD,EAEA,OAASE,GAA8B,CACtC,GAAI,CACH,OAAO,QAAQ,uBAAwBA,CAAK,CAC7C,OAASF,EAAO,CACf,MAAM,IAAI,MAAM,sBAAuB,CAAE,MAAAA,CAAM,CAAC,CACjD,CACD,CACD,EAEWC,EAAA,KAAO,CACjB,OAASC,GAA2B,CACnC,GAAI,CACH,OAAO,QAAQ,uBAAwBA,CAAK,CAC7C,OAASF,EAAO,CACf,MAAM,IAAI,MAAM,sBAAuB,CAAE,MAAAA,CAAM,CAAC,CACjD,CACD,EAEA,OAASE,GAAuB,CAC/B,GAAI,CACH,OAAO,QAAQ,uBAAwBA,CAAK,CAC7C,OAASF,EAAO,CACf,MAAM,IAAI,MAAM,sBAAuB,CAAE,MAAAA,CAAM,CAAC,CACjD,CACD,CACD,IA3GgBC,IAAA,IA8GV,IAAIE,GAAO,CACjB,IAAMJ,GAAwB,CAC7B,GAAI,CACH,OAAO,QAAQ,WAAYA,CAAG,CAC/B,OAASC,EAAO,CACf,MAAM,IAAI,MAAM,sBAAuB,CAAE,MAAAA,CAAM,CAAC,CACjD,CACD,CACD,EAEWI,GAAOF,GAAkB,CACnC,GAAI,CACH,OAAO,QAAQ,MAAOA,CAAK,CAC5B,OAASF,EAAO,CACf,MAAM,IAAI,MAAM,sBAAuB,CAAE,MAAAA,CAAM,CAAC,CACjD,CACD,EAEWK,EAAY,CACtB,IAAK,MAAOC,GAAqC,CAChD,GAAI,CACH,OAAO,MAAM,QAAQ,gBAAiBA,CAAK,CAC5C,OAASN,EAAO,CACf,MAAM,IAAI,MAAM,sBAAuB,CAAE,MAAAA,CAAM,CAAC,CACjD,CACD,EAEA,WAAY,MAAOK,GAAyC,CAC3D,GAAI,CACH,OAAO,MAAM,QAAQ,qBAAsBA,CAAS,CACrD,OAASL,EAAO,CACf,MAAM,IAAI,MAAM,sBAAuB,CAAE,MAAAA,CAAM,CAAC,CACjD,CACD,CACD,EAEWO,GAAW,CACrB,IAAMR,GAAgC,CACrC,GAAI,CACH,OAAO,QAAQ,eAAgBA,CAAG,CACnC,OAASC,EAAO,CACf,MAAM,IAAI,MAAM,sBAAuB,CAAE,MAAAA,CAAM,CAAC,CACjD,CACD,CACD,EAEWQ,EAAS,CACnB,IAAMT,GAA4B,CACjC,GAAI,CACH,OAAO,QAAQ,aAAcA,CAAG,CACjC,OAASC,EAAO,CACf,MAAM,IAAI,MAAM,sBAAuB,CAAE,MAAAA,CAAM,CAAC,CACjD,CACD,CACD,EAEWS,GAAO,CACjB,IAAMV,GAAwB,CAC7B,GAAI,CACH,OAAO,QAAQ,WAAYA,CAAG,CAC/B,OAASC,EAAO,CACf,MAAM,IAAI,MAAM,sBAAuB,CAAE,MAAAA,CAAM,CAAC,CACjD,CACD,CACD,EAEWU,GAAU,CACpB,IAAMX,GAA8B,CACnC,GAAI,CACH,OAAO,QAAQ,cAAeA,CAAG,CAClC,OAASC,EAAO,CACf,MAAM,IAAI,MAAM,sBAAuB,CAAE,MAAAA,CAAM,CAAC,CACjD,CACD,CACD,ED7kBO,IAAUW,QACLA,EAAA,OAAUC,GACLC,EAAS,OAAO,OAAOD,CAAK,EAGjCD,EAAA,OAAUC,GACLC,EAAS,OAAO,OAAOD,CAAK,IAN5BD,KAAA,IAUV,IAAUG,QACLA,EAAA,OAAUF,GACLC,EAAS,IAAI,OAAOD,CAAK,EAG9BE,EAAA,OAAUF,GACLC,EAAS,IAAI,OAAOD,CAAK,IANzBE,KAAA,IAUV,IAAUC,OACLA,EAAA,OAAUH,GACLC,EAAS,KAAK,OAAOD,CAAK,EAG/BG,EAAA,OAAUH,GACLC,EAAS,KAAK,OAAOD,CAAK,IAN1BG,IAAA,IAUV,IAAUC,QACLA,EAAA,OAAUJ,GACLC,EAAS,KAAK,OAAOD,CAAK,EAG/BI,EAAA,OAAUJ,GACLC,EAAS,KAAK,OAAOD,CAAK,IAN1BI,KAAA,IAUV,IAAUC,OACLA,EAAA,OAAUL,GACLC,EAAS,KAAK,OAAOD,CAAK,EAG/BK,EAAA,OAAUL,GACLC,EAAS,KAAK,OAAOD,CAAK,IAN1BK,IAAA,IAUV,IAAUC,QACLA,EAAA,OAAUN,GACLC,EAAS,KAAK,OAAOD,CAAK,EAG/BM,EAAA,OAAUN,GACLC,EAAS,KAAK,OAAOD,CAAK,IAN1BM,KAAA,IE9CV,IAAIC,EAAcC,GAEjBA,EAAM,KAAK,GAAQ,ECApB,IAAIC,EAAO,SAAUC,IACpB,MAAMC,EAAK,IAAI,GAAGD,CAAI,EAUjBC,EAAN,MAAMC,CAAK,CACjBC,GACAC,GACAC,GACAC,GAEA,aAAa,OAAON,EAAkD,CACrE,GAAI,CACH,SAAUO,EACV,WAAAC,EACA,WAAAC,CACD,EAAIC,EACH,MAAM,QAAQ,IACbV,EAAK,IAAI,eAAeW,EACvBC,EAOC,CACD,IAAIC,EAAM,MAAMC,EAAQF,CAAa,EACrC,OAAIG,EAAK,IAAI,GAAGF,CAAG,EACX,CAAE,SAAUA,CAAI,EACbX,EAAK,GAAGW,CAAG,EACd,CACN,SAAUA,EAAIT,GACd,WAAYS,EAAIR,GAChB,WAAY,MAAMQ,EAAI,WAAW,CAClC,EACUA,aAAe,MAClB,MAAM,QAAQ,IAAIA,EAAI,IAAIF,CAAG,CAAC,EAC3BE,aAAe,OAClB,CACN,SAAUA,EAAI,SACd,WAAYA,EAAI,WAChB,WAAYA,EAAI,UACjB,EAEOG,EAAY,CAErB,CAAC,CACF,CACD,EAAE,OAKD,CAACC,EAAO,CAAE,SAAAC,EAAU,WAAAV,EAAY,WAAAC,CAAW,KAC1CQ,EAAM,SAAS,KAAKC,CAAQ,EAC5BD,EAAM,WACLT,IAAe,OAAYA,EAAaS,EAAM,WAC/CA,EAAM,WAAW,KAAK,GAAIR,GAAc,CAAC,CAAE,EACpCQ,GAER,CAAE,SAAU,CAAC,EAAG,WAAY,GAAO,WAAY,CAAC,CAAE,CACnD,EACIC,EAAW,MAAMC,EAAK,GAAGZ,CAAY,EACzC,OAAOL,EAAK,YACHH,GAAK,IAAI,CAChB,SAAUmB,EAAS,UAAU,EAC7B,WAAAV,EACA,WAAYC,EAAW,IAAKW,GAC3BC,EAAS,UAAUD,CAAS,CAC7B,CACD,CAAC,CACF,CACD,CAEA,YAAYP,EAAqB,CAChC,KAAKV,GAASU,EAAI,MAClB,KAAKT,GAAYS,EAAI,SACrB,KAAKR,GAAcQ,EAAI,WACvB,KAAKP,GAAcO,EAAI,UACxB,CAEA,OAAO,GAAGI,EAA+B,CACxC,OAAOA,aAAiBf,CACzB,CAEA,OAAO,OAAOe,EAAsB,CACnC,OAAAK,EAAQpB,EAAK,GAAGe,CAAK,CAAC,EACfA,CACR,CAEA,OAAO,OAAOA,EAAuC,CACpDK,EAAQpB,EAAK,GAAGe,CAAK,CAAC,CACvB,CAEA,WAA0B,CACzB,IAAIM,EAAQ,KAAKpB,GAAO,UAAU,EAC9Be,EAAW,KAAKd,GAAU,UAAU,EACpCI,EAAa,KAAKH,GAClBI,EAAa,KAAKH,GAAY,IAAKiB,GAAUA,EAAM,UAAU,CAAC,EAClE,MAAO,CACN,MAAAA,EACA,SAAAL,EACA,WAAAV,EACA,WAAAC,CACD,CACD,CAEA,OAAO,YAAYQ,EAA2B,CAC7C,IAAIM,EAAQC,EAAM,YAAYP,EAAM,KAAK,EACrCC,EAAWM,EAAM,YAAYP,EAAM,QAAQ,EAC3CT,EAAaS,EAAM,WACnBR,EAAaQ,EAAM,WAAW,IAAKM,GAAUC,EAAM,YAAYD,CAAK,CAAC,EACzE,OAAO,IAAIrB,EAAK,CACf,MAAAqB,EACA,SAAAL,EACA,WAAAV,EACA,WAAAC,CACD,CAAC,CACF,CAEA,OAAe,CACd,OAAO,KAAKN,EACb,CAEA,MAAM,UAA0B,CAC/B,OAAO,MAAMY,EAAK,IAAI,KAAKX,EAAS,CACrC,CAEA,YAAsB,CACrB,OAAO,KAAKC,EACb,CAEA,MAAM,YAAuC,CAC5C,OAAO,MAAM,QAAQ,IAAI,KAAKC,GAAY,IAAIe,EAAS,GAAG,CAAC,CAC5D,CAEA,MAAM,OAA6B,CAClC,OAAO,MAAO,MAAM,KAAK,SAAS,GAAG,MAAM,CAC5C,CAEA,MAAM,MAAwB,CAC7B,OAAO,MAAO,MAAM,KAAK,SAAS,GAAG,KAAK,CAC3C,CACD,EC3JO,IAAII,EAAU,IAAIC,IACjBC,EAAQ,IAAI,GAAGD,CAAI,EAGhBE,EAAU,IAAIF,IACjBG,EAAQ,IAAI,GAAGH,CAAI,EAQdC,EAAN,MAAMG,CAAQ,CACpBC,GACAC,GAEA,OAAO,OAAON,EAAmC,CAChD,OAAOA,EAAK,OAAO,SAASO,EAAOC,EAAeC,EAAkB,CACnE,GAAI,OAAOA,GAAQ,SAClB,QAASC,KAAaD,EAAI,MAAM,GAAG,EAC9BC,IAAc,IAAMA,IAAc,MAE3BA,IAAc,KACxBF,EAAOA,EAAK,OAAO,EAEnBA,EAAKF,GAAS,KAAKI,CAAS,WAGpBD,aAAeL,EAAS,CAClC,QAASO,EAAI,EAAGA,EAAIF,EAAIJ,GAAUM,IACjCH,EAAK,OAAO,EAEbA,EAAKF,GAAS,KAAKG,EAAIH,EAAQ,CAChC,SAAWG,aAAeN,EACzBK,EAAKF,GAAS,KAAKG,CAAG,UACZA,aAAe,MACzBA,EAAI,QAASA,GAAQF,EAAOC,EAAMC,CAAG,CAAC,MAEtC,QAAOG,EAAY,EAEpB,OAAOJ,CACR,EAAG,IAAIJ,CAAS,CACjB,CAEA,YAAYK,EAA6B,CACxC,KAAKJ,GAAWI,GAAK,SAAW,EAChC,KAAKH,GAAWG,GAAK,SAAW,IAAIN,CACrC,CAEA,OAAO,GAAGU,EAAkC,CAC3C,OAAOA,aAAiBT,CACzB,CAEA,WAA6B,CAC5B,OAAO,KAAK,SAAS,CACtB,CAEA,OAAO,YAAYS,EAAiC,CACnD,OAAOT,EAAQ,IAAIS,CAAK,CACzB,CAEA,SAAmB,CAClB,OAAO,KAAKR,IAAY,GAAK,KAAKC,GAAS,QAAQ,CACpD,CAEA,SAAkB,CACjB,OAAO,KAAKD,EACb,CAEA,SAAmB,CAClB,OAAO,KAAKC,EACb,CAEA,QAAkB,CACjB,OAAI,KAAKA,GAAS,QAAQ,EACzB,KAAKD,IAAY,EAEjB,KAAKC,GAAS,IAAI,EAEZ,IACR,CAEA,KAAKQ,EAA6B,CACjCA,EAAQV,EAAQ,IAAIU,CAAK,EACzB,QAASH,EAAI,EAAGA,EAAIG,EAAMT,GAAUM,IACnC,KAAK,OAAO,EAEb,YAAKL,GAAS,KAAKQ,EAAMR,EAAQ,EAC1B,IACR,CAEA,WAAgC,CAC/B,OAAO,KAAKA,GAAS,UAAU,CAChC,CAEA,WAAqB,CACpB,GAAI,KAAKD,GAAW,EACnB,MAAM,IAAI,MAAM,4BAA4B,EAE7C,OAAO,KAAKC,EACb,CAEA,UAAmB,CAClB,IAAIS,EAAS,GACb,QAASJ,EAAI,EAAGA,EAAI,KAAKN,GAAUM,IAClCI,GAAU,MAEX,OAAAA,GAAU,KAAKT,GAAS,SAAS,EAC1BS,CACR,CACD,GAEiBd,GAAV,CAGC,IAAUe,OACLA,EAAA,GAAMH,GAEfA,IAAU,QACV,OAAOA,GAAU,UACjBA,aAAiBV,GACjBU,aAAiBZ,GAChBY,aAAiB,OAASA,EAAM,MAAMZ,EAAQ,IAAI,EAAE,EAI5Ce,EAAA,OAAUH,IACpBI,KAAQD,EAAA,IAAGH,CAAK,CAAC,EACVA,GAGGG,EAAA,OAAUH,GAAiD,CACrEI,KAAQD,EAAA,IAAGH,CAAK,CAAC,CAClB,IAlBgBG,EAAAf,EAAA,YAHDA,IAAA,IAyBV,IAAME,EAAN,MAAMe,CAAQ,CACpBC,GAEA,OAAO,OAAOnB,EAAmC,CAChD,OAAOC,EAAQ,IAAI,GAAGD,CAAI,EAAE,UAAU,CACvC,CAEA,YAAYoB,EAA4B,CACvC,KAAKD,GAAcC,GAAc,CAAC,CACnC,CAEA,OAAO,GAAGP,EAAkC,CAC3C,OAAOA,aAAiBK,CACzB,CAEA,WAA6B,CAC5B,OAAO,KAAK,SAAS,CACtB,CAEA,OAAO,YAAYL,EAAiC,CACnD,OAAOX,EAAQW,CAAK,CACrB,CAEA,YAA4B,CAC3B,MAAO,CAAC,GAAG,KAAKM,EAAW,CAC5B,CAEA,SAAmB,CAClB,OAAO,KAAKA,GAAY,QAAU,CACnC,CAEA,KAAKL,EAAyB,CAC7B,YAAKK,GAAY,KAAK,GAAGL,EAAMK,EAAW,EACnC,IACR,CAEA,KAAKT,EAAmB,CACvB,KAAKS,GAAY,KAAKT,CAAS,CAChC,CAEA,KAAM,CACL,KAAKS,GAAY,IAAI,CACtB,CAEA,WAAgC,CAC/B,OAAO,KAAKA,GAAY,GAAG,EAAE,GAAG,MAAM,GAAG,EAAE,GAAG,EAAE,CACjD,CAEA,WAAqB,CACpB,OAAOlB,EAAQ,IAAI,IAAI,CACxB,CAEA,UAAmB,CAClB,OAAO,KAAKkB,GAAY,KAAK,GAAG,CACjC,CACD,EClMO,IAAIE,EAAeC,GAClBC,EAAY,IAAID,CAAI,EAGfC,EAAN,MAAMC,CAAY,CACxBC,GAEA,OAAO,IAAIH,EAA2B,CACrC,OAAO,IAAIE,EAAYF,CAAI,CAC5B,CAEA,YAAYA,EAAc,CACzB,KAAKG,GAAQH,CACd,CAEA,OAAO,GAAGI,EAAsC,CAC/C,OAAOA,aAAiBF,CACzB,CAEA,WAAiC,CAChC,MAAO,CACN,KAAM,KAAKC,EACZ,CACD,CAEA,OAAO,YAAYJ,EAA+C,CACjE,IAAIC,EAAOD,EAAY,KACvB,OAAO,IAAIG,EAAYF,CAAI,CAC5B,CAEA,MAAe,CACd,OAAO,KAAKG,EACb,CACD,EChCO,IAAUE,MAGLA,EAAA,IAAM,KAChBC,EAAOD,EAAA,KAAK,EACLA,EAAA,QALQA,IAAA,ICKV,IAAIE,EAAI,MACdC,KACGC,IACoB,CAEvB,IAAIC,EAA8C,CAAC,EACnD,QAASC,EAAI,EAAGA,EAAIH,EAAQ,OAAS,EAAGG,IAAK,CAC5C,IAAIC,EAASJ,EAAQG,CAAC,EACtBD,EAAW,KAAKE,CAAM,EACtB,IAAIC,EAAcJ,EAAaE,CAAC,EAChCD,EAAW,KAAKG,CAAW,CAC5B,CACA,OAAAH,EAAW,KAAKF,EAAQA,EAAQ,OAAS,CAAC,CAAE,EACrC,MAAMM,EAAS,GAAGJ,CAAU,CACpC,EAEWI,EAAW,IAClBC,IAEIC,EAAS,IAAI,GAAGD,CAAI,EAGfC,EAAN,MAAMC,CAAS,CACrBC,GAEA,aAAa,OACTH,EACiB,CAEpB,IAAIL,EAAaS,EAChB,MAAM,QAAQ,IACbJ,EAAK,IAAI,eAAeK,EACvBC,EACgD,CAEhD,OADAA,EAAM,MAAMC,EAAQD,CAAG,EACnBJ,EAAS,UAAU,GAAGI,CAAG,EACrBA,EACGA,aAAeE,GAAWF,aAAeG,EAC5CH,EAAI,SAAS,EACVA,aAAeJ,EAClBI,EAAI,WAAW,EACZA,aAAe,MAClB,MAAM,QAAQ,IAAIA,EAAI,IAAID,CAAG,CAAC,EAE9BK,EAAY,CAErB,CAAC,CACF,CACD,EAAE,OAAkC,CAACf,EAAYgB,KAChDhB,EAAW,KAAKgB,CAAS,EAClBhB,GACL,CAAC,CAAC,EAGL,OAAAA,EAAaA,EAAW,OACvB,CAACA,EAAYgB,IAAc,CAC1B,IAAIC,EAAgBjB,EAAW,GAAG,EAAE,EACpC,OAAIgB,IAAc,KAGjB,OAAOC,GAAkB,UACzB,OAAOD,GAAc,SAGrBhB,EAAW,OAAO,GAAI,EAAGiB,EAAgBD,CAAS,EAElDhB,EAAW,KAAKgB,CAAS,GAEnBhB,CACR,EACA,CAAC,CACF,EAEO,IAAIO,EAASP,CAAU,CAC/B,CAEA,YAAYA,EAAuC,CAClD,KAAKQ,GAAcR,CACpB,CAEA,OAAO,GAAGkB,EAAmC,CAC5C,OAAOA,aAAiBX,CACzB,CAEA,OAAO,OAAOW,EAA0B,CACvC,OAAAC,EAAQZ,EAAS,GAAGW,CAAK,CAAC,EACnBA,CACR,CAEA,OAAO,OAAOA,EAA2C,CACxDC,EAAQZ,EAAS,GAAGW,CAAK,CAAC,CAC3B,CAGA,aAAa,KACZE,KACGf,EACiB,CACpB,IAAIgB,EAAoB,MAAMjB,EAASgB,CAAS,EAC5CE,EAAe,MAAM,QAAQ,IAAIjB,EAAK,IAAKM,GAAQP,EAASO,CAAG,CAAC,CAAC,EACrEW,EAAeA,EAAa,OAAQX,GAAQA,EAAI,WAAW,EAAE,OAAS,CAAC,EACvE,IAAIY,EAAY,CAAC,EACjB,QAAStB,EAAI,EAAGA,EAAIqB,EAAa,OAAQrB,IAAK,CACzCA,EAAI,GACPsB,EAAU,KAAKF,CAAiB,EAEjC,IAAIG,EAAcF,EAAarB,CAAC,EAChCkB,EAAQK,CAAW,EACnBD,EAAU,KAAKC,CAAW,CAC3B,CACA,OAAOpB,EAAS,GAAGmB,CAAS,CAC7B,CAEA,WAA8B,CAI7B,MAAO,CACN,WAJgB,KAAKf,GAAY,IAAKQ,GACtCT,EAAS,UAAU,UAAUS,CAAS,CACvC,CAGA,CACD,CAEA,OAAO,YAAYE,EAAmC,CACrD,IAAIlB,EAAakB,EAAM,WAAW,IAAKF,GACtCT,EAAS,UAAU,YAAYS,CAAS,CACzC,EACA,OAAO,IAAIT,EAASP,CAAU,CAC/B,CAEA,YAAwC,CACvC,MAAO,CAAC,GAAG,KAAKQ,EAAW,CAC5B,CACD,GAEiBF,GAAV,CAGC,IAAUmB,OACLA,EAAA,GAAMP,GAEf,OAAOA,GAAU,UACjBQ,EAAS,GAAGR,CAAK,GACjBA,aAAiBS,EAIRF,EAAA,UACVT,GAEI,OAAOA,GAAc,SACjB,CACN,KAAM,SACN,MAAOA,CACR,EACUU,EAAS,GAAGV,CAAS,EACxB,CACN,KAAM,WACN,MAAOU,EAAS,UAAUV,CAAS,CACpC,EACUA,aAAqBW,EACxB,CACN,KAAM,cACN,MAAOX,EAAU,UAAU,CAC5B,EAEOD,EAAY,EAIVU,EAAA,YACVT,GACe,CACf,OAAQA,EAAU,KAAM,CACvB,IAAK,SACJ,OAAOA,EAAU,MAElB,IAAK,WACJ,OAAOU,EAAS,YAAYV,EAAU,KAAK,EAE5C,IAAK,cACJ,OAAOW,EAAY,YAAYX,EAAU,KAAK,EAE/C,QACC,OAAOD,EAAY,CAErB,CACD,IAjDgBU,EAAAnB,EAAA,kBAHDA,IAAA,ICnIV,IAAIsB,EAAU,SACjBC,IAEI,MAAMC,EAAQ,IAAI,GAAGD,CAAI,EAQpBC,EAAN,MAAMC,CAAQ,CACpBC,GACAC,GAEA,aAAa,OAAOJ,EAAwD,CAE3E,GAAI,CAAE,SAAAK,EAAU,KAAAC,CAAK,EAAIC,EACxB,MAAM,QAAQ,IACbP,EAAK,IAAI,eAAeQ,EACvBC,EACqE,CACrE,IAAIC,EAAM,MAAMC,EAAQF,CAAa,EACrC,GAAI,OAAOC,GAAQ,SAClB,MAAO,CAAE,KAAME,EAAQF,CAAG,CAAE,EACtB,GAAIG,EAAQ,GAAGH,CAAG,EACxB,MAAO,CAAE,KAAME,EAAQF,CAAG,CAAE,EACtB,GAAII,EAAQ,GAAGJ,CAAG,EACxB,MAAO,CAAE,KAAMA,EAAI,UAAU,CAAE,EACzB,GAAIK,EAAS,GAAGL,CAAG,EACzB,MAAO,CAAE,SAAUA,CAAI,EACjB,GAAIA,aAAeM,EAAU,CACnCC,EAAQP,EAAI,WAAW,EAAE,QAAU,CAAC,EACpC,GAAI,CAACQ,EAAgBC,CAAe,EAAIT,EAAI,WAAW,EACvD,GACC,OAAOQ,GAAmB,UAC1BC,IAAoB,OAEpB,MAAO,CAAE,KAAMP,EAAQM,CAAc,CAAE,EACjC,GACNH,EAAS,GAAGG,CAAc,GAC1BC,IAAoB,OAEpB,MAAO,CAAE,SAAUD,CAAe,EAC5B,GACNH,EAAS,GAAGG,CAAc,GAC1B,OAAOC,GAAoB,SAE3B,OAAAF,EAAQE,EAAgB,WAAW,GAAG,CAAC,EAChC,CACN,SAAUD,EACV,KAAMN,EAAQO,EAAgB,MAAM,CAAC,CAAC,CACvC,EAEA,MAAM,IAAI,MAAM,mBAAmB,CAErC,KAAO,QAAIT,aAAeR,EAClB,CACN,SAAUQ,EAAI,SAAS,EACvB,KAAMA,EAAI,KAAK,CAChB,EACUA,aAAe,MAClB,MAAM,QAAQ,IAAIA,EAAI,IAAIF,CAAG,CAAC,EAC3B,OAAOE,GAAQ,SAClB,CACN,SAAUA,EAAI,SACd,KAAME,EAAQF,EAAI,IAAI,CACvB,EAEOU,EAAY,CAErB,CAAC,CACF,CACD,EAAE,OACD,CAACC,EAAO,CAAE,SAAAhB,EAAU,KAAAC,CAAK,KACpBD,IAAa,QAChBgB,EAAM,SAAWhB,EACjBgB,EAAM,KAAOf,GAAQM,EAAQ,GAE7BS,EAAM,KAAOA,EAAM,KAAK,KAAKf,CAAI,EAE3Be,GAER,CAAE,SAAU,OAAW,KAAMT,EAAQ,CAAE,CACxC,EAGIU,EACJ,GAAIjB,IAAa,QAAa,CAACC,EAAK,QAAQ,EAC3CgB,EAAS,MAAMC,IAAIlB,CAAQ,IAAIC,CAAI,WACzBD,IAAa,OACvBiB,EAAS,MAAMC,IAAIlB,CAAQ,WACjB,CAACC,EAAK,QAAQ,EACxBgB,EAAS,MAAMC,IAAIjB,CAAI,OAEvB,OAAM,IAAI,MAAM,kBAAkB,EAGnC,OAAOJ,EAAQ,YACNH,GAAQ,IAAI,CAAE,OAAQuB,EAAO,UAAU,CAAE,CAAC,CACnD,CACD,CAEA,YAAYZ,EAAqB,CAChC,KAAKP,GAASO,EAAI,MAClB,KAAKN,GAAUM,EAAI,MACpB,CAEA,OAAO,GAAGW,EAAkC,CAC3C,OAAOA,aAAiBnB,CACzB,CAEA,OAAO,OAAOmB,EAAyB,CACtC,OAAAJ,EAAQf,EAAQ,GAAGmB,CAAK,CAAC,EAClBA,CACR,CAEA,OAAO,OAAOA,EAA0C,CACvDJ,EAAQf,EAAQ,GAAGmB,CAAK,CAAC,CAC1B,CAEA,WAA6B,CAC5B,IAAIG,EAAQ,KAAKrB,GAAO,UAAU,EAC9BmB,EAAS,KAAKlB,GAAQ,UAAU,EACpC,MAAO,CACN,MAAAoB,EACA,OAAAF,CACD,CACD,CAEA,OAAO,YAAYvB,EAAmC,CACrD,IAAIyB,EAAQC,EAAM,YAAY1B,EAAQ,KAAK,EACvCuB,EAASN,EAAS,YAAYjB,EAAQ,MAAM,EAChD,OAAO,IAAIG,EAAQ,CAClB,MAAAsB,EACA,OAAAF,CACD,CAAC,CACF,CAEA,OAAe,CACd,OAAO,KAAKnB,EACb,CAEA,QAAmB,CAClB,OAAO,KAAKC,EACb,CAEA,UAAiC,CAChC,IAAIc,EAAiB,KAAKd,GAAQ,WAAW,EAAE,GAAG,CAAC,EACnD,GAAIW,EAAS,GAAGG,CAAc,EAC7B,OAAOA,CAIT,CAEA,MAAgB,CACf,GAAI,CAACA,EAAgBC,CAAe,EAAI,KAAKf,GAAQ,WAAW,EAChE,GAAI,OAAOc,GAAmB,UAAYC,IAAoB,OAC7D,OAAOP,EAAQM,CAAc,EACvB,GAAIH,EAAS,GAAGG,CAAc,GAAKC,IAAoB,OAC7D,OAAOP,EAAQ,EACT,GACNG,EAAS,GAAGG,CAAc,GAC1B,OAAOC,GAAoB,SAE3B,OAAOP,EAAQO,EAAgB,MAAM,CAAC,CAAC,EAEvC,MAAM,IAAI,MAAM,mBAAmB,CAErC,CAEA,MAAM,QACLO,EACwC,CACxCA,EAAOA,EAAO,MAAM3B,EAAQ2B,CAAI,EAAI,OACpC,IAAIC,EAAeD,GAAM,SAAS,EAC9BC,aAAwBzB,IAC3ByB,EAAe,MAAMA,EAAa,QAAQ,GAE3C,IAAIC,EAAWF,GAAM,KAAK,EACtBrB,EAAW,KAAK,SAAS,EACzBA,aAAoBH,IACvBG,EAAW,MAAMA,EAAS,QAAQ,GAEnC,IAAIC,EAAO,KAAK,KAAK,EACrB,GAAID,IAAa,QAAaC,EAAK,QAAQ,EAC1C,OAAOD,EACD,GAAIA,IAAa,QAAa,CAACC,EAAK,QAAQ,EAAG,CACrD,GAAI,EAAEqB,aAAwBE,GAC7B,MAAM,IAAI,MAAM,uBAAuB,EAExC,OAAO,MAAMF,EAAa,QACxBC,GAAYhB,EAAQ,GAAG,OAAO,EAAE,KAAKN,CAAI,EAAE,UAAU,CACvD,CACD,SAAWD,IAAa,QAAa,CAACC,EAAK,QAAQ,EAAG,CACrD,GAAI,EAAED,aAAoBwB,GACzB,MAAM,IAAI,MAAM,uBAAuB,EAExC,OAAO,MAAMxB,EAAS,OAAOC,EAAK,UAAU,CAAC,CAC9C,KACC,OAAM,IAAI,MAAM,kBAAkB,CAEpC,CACD,EC5MO,IAAIwB,GAAO,MAAOC,GACjB,MAAMC,EAAK,IAAID,CAAG,EAGfE,GAAM,MAChBF,GAGa,MADF,MAAMC,EAAK,IAAID,CAAG,GACL,IAAI,EAIlBG,GAASC,EAAY,QAAQ,EAa3BH,EAAN,MAAMI,CAAK,CACjBC,GACAC,GACAC,GACAC,GACAC,GACAC,GACAC,GACAC,GAEA,aAAa,IAAIb,EAA0C,CAC1D,IAAIc,EAAc,MAAMC,EAAQf,CAAG,EAC/BgB,EAASF,EAAY,OACrBG,EAAa,MAAMC,EAASJ,EAAY,UAAU,EAClDK,EAAgC,OAAO,YAC1C,MAAM,QAAQ,IACb,OAAO,QAAQL,EAAY,KAAO,CAAC,CAAC,EAAE,IAAI,MAAO,CAACM,EAAKC,CAAK,IAAM,CACjED,EACA,MAAMF,EAASG,CAAK,CACrB,CAAC,CACF,CACD,EACIC,EAAO,OAAO,YACjB,OAAO,QAAQH,CAAG,EAAE,IAAI,CAAC,CAACC,EAAKC,CAAK,IAAM,CAACD,EAAKC,EAAM,UAAU,CAAC,CAAC,CACnE,EACIE,EAAQ,MAAM,QAAQ,KACxBT,EAAY,MAAQ,CAAC,GAAG,IAAI,MAAOd,IAClC,MAAMkB,EAASlB,CAAG,GAAG,UAAU,CACjC,CACD,EACIwB,EAAWV,EAAY,UAAY,OACnCW,EAASX,EAAY,QAAU,GAC/BY,EAAUZ,EAAY,SAAW,GACrC,OAAOT,EAAK,YACHN,GAAK,IAAI,CAChB,OAAAiB,EACA,WAAYC,EAAW,UAAU,EACjC,IAAKK,EACL,KAAMC,EACN,SAAAC,EACA,OAAAC,EACA,QAAAC,CACD,CAAC,CACF,CACD,CAEA,YAAY1B,EAAqB,CAChC,KAAKM,GAASN,EAAI,MAClB,KAAKO,GAAUP,EAAI,OACnB,KAAKQ,GAAcR,EAAI,WACvB,KAAKS,GAAOT,EAAI,IAChB,KAAKU,GAAQV,EAAI,KACjB,KAAKW,GAAYX,EAAI,SACrB,KAAKY,GAAUZ,EAAI,OACnB,KAAKa,GAAWb,EAAI,OACrB,CAEA,WAA0B,CACzB,IAAI2B,EAAQ,KAAKrB,GAAO,UAAU,EAC9BU,EAAS,KAAKT,GACdU,EAAa,KAAKT,GAAY,UAAU,EACxCW,EAAM,OAAO,YAChB,OAAO,QAAQ,KAAKV,EAAI,EAAE,IAAI,CAAC,CAACW,EAAKC,CAAK,IAAM,CAACD,EAAKC,EAAM,UAAU,CAAC,CAAC,CACzE,EACIO,EAAO,KAAKlB,GAAM,IAAKV,GAAQA,EAAI,UAAU,CAAC,EAC9CwB,EAAW,KAAKb,GAChBc,EAAS,KAAKb,GACdc,EAAU,KAAKb,GACnB,MAAO,CACN,MAAAc,EACA,OAAAX,EACA,WAAAC,EACA,IAAAE,EACA,KAAAS,EACA,SAAAJ,EACA,OAAAC,EACA,QAAAC,CACD,CACD,CAEA,OAAO,YAAY3B,EAA0B,CAC5C,IAAI4B,EAAQE,EAAM,YAAY9B,EAAK,KAAK,EACpCiB,EAASjB,EAAK,OACdkB,EAAaa,EAAS,YAAY/B,EAAK,UAAU,EACjDoB,EAAM,OAAO,YAChB,OAAO,QAAQpB,EAAK,GAAG,EAAE,IAAI,CAAC,CAACqB,EAAKC,CAAK,IAAM,CAC9CD,EACAU,EAAS,YAAYT,CAAK,CAC3B,CAAC,CACF,EACIO,EAAO7B,EAAK,KAAK,IAAKC,GAAQ8B,EAAS,YAAY9B,CAAG,CAAC,EACvDwB,EAAWzB,EAAK,SAChB0B,EAAS1B,EAAK,OACd2B,EAAU3B,EAAK,QACnB,OAAO,IAAIM,EAAK,CACf,MAAAsB,EACA,OAAAX,EACA,WAAAC,EACA,IAAAE,EACA,KAAAS,EACA,SAAAJ,EACA,OAAAC,EACA,QAAAC,CACD,CAAC,CACF,CAEA,OAAe,CACd,OAAO,KAAKpB,EACb,CAEA,MAAM,KAAqC,CAC1C,IAAIyB,EAAoB,MAAcC,EAAU,WAC/CC,EAAU,UAAU,IAAI,CACzB,EAEA,OADaC,EAAM,YAAYH,CAAiB,CAEjD,CACD,ECxHO,IAAUI,OACLA,EAAA,GAAMC,GAEfA,IAAU,QACV,OAAOA,GAAU,WACjB,OAAOA,GAAU,UACjB,OAAOA,GAAU,UACjBA,aAAiB,YACjBA,aAAiBC,GACjBD,aAAiBE,GACjBF,aAAiBG,GACjBH,aAAiBI,GACjBJ,aAAiBK,GACjBL,aAAiBM,GACjBN,aAAiBO,GACjBP,aAAiBQ,GACjBR,aAAiBS,GACjBT,aAAiBU,GACjBV,aAAiBW,GACjBX,aAAiBY,GACjBZ,aAAiB,OACjB,OAAOA,GAAU,SAIRD,EAAA,OAAUC,IACpBa,KAAQd,EAAA,IAAGC,CAAK,CAAC,EACVA,GAGGD,EAAA,OAAUC,GAA2C,CAC/Da,KAAQd,EAAA,IAAGC,CAAK,CAAC,CAClB,EAEWD,EAAA,UAA8BC,GACpCA,IAAU,OACN,CACN,KAAM,MACP,EACU,OAAOA,GAAU,UACpB,CACN,KAAM,OACN,MAAAA,CACD,EACU,OAAOA,GAAU,SACpB,CACN,KAAM,SACN,MAAAA,CACD,EACU,OAAOA,GAAU,SACpB,CACN,KAAM,SACN,MAAAA,CACD,EACUA,aAAiB,WACpB,CACN,KAAM,QACN,MAAAA,CACD,EACUA,aAAiBC,EACpB,CACN,KAAM,UACN,MAAOD,EAAM,UAAU,CACxB,EACUA,aAAiBE,EACpB,CACN,KAAM,UACN,MAAOF,EAAM,UAAU,CACxB,EACUA,aAAiBI,EACpB,CACN,KAAM,QACN,MAAOJ,EAAM,UAAU,CACxB,EACUA,aAAiBG,EACpB,CACN,KAAM,OACN,MAAOH,EAAM,UAAU,CACxB,EACUc,EAAS,GAAGd,CAAK,EACpB,CACN,KAAM,WACN,MAAOc,EAAS,UAAUd,CAAK,CAChC,EACUA,aAAiBQ,EACpB,CACN,KAAM,cACN,MAAOR,EAAM,UAAU,CACxB,EACUA,aAAiBS,EACpB,CACN,KAAM,WACN,MAAOT,EAAM,UAAU,CACxB,EACUe,EAAU,GAAGf,CAAK,EACrB,CACN,KAAM,YACN,MAAOe,EAAU,UAAUf,CAAK,CACjC,EACUA,aAAiB,MAEpB,CACN,KAAM,QACN,MAHkBA,EAAM,IAAKA,GAAUD,EAAM,UAAUC,CAAK,CAAC,CAI9D,EACU,OAAOA,GAAU,SAOpB,CACN,KAAM,SACN,MARkB,OAAO,YACzB,OAAO,QAAQA,CAAK,EAAE,IAAI,CAAC,CAACgB,EAAKhB,CAAK,IAAM,CAC3CgB,EACAjB,EAAM,UAAUC,CAAK,CACtB,CAAC,CACF,CAIA,EAEOiB,EAAY,EAIVlB,EAAA,YAAeC,GAAgC,CACzD,OAAQA,EAAM,KAAM,CACnB,IAAK,OACJ,OAED,IAAK,OACJ,OAAOA,EAAM,MAEd,IAAK,SACJ,OAAOA,EAAM,MAEd,IAAK,SACJ,OAAOA,EAAM,MAEd,IAAK,QACJ,OAAOA,EAAM,MAEd,IAAK,UACJ,OAAOC,EAAQ,YAAYD,EAAM,KAAK,EAEvC,IAAK,UACJ,OAAOE,EAAQ,YAAYF,EAAM,KAAK,EAEvC,IAAK,QACJ,OAAOI,EAAM,YAAYJ,EAAM,KAAK,EAErC,IAAK,OACJ,OAAOG,EAAK,YAAYH,EAAM,KAAK,EAEpC,IAAK,WACJ,OAAOc,EAAS,YAAYd,EAAM,KAAK,EAExC,IAAK,cACJ,OAAOQ,EAAY,YAAYR,EAAM,KAAK,EAE3C,IAAK,WACJ,OAAOS,EAAS,YAAYT,EAAM,KAAK,EAExC,IAAK,YACJ,OAAOe,EAAU,YAAYf,EAAM,KAAK,EAEzC,IAAK,QACJ,OAAOA,EAAM,MAAM,IAAKA,GAAUD,EAAM,YAAYC,CAAK,CAAC,EAE3D,IAAK,SACJ,OAAO,OAAO,YACb,OAAO,QAAQA,EAAM,KAAK,EAAE,IAAI,CAAC,CAACgB,EAAKhB,CAAK,IAAM,CACjDgB,EACAjB,EAAM,YAAYC,CAAK,CACxB,CAAC,CACF,EAED,QACC,OAAOiB,EAAY,CAErB,CACD,IAjLgBlB,IAAA,ICvBV,IAAImB,EAA4C,CAAC,EAW7CC,GAIVC,GACI,CAEJC,EAAQD,EAAI,OAAO,OAAS,QAAQ,EACpC,IAAID,EAASG,EAAO,YACXH,EAAO,IAAI,CAClB,QAASC,EAAI,OAAO,MAAM,QAC1B,WAAYA,EAAI,OAAO,MAAM,WAC7B,KAAMA,EAAI,KACV,IAAK,CAAC,EACN,KAAM,CAAC,CACR,CAAC,CACF,EACAD,EAAO,EAAIC,EAAI,EAGf,IAAIG,EAAMC,EAAK,OAAO,CAAE,OAAQJ,EAAI,OAAQ,KAAMA,EAAI,IAAK,CAAC,EAC5D,OAAAC,EAAQH,EAAQK,CAAG,IAAM,MAAS,EAClCL,EAAQK,CAAG,EAAIJ,EAERA,CACR,EAEWM,GAAa,MACvBC,EACAC,EACAC,IAC4B,CAE5BC,EAAI,MAAQ,OAAO,YAClB,OAAO,QAAQF,CAAU,EAAE,IAAI,CAAC,CAACJ,EAAKO,CAAK,IAAM,CAChDP,EACAQ,EAAM,YAAYD,CAAK,CACxB,CAAC,CACF,EAGA,IAAIE,EAAOJ,EAAY,IAAKE,GAAUC,EAAM,YAAYD,CAAK,CAAC,EAG1DG,EAAS,MAAMP,EAAE,GAAGM,CAAI,EAK5B,OAFoBD,EAAM,UAAUE,CAAM,CAG3C,EA4BaX,EAAN,MAAMY,UAGH,WAAW,QAAS,CAC7B,EACA,MACA,QACA,WACA,KACA,IACA,KAEA,OAAO,IACNd,EACe,CACf,IAAIe,EAAO,OAAO,YACjB,OAAO,QAAQf,EAAI,KAAO,CAAC,CAAC,EAAE,IAAI,CAAC,CAACG,EAAKO,CAAK,IAAM,CACnDP,EACAQ,EAAM,UAAUD,CAAK,CACtB,CAAC,CACF,EACIM,GAAShB,EAAI,MAAQ,CAAC,GAAG,IAAKU,GAAUC,EAAM,UAAUD,CAAK,CAAC,EAC9DX,EAASe,EAAO,YACXf,EAAO,IAAI,CAClB,QAASC,EAAI,OAAO,QAAQ,UAAU,EACtC,WAAYA,EAAI,OAAO,WAAW,UAAU,EAC5C,KAAMA,EAAI,OAAO,KACjB,IAAKe,EACL,KAAMC,CACP,CAAC,CACF,EACA,OAAAjB,EAAO,EAAIC,EAAI,OAAO,EACfD,CACR,CAEA,YAAYC,EAA2B,CACtC,aAAM,EAEN,KAAK,EAAIA,EAAI,EACb,KAAK,MAAQA,EAAI,MACjB,KAAK,QAAUA,EAAI,QACnB,KAAK,WAAaiB,EAAQjB,EAAI,UAAU,EACxC,KAAK,KAAOA,EAAI,KAChB,KAAK,IAAMA,EAAI,IACf,KAAK,KAAOA,EAAI,KAGT,IAAI,MAAM,KAAM,CACtB,MAAO,MAAOD,EAAQmB,EAAGN,IAAS,CACjC,IAAIO,EAAUL,EAAO,IAAI,CACxB,OAAAf,EACA,KAAO,MAAM,QAAQ,IAAIa,EAAK,IAAIQ,CAAO,CAAC,EAC1C,IAAKX,EAAI,KACV,CAAC,EACGY,EAAgB,MAAcC,EAAU,WAC3CC,EAAU,UAAUJ,CAAoB,CACzC,EAEA,OADaR,EAAM,YAAYU,CAAa,CAE7C,CACD,CAAC,CACF,CAEA,OAAO,GAAGX,EAAiC,CAC1C,OAAOA,aAAiBI,CACzB,CAEA,OAAO,OAAOJ,EAAwB,CACrC,OAAAT,EAAQa,EAAO,GAAGJ,CAAK,CAAC,EACjBA,CACR,CAEA,OAAO,OAAOA,EAAyC,CACtDT,EAAQa,EAAO,GAAGJ,CAAK,CAAC,CACzB,CAEA,WAA4B,CAC3B,IAAIc,EAAQ,KAAK,MAAM,UAAU,EAC7BC,EAAW,KAAK,QAAQ,UAAU,EAClCC,EAAa,KAAK,WAAW,SAAS,EACtCC,EAAO,KAAK,KACZlB,EAAM,KAAK,IACZ,OAAO,YACP,OAAO,QAAQ,KAAK,GAAG,EAAE,IAAI,CAAC,CAACN,EAAKO,CAAK,IAAM,CAC9CP,EACAQ,EAAM,UAAUD,CAAK,CACtB,CAAC,CACD,EACA,OACCE,EAAO,KAAK,KACb,KAAK,KAAK,IAAKZ,GAAQW,EAAM,UAAUX,CAAG,CAAC,EAC3C,OACH,MAAO,CACN,MAAAwB,EACA,QAASC,EACT,WAAAC,EACA,KAAAC,EACA,IAAAlB,EACA,KAAAG,CACD,CACD,CAEA,OAAO,YAGLb,EAAsC,CACvC,IAAIyB,EAAQI,EAAM,YAAY7B,EAAO,KAAK,EACtC0B,EAAWG,EAAM,YAAY7B,EAAO,OAAO,EAC3C2B,EAAa3B,EAAO,WACpB4B,EAAO5B,EAAO,KACdU,EACHV,EAAO,MAAQ,OACZ,OAAO,YACP,OAAO,QAAQA,EAAO,GAAG,EAAE,IAAI,CAAC,CAACI,EAAKO,CAAK,IAAM,CAChDP,EACAQ,EAAM,YAAYD,CAAK,CACxB,CAAC,CACD,EACA,OACAE,EACHb,EAAO,OAAS,OACZA,EAAO,KAAK,IAAKC,GAAQW,EAAM,YAAYX,CAAG,CAAC,EAChD,OACJ,OAAO,IAAIc,EAAO,CACjB,MAAAU,EACA,QAASC,EACT,WAAAC,EACA,KAAAC,EACA,IAAAlB,EACA,KAAAG,CACD,CAAC,CACF,CACD,EC/NO,IAAUiB,OACLA,EAAA,GAAMC,GAEfA,aAAiBC,GACjBD,aAAiBE,GACjBF,aAAiBG,EAIRJ,EAAA,UAAaK,GACnBA,aAAqBH,EACjB,CACN,KAAM,WACN,MAAOG,EAAU,UAAU,CAC5B,EACUA,aAAqBF,EACxB,CACN,KAAM,SACN,MAAOE,EAAU,UAAU,CAC5B,EACUA,aAAqBD,EACxB,CACN,KAAM,OACN,MAAOC,EAAU,UAAU,CAC5B,EAEOC,EAAY,EAIVN,EAAA,YAAeK,GAA4C,CACrE,OAAQA,EAAU,KAAM,CACvB,IAAK,WACJ,OAAOH,EAAS,YAAYG,EAAU,KAAK,EAE5C,IAAK,SACJ,OAAOF,EAAO,YAAYE,EAAU,KAAK,EAE1C,IAAK,OACJ,OAAOD,EAAK,YAAYC,EAAU,KAAK,EAExC,QACC,OAAOC,EAAY,CAErB,CACD,IA7CgBN,IAAA,ICAV,IAAIO,GAAW,MAAOC,GACrB,MAAMC,EAAS,IAAID,CAAG,EAGnBE,GAAW,MAAOF,GAEf,MADE,MAAMC,EAAS,IAAID,CAAG,GACT,SAAS,EAYzBC,EAAN,MAAME,CAAS,CACrBC,GACAC,GACAC,GACAC,GACAC,GAEA,aAAa,IAAIR,EAAsC,CACtD,OAAOG,EAAS,YACPJ,GAAS,IAAI,CACpB,IAAKC,EAAI,IACT,OAAQA,EAAI,QAAU,OACtB,SAAUA,EAAI,UAAY,OAC1B,OAAQA,EAAI,QAAU,EACvB,CAAC,CACF,CACD,CAEA,YAAYA,EAAqB,CAChC,KAAKI,GAASJ,EAAI,MAClB,KAAKK,GAAOL,EAAI,IAChB,KAAKM,GAAUN,EAAI,QAAU,OAC7B,KAAKO,GAAYP,EAAI,UAAY,OACjC,KAAKQ,GAAUR,EAAI,QAAU,EAC9B,CAEA,OAAO,GAAGS,EAAmC,CAC5C,OAAOA,aAAiBN,CACzB,CAEA,OAAO,OAAOM,EAA0B,CACvC,OAAAC,EAAQP,EAAS,GAAGM,CAAK,CAAC,EACnBA,CACR,CAEA,OAAO,OAAOA,EAA2C,CACxDC,EAAQP,EAAS,GAAGM,CAAK,CAAC,CAC3B,CAEA,OAAe,CACd,OAAO,KAAKL,EACb,CAEA,WAA8B,CAC7B,MAAO,CACN,MAAO,KAAKA,GAAO,UAAU,EAC7B,IAAK,KAAKC,GACV,OAAQ,KAAKC,GACb,SAAU,KAAKC,GACf,OAAQ,KAAKC,EACd,CACD,CAEA,OAAO,YAAYN,EAAsC,CACxD,OAAO,IAAIC,EAAS,CACnB,MAAOQ,EAAM,YAAYT,EAAS,KAAK,EACvC,IAAKA,EAAS,IACd,OAAQA,EAAS,OACjB,SAAUA,EAAS,SACnB,OAAQA,EAAS,MAClB,CAAC,CACF,CAEA,MAAM,UAA8B,CACnC,IAAIU,EAAoB,MAAcC,EAAU,WAC/CC,EAAU,UAAU,IAAI,CACzB,EAEA,OADaC,EAAM,YAAYH,CAAiB,CAEjD,CACD,ECjCO,IAAII,EAAU,MACpBC,GAC0B,CAE1B,GADAA,EAAQ,MAAMA,EAEbA,IAAU,QACV,OAAOA,GAAU,WACjB,OAAOA,GAAU,UACjB,OAAOA,GAAU,UACjBA,aAAiB,YACjBA,aAAiBC,GACjBD,aAAiBE,GACjBF,aAAiBG,GACjBH,aAAiBI,GACjBJ,aAAiBK,GACjBL,aAAiBM,GACjBN,aAAiBO,GACjBP,aAAiBQ,GACjBR,aAAiBS,GACjBT,aAAiBU,GACjBV,aAAiBW,EAEjB,OAAOX,EACD,GAAIA,aAAiB,MAC3B,OAAQ,MAAM,QAAQ,IACrBA,EAAM,IAAKA,GAAUD,EAAQC,CAAK,CAAC,CACpC,EACM,GAAI,OAAOA,GAAU,SAC3B,OAAO,OAAO,YACb,MAAM,QAAQ,IACb,OAAO,QAAQA,CAAK,EAAE,IAAI,MAAO,CAACY,EAAKZ,CAAK,IAAM,CACjDY,EACA,MAAMb,EAAQC,CAAK,CACpB,CAAC,CACF,CACD,EAEA,MAAM,IAAI,MAAM,2BAA2B,CAE7C,EC/FO,IAAIa,GAAQ,SAAUC,IACrB,MAAMC,EAAM,IAAI,GAAGD,CAAI,EAOlBC,EAAN,MAAMC,CAAM,CAClBC,GAEA,aAAa,OAAOH,EAAoD,CAEvE,GAAI,CAAE,SAAAI,EAAU,KAAMC,CAAY,EAAIC,EACrC,MAAM,QAAQ,IACbN,EAAK,IAAI,eAAeO,EAAIC,EAK1B,CACD,IAAIC,EAAM,MAAMC,EAAQF,CAAa,EACrC,GAAIC,IAAQ,OACX,MAAO,CAAC,EACF,GAAI,OAAOA,GAAQ,SACzB,MAAO,CAAE,KAAM,CAAUE,EAAK,OAAOF,CAAG,CAAC,CAAE,EACrC,GAAIA,aAAe,WACzB,MAAO,CAAE,KAAM,CAACA,CAAG,CAAE,EACf,GAAIA,aAAeP,EACzB,MAAO,CACN,SAAU,MAAMO,EAAI,SAAS,EAC7B,KAAM,CAAC,MAAMA,EAAI,MAAM,CAAC,CACzB,EACM,GAAIA,aAAe,MACzB,OAAO,MAAM,QAAQ,IAAIA,EAAI,IAAIF,CAAG,CAAC,EAC/B,GAAI,OAAOE,GAAQ,SAAU,CACnC,IAAIL,EAAW,MAAM,QAAQ,KAC3BK,EAAI,UAAY,CAAC,GAAG,IAAKG,GAAUV,EAAM,IAAIU,CAAK,CAAC,CACrD,EACIC,EACH,OAAOJ,EAAI,MAAS,SACjB,CAAUE,EAAK,OAAOF,EAAI,IAAI,CAAC,EAC/BA,EAAI,gBAAgB,WACpB,CAACA,EAAI,IAAI,EACT,CAAC,EACL,MAAO,CACN,SAAAL,EACA,KAAAS,CACD,CACD,KACC,QAAOC,EAAY,CAErB,CAAC,CACF,CACD,EAAE,OAID,CAACC,EAAO,CAAE,SAAAX,EAAU,KAAAS,CAAK,KACpBT,IAAa,QAChBW,EAAM,SAAS,KAAK,GAAGX,CAAQ,EAE5BS,IAAS,QACZE,EAAM,KAAK,KAAK,GAAGF,CAAI,EAEjBE,GAER,CAAE,SAAU,CAAC,EAAG,KAAM,CAAC,CAAE,CAC1B,EAGIC,EAASX,EAAY,OACxB,CAACW,EAAQC,IAAcD,EAASC,EAAU,OAC1C,CACD,EACIJ,EAAO,IAAI,WAAWG,CAAM,EAC5BE,EAAW,EACf,QAASD,KAAaZ,EACrBQ,EAAK,IAAII,EAAWC,CAAQ,EAC5BA,GAAYD,EAAU,OAGvB,OAAOf,EAAM,YACZ,MAAcH,EAAM,IAAI,CACvB,KAAAc,EACA,SAAUT,EAAS,IAAKL,GAAUA,EAAM,UAAU,CAAC,CACpD,CAAC,CACF,CACD,CAEA,YAAYU,EAAqB,CAChC,KAAKN,GAAMM,EAAI,EAChB,CAEA,OAAO,GAAGM,EAAgC,CACzC,OAAOA,aAAiBb,CACzB,CAEA,OAAO,OAAOa,EAAuB,CACpC,OAAAI,EAAQjB,EAAM,GAAGa,CAAK,CAAC,EAChBA,CACR,CAEA,OAAO,OAAOA,EAAwC,CACrDI,EAAQjB,EAAM,GAAGa,CAAK,CAAC,CACxB,CAEA,WAA2B,CAC1B,MAAO,CACN,GAAI,KAAKZ,EACV,CACD,CAEA,OAAO,YAAYY,EAA6B,CAC/C,IAAIK,EAAKL,EAAM,GACf,OAAO,IAAIb,EAAM,CAAE,GAAAkB,CAAG,CAAC,CACxB,CAEA,IAAS,CACR,OAAO,KAAKjB,EACb,CAEA,MAAM,OAA6B,CAClC,OAAO,MAAcJ,EAAM,MAAM,KAAK,UAAU,CAAC,CAClD,CAEA,MAAM,UAAkC,CACvC,OAAQ,MAAcA,EAAM,SAAS,KAAK,UAAU,CAAC,GAAG,IAAKA,GAC5DG,EAAM,YAAYH,CAAK,CACxB,CACD,CAEA,MAAM,MAA4B,CACjC,OAAO,MAAcA,EAAM,KAAK,KAAK,UAAU,CAAC,CACjD,CACD,GAEiBE,GAAV,CAcC,IAAUoB,OACLA,EAAA,GAAMN,GAEfA,IAAU,QACV,OAAOA,GAAU,UACjBA,aAAiB,YACjBA,aAAiBd,GAChBc,aAAiB,OAASA,EAAM,MAAMM,EAAI,EAAE,EAIpCA,EAAA,OAAUN,IACpBI,KAAQE,EAAA,IAAGN,CAAK,CAAC,EACVA,GAGGM,EAAA,OAAUN,GAAyC,CAC7DI,KAAQE,EAAA,IAAGN,CAAK,CAAC,CAClB,IAlBgBM,EAAApB,EAAA,YAdDA,IAAA,IC1IV,IAAIqB,EAAO,SAAUC,IACpB,MAAMC,EAAK,IAAI,GAAGD,CAAI,EAQjBC,EAAN,MAAMC,CAAK,CACjBC,GACAC,GAEA,aAAa,IAAIC,EAA6B,CAC7C,OAAOH,EAAK,YAAY,MAAcH,EAAK,IAAIM,EAAM,UAAU,CAAC,CAAC,CAClE,CAEA,aAAa,OAAOL,EAAkD,CACrE,IAAIM,EAASC,EACZ,MAAM,QAAQ,IACbP,EAAK,IAAI,eAAeQ,EACvBC,EACmC,CACnC,IAAIC,EAAM,MAAMC,EAAQF,CAAa,EACrC,OAAIG,EAAM,IAAI,GAAGF,CAAG,EACZ,MAAML,GAAMK,CAAG,EACZA,aAAeR,EAClBQ,EAAI,MAAM,EACPA,aAAe,MAClB,MAAM,QAAQ,IAAIA,EAAI,IAAIF,CAAG,CAAC,EAE9BK,EAAY,CAErB,CAAC,CACF,CACD,EAAE,OAAqB,CAACP,EAAQD,KAC/BC,EAAO,KAAKD,CAAK,EACVC,GACL,CAAC,CAAC,EACL,OAAOJ,EAAK,YACX,MAAcH,EAAK,IAAI,CACtB,SAAUO,EAAO,IAAKD,GAAUA,EAAM,UAAU,CAAC,CAClD,CAAC,CACF,CACD,CAEA,YAAYK,EAAqB,CAChC,KAAKP,GAASO,EAAI,MAClB,KAAKN,GAAQM,EAAI,IAClB,CAEA,OAAO,GAAGI,EAA+B,CACxC,OAAOA,aAAiBZ,CACzB,CAEA,OAAO,OAAOY,EAAsB,CACnC,OAAAC,EAAQb,EAAK,GAAGY,CAAK,CAAC,EACfA,CACR,CAEA,OAAO,OAAOA,EAAuC,CACpDC,EAAQb,EAAK,GAAGY,CAAK,CAAC,CACvB,CAEA,WAA0B,CACzB,MAAO,CACN,MAAO,KAAKX,GAAO,UAAU,EAC7B,KAAM,KAAKC,EACZ,CACD,CAEA,OAAO,YAAYU,EAA2B,CAC7C,IAAIT,EAAQO,EAAM,YAAYE,EAAM,KAAK,EACrCE,EAAOF,EAAM,KACjB,OAAO,IAAIZ,EAAK,CAAE,MAAAG,EAAO,KAAAW,CAAK,CAAC,CAChC,CAEA,OAAe,CACd,OAAO,KAAKb,EACb,CAEA,MAAM,OAA6B,CAClC,OAAO,MAAcJ,EAAK,MAAM,KAAK,UAAU,CAAC,CACjD,CAEA,MAAM,MAAwB,CAC7B,OAAO,MAAcA,EAAK,KAAK,KAAK,UAAU,CAAC,CAChD,CACD,GAEiBE,GAAV,CAGC,IAAUgB,OACLA,EAAA,GAAMH,GAEfF,EAAM,IAAI,GAAGE,CAAK,GAClBA,aAAiBb,GAChBa,aAAiB,OAASA,EAAM,MAAMG,EAAI,EAAE,EAIpCA,EAAA,OAAUH,IACpBC,KAAQE,EAAA,IAAGH,CAAK,CAAC,EACVA,GAGGG,EAAA,OAAUH,GAAyC,CAC7DC,KAAQE,EAAA,IAAGH,CAAK,CAAC,CAClB,IAhBgBG,EAAAhB,EAAA,YAHDA,IAAA,ICtFV,IAAIiB,GAAY,SAAUC,IACzB,MAAMC,EAAU,IAAI,GAAGD,CAAI,EAQtBC,EAAN,MAAMC,CAAU,CACtBC,GACAC,GAEA,aAAa,OACTJ,EACkB,CACrB,IAAIK,EAAU,MACb,MAAM,QAAQ,IAAIL,EAAK,IAAIM,CAAO,CAAC,GAClC,OAA0C,eAAeC,EAC1DC,EACAC,EACC,CACD,IAAIJ,EAAU,MAAMG,EACpB,GAAIC,IAAQ,OAEL,GAAIA,aAAeP,EAEzB,OAAS,CAACQ,EAAMC,CAAK,IAAK,OAAO,QAAQ,MAAMF,EAAI,QAAQ,CAAC,EAAG,CAE9D,IAAIG,EAAgBP,EAAQK,CAAI,EAI/BE,aAAyBV,GACzBS,aAAiBT,IAEjBS,EAAQ,MAAMT,EAAU,IAAIU,EAAeD,CAAK,GAIjDN,EAAQK,CAAI,EAAIC,CACjB,SACUF,aAAe,MACzB,QAASI,KAAYJ,EACpBJ,EAAU,MAAME,EAAO,QAAQ,QAAQF,CAAO,EAAGQ,CAAQ,UAEhD,OAAOJ,GAAQ,SAEzB,OAAS,CAACK,EAAKC,CAAK,IAAK,OAAO,QAAQN,CAAG,EAAG,CAE7C,GAAI,CAACO,EAAgB,GAAGC,CAAkB,EACzCC,EAAQJ,CAAG,EAAE,WAAW,EACzB,GAAIE,IAAmB,OACtB,MAAM,IAAI,MAAM,4CAA4C,EAE7D,IAAIN,EAAOM,EAGPJ,EAAgBP,EAAQK,CAAI,EAOhC,GAJME,aAAyBV,IAC9BU,EAAgB,QAGbK,EAAmB,OAAS,EAAG,CAElC,IAAIE,EAAeD,EAAQD,CAAkB,EAAE,SAAS,EAGpDG,GAAW,MAAMlB,EAAU,IAAIU,EAAe,CACjD,CAACO,CAAY,EAAGJ,CACjB,CAAC,EAGDV,EAAQK,CAAI,EAAIU,EACjB,SAEKL,IAAU,OACb,OAAOV,EAAQK,CAAI,UACTW,EAAK,IAAI,GAAGN,CAAK,EAAG,CAC9B,IAAIK,EAAW,MAAME,EAAKP,CAAK,EAC/BV,EAAQK,CAAI,EAAIU,CACjB,SAAWG,EAAK,GAAGR,CAAK,GAAKS,EAAQ,GAAGT,CAAK,EAC5CV,EAAQK,CAAI,EAAIK,MACV,CACN,IAAIK,EAAW,MAAMlB,EAAU,IAAIU,EAAeG,CAAK,EACvDV,EAAQK,CAAI,EAAIU,CACjB,CAEF,KAEA,QAAOK,EAAY,EAEpB,OAAOpB,CACR,EACA,QAAQ,QAAQ,CAAC,CAAC,CAAC,EACnB,OAAOH,EAAU,YACRH,GAAU,IAAI,CACrB,QAAS,OAAO,YACf,OAAO,QAAQM,CAAO,EAAE,IAAI,CAAC,CAACK,EAAMC,CAAK,IAAM,CAC9CD,EACAgB,EAAS,UAAUf,CAAK,CACzB,CAAC,CACF,CACD,CAAC,CACF,CACD,CAEA,YAAYF,EAAqB,CAChC,KAAKN,GAASM,EAAI,MAClB,KAAKL,GAAWK,EAAI,OACrB,CAEA,OAAO,GAAGM,EAAoC,CAC7C,OAAOA,aAAiBb,CACzB,CAEA,OAAO,OAAOa,EAA2B,CACxC,OAAAY,EAAQzB,EAAU,GAAGa,CAAK,CAAC,EACpBA,CACR,CAEA,OAAO,OAAOA,EAA4C,CACzDY,EAAQzB,EAAU,GAAGa,CAAK,CAAC,CAC5B,CAEA,WAA+B,CAC9B,IAAIa,EAAQ,KAAKzB,GAAO,UAAU,EAC9BE,EAAU,OAAO,YACpB,OAAO,QAAQ,KAAKD,EAAQ,EAAE,IAAI,CAAC,CAACM,EAAMC,CAAK,IAAM,CACpDD,EACAC,EAAM,UAAU,CACjB,CAAC,CACF,EACA,MAAO,CACN,MAAAiB,EACA,QAAAvB,CACD,CACD,CAEA,OAAO,YAAYN,EAAyC,CAC3D,IAAI6B,EAAQC,EAAM,YAAY9B,EAAU,KAAK,EACzCM,EAAU,OAAO,YACpB,OAAO,QAAQN,EAAU,OAAO,EAAE,IAAI,CAAC,CAACW,EAAMC,CAAK,IAAM,CACxDD,EACAmB,EAAM,YAAYlB,CAAK,CACxB,CAAC,CACF,EACA,OAAO,IAAIT,EAAU,CAAE,MAAA0B,EAAO,QAAAvB,CAAQ,CAAC,CACxC,CAEA,OAAe,CACd,OAAO,KAAKF,EACb,CAEA,MAAM,IAAIM,EAA6C,CACtD,IAAIqB,EAAW,MAAM,KAAK,OAAOrB,CAAG,EACpC,OAAAkB,EAAQG,EAAU,sCAAsCrB,CAAG,IAAI,EACxDqB,CACR,CAEA,MAAM,OAAOrB,EAAyD,CACrE,IAAIqB,EAA6B,KAC7BC,EAAiBb,EAAQ,EAC7BT,EAAMS,EAAQT,CAAG,EACjB,QAASuB,KAAavB,EAAI,WAAW,EAAG,CACvC,GAAI,EAAEqB,aAAoB5B,GACzB,OAED6B,EAAe,KAAKC,CAAS,EAC7B,IAAIC,EAAaH,EAAS1B,GAAS4B,CAAS,EAC5C,GAAIC,IAAe,OAClB,OAED,IAAItB,EAAQ,MAAMe,EAAS,IAAIO,CAAU,EACzC,GAAItB,aAAiBa,EAAS,CAC7B,IAAIU,EAAW,MAAMvB,EAAM,QAAQ,CAClC,SAAU,KACV,KAAMoB,CACP,CAAC,EACD,GAAIG,IAAa,OAChB,OAEDJ,EAAWI,CACZ,MACCJ,EAAWnB,CAEb,CACA,OAAOmB,CACR,CAEA,MAAM,SAA6C,CAClD,IAAIzB,EAAoC,CAAC,EACzC,aAAe,CAACK,EAAMoB,CAAQ,IAAK,KAClCzB,EAAQK,CAAI,EAAIoB,EAEjB,OAAOzB,CACR,CAEA,MAAM,QAA6B,CAClC,IAAI8B,EAAkBT,EAAS,YAC9B,MAAcI,EAAS,OAAOJ,EAAS,UAAU,IAAI,CAAC,CACvD,EACA,OAAAC,EAAQzB,EAAU,GAAGiC,CAAe,CAAC,EAC9BA,CACR,CAEA,MAAO,MAAmD,CACzD,aAAe,CAACzB,EAAMoB,CAAQ,IAAK,KAElC,GADA,KAAM,CAACZ,EAAQR,CAAI,EAAGoB,CAAQ,EAC1B5B,EAAU,GAAG4B,CAAQ,EACxB,aAAe,CAACM,EAAWC,CAAa,IAAKP,EAAS,KAAK,EAC1D,KAAM,CAACZ,EAAQR,CAAI,EAAE,KAAK0B,CAAS,EAAGC,CAAa,CAIvD,CAEA,EAAE,OAAO,QAAQ,GAA+B,CAC/C,OAAS,CAAC3B,EAAMC,CAAK,IAAK,OAAO,QAAQ,KAAKP,EAAQ,EACrD,KAAM,CAACM,EAAMC,CAAK,CAEpB,CAEA,OAAQ,OAAO,aAAa,GAAuC,CAClE,OAAS,CAACD,EAAMC,CAAK,IAAK,KACzB,KAAM,CAACD,EAAM,MAAMgB,EAAS,IAAIf,CAAK,CAAC,CAExC,CACD,ECvOO,IAAU2B,OACLA,EAAA,GAAMC,GAEfA,aAAiBC,GACjBD,aAAiBE,GACjBF,aAAiBG,EAIRJ,EAAA,OAAUC,IACpBI,KAAQL,EAAA,IAAGC,CAAK,CAAC,EACVA,GAGGD,EAAA,OAAUC,GAA8C,CAClEI,KAAQL,EAAA,IAAGC,CAAK,CAAC,CAClB,EAEWD,EAAA,IAAM,MAAOM,GAChBN,EAAS,YAAY,MAAcO,EAAS,IAAID,EAAM,UAAU,CAAC,CAAC,EAG/DN,EAAA,UAAaO,GACnBA,aAAoBL,EAChB,CACN,KAAM,YACN,MAAOK,EAAS,UAAU,CAC3B,EACUA,aAAoBJ,EACvB,CACN,KAAM,OACN,MAAOI,EAAS,UAAU,CAC3B,EACUA,aAAoBH,EACvB,CACN,KAAM,UACN,MAAOG,EAAS,UAAU,CAC3B,EAEOC,EAAY,EAIVR,EAAA,YAAeO,GAAyC,CAClE,OAAQA,EAAS,KAAM,CACtB,IAAK,YACJ,OAAOL,EAAU,YAAYK,EAAS,KAAK,EAE5C,IAAK,OACJ,OAAOJ,EAAK,YAAYI,EAAS,KAAK,EAEvC,IAAK,UACJ,OAAOH,EAAQ,YAAYG,EAAS,KAAK,EAE1C,QACC,OAAOC,EAAY,CAErB,CACD,IA1DgBR,IAAA,ICTV,IAAIS,GAAoB,CAC9BC,EACAC,KAmBO,CAAE,UAjBOA,EAAqB,IAAKC,IAClC,CACN,SAAUA,EAAS,YAAY,EAC/B,aAAcA,EAAS,gBAAgB,EACvC,WAAYA,EAAS,cAAc,EACnC,SAAUA,EAAS,YAAY,EAC/B,WAAYA,EAAS,cAAc,EACnC,aAAcA,EAAS,gBAAgB,EACvC,OAAQA,EAAS,OAAO,EACxB,SAAUA,EAAS,SAAS,EAC5B,cAAeA,EAAS,cAAc,EACtC,QAASA,EAAS,QAAQ,EAC1B,aAAcA,EAAS,aAAa,EAEpC,aAAcA,EAAS,gBAAgB,CACxC,EACA,CACkB,GCTb,IAAIC,GAAU,MAAOC,GAAgC,CAC3DC,EAAOD,EAAI,OAAO,OAAS,QAAQ,EACnC,IAAIE,EAAW,MAAMC,EAAS,IAC7BC,EAAM,YAAYJ,EAAI,OAAO,MAAM,OAAO,CAC3C,EACAK,EAAU,OAAOH,CAAQ,EACzB,IAAII,EAAOC,EAAQP,EAAI,OAAO,MAAM,UAAU,EAC5C,UAAU,EACV,OAAO,EACP,KAAKA,EAAI,IAAI,EACb,UAAU,EAEZ,OADuBE,EAAS,IAAII,CAAI,CAEzC,ECXO,IAAIE,GAAM,IAAIC,IAAyB,CAC7C,IAAIC,EAASD,EAAK,IAAKE,GAAQC,GAAUD,CAAG,CAAC,EAAE,KAAK,GAAG,EAC/CH,GAAIE,CAAM,CACnB,EAEIE,GAAaC,GACTC,EAAeD,EAAO,IAAI,OAAS,EAGvCC,EAAiB,CAACD,EAAgBE,IAAqC,CAC1E,OAAQ,OAAOF,EAAO,CACrB,IAAK,SACJ,MAAO,IAAIA,CAAK,IAEjB,IAAK,SACJ,OAAOA,EAAM,SAAS,EAEvB,IAAK,UACJ,OAAOA,EAAQ,OAAS,QAEzB,IAAK,YACJ,MAAO,YAER,IAAK,SACJ,OAAIA,IAAU,KACN,OAEAG,GAAgBH,EAAOE,CAAO,EAGvC,IAAK,WACJ,MAAO,cAAcF,EAAM,MAAQ,aAAa,KAEjD,IAAK,SACJ,MAAO,WAER,IAAK,SACJ,OAAOA,EAAM,SAAS,CAExB,CACD,EAEIG,GAAkB,CAACH,EAAeE,IAAqC,CAE1E,GAAIA,EAAQ,IAAIF,CAAK,EACpB,MAAO,aAMR,GAFAE,EAAQ,IAAIF,CAAK,EAEbA,aAAiB,MAEpB,MAAO,IAAIA,EACT,IAAKA,GAAUC,EAAeD,EAAOE,CAAO,CAAC,EAC7C,KAAK,IAAI,CAAC,IACN,GAAIF,aAAiB,MAE3B,OAAOA,EAAM,OAAS,GAChB,GAAIA,aAAiB,QAE3B,MAAO,YACD,GAAIA,aAAiBI,EAC3B,MAAO,eAAeJ,EAAM,SAAS,CAAC,IAChC,GAAIA,aAAiBK,EAC3B,MAAO,eAAeL,EAAM,SAAS,CAAC,IAChC,GAAIA,aAAiBM,EAC3B,MAAO,YAAYN,EAAM,MAAM,EAAE,GAAG,CAAC,IAC/B,GAAIA,aAAiBO,EAC3B,MAAO,aAAaP,EAAM,GAAG,CAAC,IACxB,GAAIA,aAAiBQ,EAC3B,MAAO,iBAAiBR,EAAM,MAAM,EAAE,GAAG,CAAC,IACpC,GAAIA,aAAiBS,EAC3B,MAAO,YAAYT,EAAM,MAAM,EAAE,GAAG,CAAC,IAC/B,GAAIA,aAAiBU,EAC3B,MAAO,eAAeV,EAAM,MAAM,EAAE,GAAG,CAAC,IAClC,GAAIA,aAAiBW,EAC3B,MAAO,oBAAoBX,EAAM,KAAK,CAAC,KACjC,GAAIA,aAAiBY,EAW3B,MAAO,iBAVMZ,EACX,WAAW,EACX,IAAKa,GACD,OAAOA,GAAc,SACjBA,EAEA,MAAMZ,EAAeY,EAAWX,CAAO,CAAC,GAEhD,EACA,KAAK,EAAE,CACqB,KACxB,GAAIF,aAAiBc,EAC3B,MAAO,iBAAiBd,EAAM,MAAM,EAAE,GAAG,CAAC,KACpC,GAAIA,aAAiBe,EAC3B,MAAO,eAAef,EAAM,MAAM,GAAG,CAAC,KAChC,GAAIA,aAAiBgB,EAC3B,MAAO,aAAahB,EAAM,MAAM,EAAE,GAAG,CAAC,KAChC,CAEN,IAAIiB,EAAkB,GAErBjB,EAAM,cAAgB,QACtBA,EAAM,YAAY,OAAS,WAE3BiB,EAAkB,GAAGjB,EAAM,YAAY,IAAI,KAE5C,IAAIkB,EAAU,OAAO,QAAQlB,CAAK,EAAE,IACnC,CAAC,CAACmB,EAAKnB,CAAK,IAAM,GAAGmB,CAAG,KAAKlB,EAAeD,EAAOE,CAAO,CAAC,EAC5D,EACA,MAAO,GAAGe,CAAe,KAAKC,EAAQ,KAAK,IAAI,CAAC,IACjD,CACD,ECnHO,IAAIE,GAAUC,GAA4B,CAChD,GAAI,OAAOA,GAAQ,SAClB,OAAOA,EACD,CACN,GAAI,CAAE,KAAAC,EAAM,GAAAC,CAAG,EAAIF,EACnB,MAAO,GAAGC,CAAI,IAAIC,CAAE,EACrB,CACD,EAQiBC,QAKLA,EAAA,GAAMC,GAEfA,IAAU,eACVA,IAAU,eACVA,IAAU,eACVA,IAAU,cAIDD,EAAA,KAAQJ,GAAyB,CAC3C,OAAQA,EAAQ,CACf,IAAK,cACL,IAAK,cACJ,MAAO,QAER,IAAK,cACL,IAAK,cACJ,MAAO,QAER,QACC,MAAM,IAAI,MAAM,iBAAiB,CAEnC,CACD,EAEWI,EAAA,GAAMJ,GAAuB,CACvC,OAAQA,EAAQ,CACf,IAAK,cACL,IAAK,cACJ,MAAO,QAER,IAAK,cACL,IAAK,cACJ,MAAO,QAER,QACC,MAAM,IAAI,MAAM,iBAAiB,CAEnC,CACD,IA5CgBI,KAAA,ICFjB,OAAO,iBAAiB,MAAO,CAC9B,kBAAmB,CAAE,MAAOE,EAAkB,CAC/C,CAAC,EAGD,IAAIC,GAAU,CACb,IAAAC,EACD,EACA,OAAO,iBAAiB,WAAY,CACnC,QAAS,CAAE,MAAOD,EAAQ,CAC3B,CAAC,EAGD,IAAIE,GAAK,CACR,SAAAC,EACA,KAAAC,EACA,UAAAC,EACA,KAAAC,EACA,YAAAC,EACA,QAAAC,EACA,QAAAC,EACA,QAAAC,EACA,OAAAC,GACA,OAAAC,EACA,KAAAC,EACA,SAAAC,EACA,MAAAC,EACA,OAAAC,EACA,KAAAC,EACA,UAAAC,GACA,SAAAC,GACA,SAAAC,EACA,WAAAC,GACA,IAAAC,EACA,KAAAC,EACA,QAAAC,GACA,IAAAvB,GACA,OAAAwB,GACA,YAAAC,EACA,QAAAC,EACA,QAAAC,EACA,SAAAC,GACA,IAAAC,GACA,QAAAC,EACA,QAAAC,EACA,OAAAC,GACA,OAAAC,GACA,QAAAC,EACA,KAAAC,GACA,SAAAC,EACA,cAAAC,GACA,YAAAC,CACD,EACA,OAAO,iBAAiB,WAAY,CACnC,GAAI,CAAE,MAAOrC,EAAG,EAChB,EAAG,CAAE,MAAOsC,CAAE,CACf,CAAC",
  "names": ["assert", "condition", "message", "unimplemented", "unreachable", "encoding_exports", "__export", "base64", "hex", "json", "toml", "utf8", "yaml", "artifact", "cause", "block", "blob", "arg", "directory", "arg", "cause", "encoding", "value", "file", "log", "operation", "block", "resource", "target", "task", "symlink", "base64", "value", "encoding", "hex", "json", "toml", "utf8", "yaml", "flatten", "value", "file", "args", "File", "_File", "#block", "#contents", "#executable", "#references", "contentsArgs", "executable", "references", "flatten", "map", "unresolvedArg", "arg", "resolve", "Blob", "unreachable", "value", "contents", "blob", "reference", "Artifact", "assert", "block", "Block", "relpath", "args", "Relpath", "subpath", "Subpath", "_Relpath", "#parents", "#subpath", "reduce", "path", "arg", "component", "i", "unreachable", "value", "other", "string", "Arg", "assert", "_Subpath", "#components", "components", "placeholder", "name", "Placeholder", "_Placeholder", "#name", "value", "env", "assert", "t", "strings", "placeholders", "components", "i", "string", "placeholder", "template", "args", "Template", "_Template", "#components", "flatten", "map", "arg", "resolve", "Relpath", "Subpath", "unreachable", "component", "lastComponent", "value", "assert", "separator", "separatorTemplate", "argTemplates", "templates", "argTemplate", "Component", "Artifact", "Placeholder", "symlink", "args", "Symlink", "_Symlink", "#block", "#target", "artifact", "path", "flatten", "map", "unresolvedArg", "arg", "resolve", "relpath", "Relpath", "Subpath", "Artifact", "Template", "assert", "firstComponent", "secondComponent", "unreachable", "value", "target", "t", "block", "Block", "from", "fromArtifact", "fromPath", "Directory", "task", "arg", "Task", "run", "output", "placeholder", "_Task", "#block", "#system", "#executable", "#env", "#args", "#checksum", "#unsafe", "#network", "resolvedArg", "resolve", "system", "executable", "template", "env", "key", "value", "env_", "args_", "checksum", "unsafe", "network", "block", "args", "Block", "Template", "outputFromSyscall", "operation", "Operation", "Value", "Value", "value", "Relpath", "Subpath", "Blob", "Block", "Directory", "File", "Symlink", "Placeholder", "Template", "Resource", "Target", "Task", "assert", "Artifact", "Operation", "key", "unreachable", "targets", "target", "arg", "assert", "Target", "key", "json", "entrypoint", "f", "syscallEnv", "syscallArgs", "env", "value", "Value", "args", "output", "_Target", "env_", "args_", "subpath", "_", "target_", "resolve", "syscallOutput", "operation", "Operation", "block", "package_", "modulePath", "name", "Block", "Operation", "value", "Resource", "Target", "Task", "operation", "unreachable", "resource", "arg", "Resource", "download", "_Resource", "#block", "#url", "#unpack", "#checksum", "#unsafe", "value", "assert", "Block", "outputFromSyscall", "operation", "Operation", "Value", "resolve", "value", "Relpath", "Subpath", "Blob", "Directory", "File", "Symlink", "Placeholder", "Template", "Resource", "Target", "Task", "key", "block", "args", "Block", "_Block", "#id", "children", "dataEntries", "flatten", "map", "unresolvedArg", "arg", "resolve", "utf8", "child", "data", "unreachable", "value", "length", "dataEntry", "position", "assert", "id", "Arg", "blob", "args", "Blob", "_Blob", "#block", "#kind", "block", "blocks", "flatten", "map", "unresolvedArg", "arg", "resolve", "Block", "unreachable", "value", "assert", "kind", "Arg", "directory", "args", "Directory", "_Directory", "#block", "#entries", "entries", "resolve", "reduce", "promiseEntries", "arg", "name", "entry", "existingEntry", "argEntry", "key", "value", "firstComponent", "trailingComponents", "subpath", "trailingPath", "newEntry", "Blob", "file", "File", "Symlink", "unreachable", "Artifact", "assert", "block", "Block", "artifact", "currentSubpath", "component", "entryBlock", "resolved", "bundledArtifact", "entryName", "entryArtifact", "Artifact", "value", "Directory", "File", "Symlink", "assert", "block", "artifact", "unreachable", "prepareStackTrace", "_error", "structuredStackTrace", "callSite", "include", "arg", "assert", "artifact", "Artifact", "Block", "Directory", "path", "subpath", "log", "args", "string", "arg", "stringify", "value", "stringifyInner", "visited", "stringifyObject", "Relpath", "Subpath", "Blob", "Block", "Directory", "File", "Symlink", "Placeholder", "Template", "component", "Resource", "Target", "Task", "constructorName", "entries", "key", "system", "arg", "arch", "os", "System", "value", "prepareStackTrace", "console", "log", "tg", "Artifact", "Blob", "Directory", "File", "Placeholder", "Relpath", "Subpath", "Symlink", "System", "Target", "Task", "Template", "Value", "assert", "blob", "directory", "download", "encoding_exports", "entrypoint", "env", "file", "include", "output", "placeholder", "relpath", "resolve", "resource", "run", "subpath", "symlink", "system", "target", "targets", "task", "template", "unimplemented", "unreachable", "t"]
}
