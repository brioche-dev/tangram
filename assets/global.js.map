{
  "version": 3,
  "sources": ["../src/global/assert.ts", "../src/global/syscall.ts", "../src/global/file.ts", "../src/global/path.ts", "../src/global/placeholder.ts", "../src/global/template.ts", "../src/global/symlink.ts", "../src/global/resolve.ts", "../src/global/blob.ts", "../src/global/value.ts", "../src/global/directory.ts", "../src/global/artifact.ts", "../src/global/env.ts", "../src/global/function.ts", "../src/global/download.ts", "../src/global/process.ts", "../src/global/operation.ts", "../src/global/call.ts", "../src/global/error.ts", "../src/global/include.ts", "../src/global/log.ts", "../src/global/system.ts", "../src/global/main.ts"],
  "sourcesContent": ["export let assert: (\n\tcondition: unknown,\n\tmessage?: string,\n) => asserts condition = (condition, message) => {\n\tif (!condition) {\n\t\tthrow new Error(message ?? \"Failed assertion.\");\n\t}\n};\n\nexport let unreachable = (message?: string): never => {\n\tthrow new Error(message ?? \"Reached unreachable code.\");\n};\n", "export type ArtifactHash = string;\n\nexport type Artifact =\n\t| { kind: \"directory\"; value: Directory }\n\t| { kind: \"file\"; value: File }\n\t| { kind: \"symlink\"; value: Symlink };\n\nexport type BlobHash = string;\n\nexport type Blob = {\n\thash: BlobHash;\n};\n\nexport type Directory = {\n\thash: ArtifactHash;\n\tentries: Record<string, ArtifactHash>;\n};\n\nexport type File = {\n\thash: ArtifactHash;\n\tblob: Blob;\n\texecutable: boolean;\n\treferences: Array<ArtifactHash>;\n};\n\nexport type Symlink = {\n\thash: ArtifactHash;\n\ttarget: Template;\n};\n\nexport type Value =\n\t| { kind: \"null\"; value: nullish }\n\t| { kind: \"bool\"; value: boolean }\n\t| { kind: \"number\"; value: number }\n\t| { kind: \"string\"; value: string }\n\t| { kind: \"bytes\"; value: Uint8Array }\n\t| { kind: \"path\"; value: Path }\n\t| { kind: \"blob\"; value: Blob }\n\t| { kind: \"artifact\"; value: Artifact }\n\t| { kind: \"placeholder\"; value: Placeholder }\n\t| { kind: \"template\"; value: Template }\n\t| { kind: \"array\"; value: Array<Value> }\n\t| { kind: \"object\"; value: Record<string, Value> };\n\nexport type Path = string;\n\nexport type Placeholder = {\n\tname: string;\n};\n\nexport type Template = {\n\tcomponents: Array<TemplateComponent>;\n};\n\nexport type TemplateComponent =\n\t| { kind: \"string\"; value: string }\n\t| { kind: \"artifact\"; value: Artifact }\n\t| { kind: \"placeholder\"; value: Placeholder };\n\nexport type OperationHash = string;\n\nexport type Operation =\n\t| { kind: \"call\"; value: Call }\n\t| { kind: \"download\"; value: Download }\n\t| { kind: \"process\"; value: Process };\n\nexport type Download = {\n\thash: OperationHash;\n\turl: string;\n\tunpack: boolean;\n\tchecksum: Checksum | nullish;\n\tunsafe: boolean;\n};\n\nexport type UnpackFormat =\n\t| \".bz2\"\n\t| \".gz\"\n\t| \".lz\"\n\t| \".xz\"\n\t| \".zstd\"\n\t| \".tar\"\n\t| \".tar.bz2\"\n\t| \".tar.gz\"\n\t| \".tar.lz\"\n\t| \".tar.xz\"\n\t| \".tar.zstd\"\n\t| \".zip\";\n\nexport type Process = {\n\thash: OperationHash;\n\tsystem: System;\n\texecutable: Template;\n\tenv: Record<string, Template>;\n\targs: Array<Template>;\n\tchecksum: Checksum | nullish;\n\tunsafe: boolean;\n\tnetwork: boolean;\n\thostPaths: Array<string>;\n};\n\nexport type System =\n\t| \"amd64_linux\"\n\t| \"arm64_linux\"\n\t| \"amd64_macos\"\n\t| \"arm64_macos\";\n\nexport type Call = {\n\thash: OperationHash;\n\tfunction: Function;\n\tenv: Record<string, Value>;\n\targs: Array<Value>;\n};\n\nexport type Function = {\n\tpackageInstanceHash: PackageInstanceHash;\n\tname: string;\n};\n\nexport type PackageInstanceHash = string;\n\nexport type PackageInstance = {\n\thash: PackageInstanceHash;\n\tpackageHash: ArtifactHash;\n\tdependencies: Record<string, PackageInstanceHash>;\n};\n\nexport type Checksum = `${ChecksumAlgorithm}${\":\" | \"-\"}${string}`;\n\nexport type ChecksumAlgorithm = \"blake3\" | \"sha256\";\n\nexport type nullish = undefined | null;\n\nexport type Caller = {\n\tmodule: Module;\n\tposition: Position;\n\tline: string;\n};\n\nexport type Module =\n\t| { kind: \"library\"; value: LibraryModule }\n\t| { kind: \"document\"; value: DocumentModule }\n\t| { kind: \"normal\"; value: NormalModule };\n\nexport type LibraryModule = {\n\tmodulePath: string;\n};\n\nexport type DocumentModule = {\n\tpackagePath: string;\n\tmodulePath: string;\n};\n\nexport type NormalModule = {\n\tpackageInstanceHash: string;\n\tmodulePath: string;\n};\n\nexport type Position = {\n\tline: number;\n\tcharacter: number;\n};\n\ndeclare global {\n\tfunction syscall(\n\t\tsyscall: \"artifact_bundle\",\n\t\tartifact: Artifact,\n\t): Promise<Artifact>;\n\n\tfunction syscall(\n\t\tsyscall: \"artifact_get\",\n\t\thash: ArtifactHash,\n\t): Promise<Artifact>;\n}\n\nexport let artifact = {\n\tbundle: async (artifact: Artifact): Promise<Artifact> => {\n\t\ttry {\n\t\t\treturn await syscall(\"artifact_bundle\", artifact);\n\t\t} catch (cause) {\n\t\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t\t}\n\t},\n\n\tget: async (hash: ArtifactHash): Promise<Artifact> => {\n\t\ttry {\n\t\t\treturn await syscall(\"artifact_get\", hash);\n\t\t} catch (cause) {\n\t\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t\t}\n\t},\n};\n\ndeclare global {\n\t/** Decode a base64 string to bytes. */\n\tfunction syscall(syscall: \"base64_decode\", value: string): Uint8Array;\n\n\t/** Encode bytes to a base64 string. */\n\tfunction syscall(syscall: \"base64_encode\", value: Uint8Array): string;\n}\n\nexport let base64 = {\n\tdecode: (value: string): Uint8Array => {\n\t\ttry {\n\t\t\treturn syscall(\"base64_decode\", value);\n\t\t} catch (cause) {\n\t\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t\t}\n\t},\n\n\tencode: (value: Uint8Array): string => {\n\t\ttry {\n\t\t\treturn syscall(\"base64_encode\", value);\n\t\t} catch (cause) {\n\t\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t\t}\n\t},\n};\n\ndeclare global {\n\tfunction syscall(syscall: \"blob_bytes\", blob: Blob): Promise<Uint8Array>;\n\n\tfunction syscall(\n\t\tsyscall: \"blob_new\",\n\t\tbytes: Uint8Array | string,\n\t): Promise<Blob>;\n\n\tfunction syscall(syscall: \"blob_text\", blob: Blob): Promise<string>;\n}\n\nexport let blob = {\n\tbytes: async (blob: Blob): Promise<Uint8Array> => {\n\t\ttry {\n\t\t\treturn await syscall(\"blob_bytes\", blob);\n\t\t} catch (cause) {\n\t\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t\t}\n\t},\n\n\tnew: async (bytes: Uint8Array | string): Promise<Blob> => {\n\t\ttry {\n\t\t\treturn await syscall(\"blob_new\", bytes);\n\t\t} catch (cause) {\n\t\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t\t}\n\t},\n\n\ttext: async (blob: Blob): Promise<string> => {\n\t\ttry {\n\t\t\treturn await syscall(\"blob_text\", blob);\n\t\t} catch (cause) {\n\t\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t\t}\n\t},\n};\n\ndeclare global {\n\tfunction syscall(\n\t\tsyscall: \"call_new\",\n\t\tfunction_: Function,\n\t\tenv: Record<string, Value>,\n\t\targs: Array<Value>,\n\t): Promise<Call>;\n}\n\nexport let call = {\n\tnew: async (\n\t\tfunction_: Function,\n\t\tenv: Record<string, Value>,\n\t\targs: Array<Value>,\n\t): Promise<Call> => {\n\t\ttry {\n\t\t\treturn await syscall(\"call_new\", function_, env, args);\n\t\t} catch (cause) {\n\t\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t\t}\n\t},\n};\n\ndeclare global {\n\tfunction syscall(syscall: \"caller\"): Caller;\n}\n\nexport let caller = (): Caller => {\n\ttry {\n\t\treturn syscall(\"caller\");\n\t} catch (cause) {\n\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t}\n};\n\ndeclare global {\n\tfunction syscall(\n\t\tsyscall: \"download_new\",\n\t\turl: string,\n\t\tunpack: boolean,\n\t\tchecksum: Checksum | nullish,\n\t\tunsafe: boolean,\n\t): Promise<Download>;\n}\n\nexport let download = {\n\tnew: async (\n\t\turl: string,\n\t\tunpack: boolean,\n\t\tchecksum: Checksum | nullish,\n\t\tunsafe: boolean,\n\t): Promise<Download> => {\n\t\ttry {\n\t\t\treturn await syscall(\"download_new\", url, unpack, checksum, unsafe);\n\t\t} catch (cause) {\n\t\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t\t}\n\t},\n};\n\ndeclare global {\n\tfunction syscall(\n\t\tsyscall: \"directory_new\",\n\t\tentries: Map<string, Artifact>,\n\t): Promise<Directory>;\n}\n\nexport let directory = {\n\tnew: async (entries: Map<string, Artifact>): Promise<Directory> => {\n\t\ttry {\n\t\t\treturn await syscall(\"directory_new\", entries);\n\t\t} catch (cause) {\n\t\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t\t}\n\t},\n};\n\ndeclare global {\n\tfunction syscall(\n\t\tsyscall: \"file_new\",\n\t\tblob: Blob,\n\t\texecutable: boolean,\n\t\treferences: Array<Artifact>,\n\t): Promise<File>;\n}\n\nexport let file = {\n\tnew: async (\n\t\tblob: Blob,\n\t\texecutable: boolean,\n\t\treferences: Array<Artifact>,\n\t): Promise<File> => {\n\t\ttry {\n\t\t\treturn await syscall(\"file_new\", blob, executable, references);\n\t\t} catch (cause) {\n\t\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t\t}\n\t},\n};\n\ndeclare global {\n\t/** Decode a hex string to bytes. */\n\tfunction syscall(syscall: \"hex_decode\", value: string): Uint8Array;\n\n\t/** Encode bytes to a hex string. */\n\tfunction syscall(syscall: \"hex_encode\", value: Uint8Array): string;\n}\n\nexport let hex = {\n\tdecode: (value: string): Uint8Array => {\n\t\ttry {\n\t\t\treturn syscall(\"hex_decode\", value);\n\t\t} catch (cause) {\n\t\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t\t}\n\t},\n\n\tencode: (value: Uint8Array): string => {\n\t\ttry {\n\t\t\treturn syscall(\"hex_encode\", value);\n\t\t} catch (cause) {\n\t\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t\t}\n\t},\n};\n\ndeclare global {\n\tfunction syscall(\n\t\tsyscall: \"include\",\n\t\tcaller: Caller,\n\t\tpath: string,\n\t): Promise<Artifact>;\n}\n\nexport let include = async (\n\tcaller: Caller,\n\tpath: string,\n): Promise<Artifact> => {\n\ttry {\n\t\treturn await syscall(\"include\", caller, path);\n\t} catch (cause) {\n\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t}\n};\n\ndeclare global {\n\t/** Decode a json string to a value. */\n\tfunction syscall(syscall: \"json_decode\", value: string): unknown;\n\n\t/** Encode a value to a json string. */\n\tfunction syscall(syscall: \"json_encode\", value: any): string;\n}\n\nexport let json = {\n\tdecode: (value: string): unknown => {\n\t\ttry {\n\t\t\treturn syscall(\"json_decode\", value);\n\t\t} catch (cause) {\n\t\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t\t}\n\t},\n\n\tencode: (value: any): string => {\n\t\ttry {\n\t\t\treturn syscall(\"json_encode\", value);\n\t\t} catch (cause) {\n\t\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t\t}\n\t},\n};\n\ndeclare global {\n\tfunction syscall(syscall: \"log\", value: string): void;\n}\n\nexport let log = (value: string) => {\n\ttry {\n\t\treturn syscall(\"log\", value);\n\t} catch (cause) {\n\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t}\n};\n\ndeclare global {\n\tfunction syscall(\n\t\tsyscall: \"operation_get\",\n\t\thash: OperationHash,\n\t): Promise<Operation>;\n\n\tfunction syscall(\n\t\tsyscall: \"operation_run\",\n\t\toperation: Operation,\n\t): Promise<Value>;\n}\n\nexport let operation = {\n\tget: async (hash: OperationHash): Promise<Operation> => {\n\t\ttry {\n\t\t\treturn await syscall(\"operation_get\", hash);\n\t\t} catch (cause) {\n\t\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t\t}\n\t},\n\n\trun: async (operation: Operation): Promise<Value> => {\n\t\ttry {\n\t\t\treturn await syscall(\"operation_run\", operation);\n\t\t} catch (cause) {\n\t\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t\t}\n\t},\n};\n\ndeclare global {\n\tfunction syscall(\n\t\tsyscall: \"process_new\",\n\t\tsystem: System,\n\t\texecutable: Template,\n\t\tenv?: Record<string, Template> | nullish,\n\t\targs?: Array<Template> | nullish,\n\t\tchecksum?: Checksum | nullish,\n\t\tunsafe?: boolean | nullish,\n\t\tnetwork?: boolean | nullish,\n\t\thostPaths?: Array<string> | nullish,\n\t): Promise<Process>;\n}\n\nexport let process = {\n\tnew: async (\n\t\tsystem: System,\n\t\texecutable: Template,\n\t\tenv: Record<string, Template>,\n\t\targs: Array<Template>,\n\t\tchecksum: Checksum | nullish,\n\t\tunsafe: boolean,\n\t\tnetwork: boolean,\n\t\thostPaths: Array<string>,\n\t): Promise<Process> => {\n\t\ttry {\n\t\t\treturn await syscall(\n\t\t\t\t\"process_new\",\n\t\t\t\tsystem,\n\t\t\t\texecutable,\n\t\t\t\tenv,\n\t\t\t\targs,\n\t\t\t\tchecksum,\n\t\t\t\tunsafe,\n\t\t\t\tnetwork,\n\t\t\t\thostPaths,\n\t\t\t);\n\t\t} catch (cause) {\n\t\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t\t}\n\t},\n};\n\ndeclare global {\n\tfunction syscall(syscall: \"symlink_new\", target: Template): Promise<Symlink>;\n}\n\nexport let symlink = {\n\tnew: async (target: Template): Promise<Symlink> => {\n\t\ttry {\n\t\t\treturn await syscall(\"symlink_new\", target);\n\t\t} catch (cause) {\n\t\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t\t}\n\t},\n};\n\ndeclare global {\n\t/** Decode a toml string to a value. */\n\tfunction syscall(syscall: \"toml_decode\", value: string): unknown;\n\n\t/** Encode a value to a toml string. */\n\tfunction syscall(syscall: \"toml_encode\", value: any): string;\n}\n\nexport let toml = {\n\tdecode: (value: string): unknown => {\n\t\ttry {\n\t\t\treturn syscall(\"toml_decode\", value);\n\t\t} catch (cause) {\n\t\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t\t}\n\t},\n\n\tencode: (value: any): string => {\n\t\ttry {\n\t\t\treturn syscall(\"toml_encode\", value);\n\t\t} catch (cause) {\n\t\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t\t}\n\t},\n};\n\ndeclare global {\n\t/** Decode UTF-8 bytes to a string. */\n\tfunction syscall(syscall: \"utf8_decode\", value: Uint8Array): string;\n\n\t/** Encode a string to UTF-8 bytes. */\n\tfunction syscall(syscall: \"utf8_encode\", value: string): Uint8Array;\n}\n\nexport let utf8 = {\n\tdecode: (value: Uint8Array): string => {\n\t\ttry {\n\t\t\treturn syscall(\"utf8_decode\", value);\n\t\t} catch (cause) {\n\t\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t\t}\n\t},\n\n\tencode: (value: string): Uint8Array => {\n\t\ttry {\n\t\t\treturn syscall(\"utf8_encode\", value);\n\t\t} catch (cause) {\n\t\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t\t}\n\t},\n};\n\ndeclare global {\n\t/** Decode a yaml string to a value. */\n\tfunction syscall(syscall: \"yaml_decode\", value: string): unknown;\n\n\t/** Encode a value to a yaml string. */\n\tfunction syscall(syscall: \"yaml_encode\", value: any): string;\n}\n\nexport let yaml = {\n\tdecode: (value: string): unknown => {\n\t\ttry {\n\t\t\treturn syscall(\"yaml_decode\", value);\n\t\t} catch (cause) {\n\t\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t\t}\n\t},\n\n\tencode: (value: any): string => {\n\t\ttry {\n\t\t\treturn syscall(\"yaml_encode\", value);\n\t\t} catch (cause) {\n\t\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t\t}\n\t},\n};\n", "import { Artifact } from \"./artifact.ts\";\nimport { Blob, blob } from \"./blob.ts\";\nimport { Unresolved, resolve } from \"./resolve.ts\";\nimport * as syscall from \"./syscall.ts\";\n\nexport namespace File {\n\texport type Arg = Blob.Arg | File | ArgObject;\n\n\texport type ArgObject = {\n\t\tblob: Blob.Arg;\n\t\texecutable?: boolean;\n\t\treferences?: Array<Artifact>;\n\t};\n}\n\nexport let file = async (arg: Unresolved<File.Arg>): Promise<File> => {\n\t// Resolve the arg.\n\tlet resolvedArg = await resolve(arg);\n\n\t// Get the blob, executable, and references.\n\tlet blob_: Blob;\n\tlet executable: boolean;\n\tlet references: Array<Artifact>;\n\tif (Blob.isBlobArg(resolvedArg)) {\n\t\t// If the arg is a blob arg, then create a file which is not executable and has no references.\n\t\tblob_ = await blob(resolvedArg);\n\t\texecutable = false;\n\t\treferences = [];\n\t} else if (File.isFile(resolvedArg)) {\n\t\t// If the arg is a file, then return it.\n\t\treturn resolvedArg;\n\t} else {\n\t\t// Otherwise, the arg is a file object.\n\t\tblob_ = await blob(resolvedArg.blob);\n\t\texecutable = resolvedArg.executable ?? false;\n\t\treferences = resolvedArg.references ?? [];\n\t}\n\n\t// Create the file.\n\treturn File.fromSyscall(\n\t\tawait syscall.file.new(\n\t\t\tblob_.toSyscall(),\n\t\t\texecutable,\n\t\t\treferences.map((reference) => Artifact.toSyscall(reference)),\n\t\t),\n\t);\n};\n\ntype ConstructorArg = {\n\thash: Artifact.Hash;\n\tblob: Blob;\n\texecutable: boolean;\n\treferences: Array<Artifact.Hash>;\n};\n\nexport class File {\n\t#hash: Artifact.Hash;\n\t#blob: Blob;\n\t#executable: boolean;\n\t#references: Array<Artifact.Hash>;\n\n\tconstructor(arg: ConstructorArg) {\n\t\tthis.#hash = arg.hash;\n\t\tthis.#blob = arg.blob;\n\t\tthis.#executable = arg.executable;\n\t\tthis.#references = arg.references;\n\t}\n\n\tstatic isFile(value: unknown): value is File {\n\t\treturn value instanceof File;\n\t}\n\n\ttoSyscall(): syscall.File {\n\t\treturn {\n\t\t\thash: this.#hash,\n\t\t\tblob: this.#blob.toSyscall(),\n\t\t\texecutable: this.#executable,\n\t\t\treferences: this.#references,\n\t\t};\n\t}\n\n\tstatic fromSyscall(value: syscall.File): File {\n\t\treturn new File({\n\t\t\thash: value.hash,\n\t\t\tblob: Blob.fromSyscall(value.blob),\n\t\t\texecutable: value.executable,\n\t\t\treferences: value.references,\n\t\t});\n\t}\n\n\thash(): Artifact.Hash {\n\t\treturn this.#hash;\n\t}\n\n\tblob(): Blob {\n\t\treturn this.#blob;\n\t}\n\n\texecutable(): boolean {\n\t\treturn this.#executable;\n\t}\n\n\tasync references(): Promise<Array<Artifact>> {\n\t\treturn await Promise.all(this.#references.map(Artifact.get));\n\t}\n\n\tasync bytes(): Promise<Uint8Array> {\n\t\treturn await this.blob().bytes();\n\t}\n\n\tasync text(): Promise<string> {\n\t\treturn await this.blob().text();\n\t}\n}\n", "import * as syscall from \"./syscall.ts\";\nimport { nullish } from \"./value.ts\";\n\nexport namespace Path {\n\texport type Arg = string | Path.Component | Path | Array<Arg>;\n}\n\nexport let path = (...args: Array<Path.Arg>): Path => {\n\t// Collect the components.\n\tlet components: Array<Path.Component> = [];\n\tlet collectComponents = (arg: Path.Arg | nullish) => {\n\t\tif (typeof arg === \"string\") {\n\t\t\t// Push each component.\n\t\t\tfor (let component of arg.split(\"/\")) {\n\t\t\t\tif (component === \"\" || component === \".\") {\n\t\t\t\t\t// Ignore empty and current dir components.\n\t\t\t\t} else if (component === \"..\") {\n\t\t\t\t\tcomponents.push({ kind: \"parent\" });\n\t\t\t\t} else {\n\t\t\t\t\tcomponents.push({\n\t\t\t\t\t\tkind: \"normal\",\n\t\t\t\t\t\tvalue: component,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (Path.Component.isPathComponent(arg)) {\n\t\t\tcomponents.push(arg);\n\t\t} else if (arg instanceof Path) {\n\t\t\tcomponents.push(...arg.components());\n\t\t} else if (arg instanceof Array) {\n\t\t\tfor (let component of arg) {\n\t\t\t\tcollectComponents(component);\n\t\t\t}\n\t\t}\n\t};\n\tfor (let arg of args) {\n\t\tcollectComponents(arg);\n\t}\n\n\t// Create the path.\n\tlet path_ = new Path();\n\tfor (let component of components) {\n\t\tpath_.push(component);\n\t}\n\n\treturn path_;\n};\n\nexport class Path {\n\t#components: Array<Path.Component>;\n\n\tconstructor(components: Array<Path.Component> = []) {\n\t\tthis.#components = components;\n\t}\n\n\tstatic isPathArg(value: unknown): value is Path.Arg {\n\t\treturn (\n\t\t\ttypeof value === \"string\" ||\n\t\t\tPath.Component.isPathComponent(value) ||\n\t\t\tvalue instanceof Path ||\n\t\t\t(value instanceof Array && value.every(Path.isPathArg))\n\t\t);\n\t}\n\n\tstatic isPath(value: unknown): value is Path {\n\t\treturn value instanceof Path;\n\t}\n\n\ttoSyscall(): syscall.Path {\n\t\treturn this.toString();\n\t}\n\n\tstatic fromSyscall(value: syscall.Path): Path {\n\t\treturn path(value);\n\t}\n\n\tcomponents(): Array<Path.Component> {\n\t\treturn [...this.#components];\n\t}\n\n\tpush(component: Path.Component) {\n\t\tif (component.kind === \"parent\") {\n\t\t\tlet lastComponent = this.#components.at(-1);\n\t\t\tif (lastComponent === undefined || lastComponent.kind === \"parent\") {\n\t\t\t\tthis.#components.push(component);\n\t\t\t} else {\n\t\t\t\tthis.#components.pop();\n\t\t\t}\n\t\t} else {\n\t\t\tthis.#components.push(component);\n\t\t}\n\t}\n\n\tjoin(other: Path.Arg): Path {\n\t\tlet result = path(this);\n\t\tfor (let component of path(other).components()) {\n\t\t\tresult.push(component);\n\t\t}\n\t\treturn result;\n\t}\n\n\tdiff(src: Path.Arg): Path {\n\t\tlet srcPath = path(src);\n\t\tlet dstPath = path(this);\n\n\t\t// Remove the paths' common ancestor.\n\t\twhile (true) {\n\t\t\tlet srcComponent = srcPath.#components.at(0);\n\t\t\tlet dstComponent = dstPath.#components.at(0);\n\t\t\tif (\n\t\t\t\tsrcComponent &&\n\t\t\t\tdstComponent &&\n\t\t\t\tPath.Component.equal(srcComponent, dstComponent)\n\t\t\t) {\n\t\t\t\tsrcPath.#components.shift();\n\t\t\t\tdstPath.#components.shift();\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// If there is no valid path from the base to the target, then throw an error.\n\t\tif (srcPath.#components.at(0)?.kind === \"parent\") {\n\t\t\tthrow new Error(\n\t\t\t\t`There is no valid path from \"${srcPath}\" to \"${dstPath}\".`,\n\t\t\t);\n\t\t}\n\n\t\t// Construct the path.\n\t\tlet output = path(\n\t\t\tArray.from({ length: srcPath.#components.length }, () => ({\n\t\t\t\tkind: \"parent\",\n\t\t\t})),\n\t\t\tdstPath,\n\t\t);\n\t\treturn output;\n\t}\n\n\ttoString(): string {\n\t\treturn this.#components\n\t\t\t.map((component) => {\n\t\t\t\tswitch (component.kind) {\n\t\t\t\t\tcase \"parent\": {\n\t\t\t\t\t\treturn \"..\";\n\t\t\t\t\t}\n\t\t\t\t\tcase \"normal\": {\n\t\t\t\t\t\treturn component.value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})\n\t\t\t.join(\"/\");\n\t}\n}\n\nexport namespace Path {\n\texport type Component =\n\t\t| { kind: \"parent\" }\n\t\t| { kind: \"normal\"; value: string };\n\n\texport namespace Component {\n\t\texport let isPathComponent = (value: unknown): value is Path.Component => {\n\t\t\treturn (\n\t\t\t\ttypeof value === \"object\" &&\n\t\t\t\tvalue !== null &&\n\t\t\t\t\"kind\" in value &&\n\t\t\t\t(value.kind === \"parent\" || value.kind === \"normal\")\n\t\t\t);\n\t\t};\n\n\t\texport let equal = (a: Path.Component, b: Path.Component): boolean => {\n\t\t\treturn (\n\t\t\t\ta.kind === b.kind &&\n\t\t\t\t(a.kind === \"normal\" && b.kind === \"normal\"\n\t\t\t\t\t? a.value === b.value\n\t\t\t\t\t: true)\n\t\t\t);\n\t\t};\n\t}\n}\n", "import * as syscall from \"./syscall.ts\";\n\nexport let placeholder = (name: string): Placeholder => {\n\treturn new Placeholder(name);\n};\n\nexport class Placeholder {\n\t#name: string;\n\n\tconstructor(name: string) {\n\t\tthis.#name = name;\n\t}\n\n\tstatic isPlaceholder(value: unknown): value is Placeholder {\n\t\treturn value instanceof Placeholder;\n\t}\n\n\ttoSyscall(): syscall.Placeholder {\n\t\treturn {\n\t\t\tname: this.#name,\n\t\t};\n\t}\n\n\tstatic fromSyscall(placeholder: syscall.Placeholder): Placeholder {\n\t\tlet name = placeholder.name;\n\t\treturn new Placeholder(name);\n\t}\n\n\tname(): string {\n\t\treturn this.#name;\n\t}\n}\n", "import { Artifact } from \"./artifact.ts\";\nimport { assert, unreachable } from \"./assert.ts\";\nimport { Path } from \"./path.ts\";\nimport { Placeholder } from \"./placeholder.ts\";\nimport { Unresolved, resolve } from \"./resolve.ts\";\nimport * as syscall from \"./syscall.ts\";\nimport { nullish } from \"./value.ts\";\n\nexport namespace Template {\n\texport type Arg = Component | Path | Template | Array<Arg>;\n}\n\nexport let t = async (\n\tstrings: TemplateStringsArray,\n\t...placeholders: Array<Unresolved<Template.Arg | nullish>>\n): Promise<Template> => {\n\t// Collect the strings and placeholders.\n\tlet components: Array<Unresolved<Template.Arg | nullish>> = [];\n\tfor (let i = 0; i < strings.length - 1; i++) {\n\t\t// eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\t\tlet string = strings[i]!;\n\t\tcomponents.push(string);\n\t\t// eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\t\tlet placeholder = placeholders[i]!;\n\t\tcomponents.push(placeholder);\n\t}\n\t// eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\tcomponents.push(strings[strings.length - 1]!);\n\treturn await template(...components);\n};\n\nexport let template = async (\n\t...args: Array<Unresolved<Template.Arg | nullish>>\n): Promise<Template> => {\n\t// Collect the components.\n\tlet components: Array<Template.Component> = [];\n\tlet collectComponents = (arg: Template.Arg | nullish) => {\n\t\tif (Template.Component.isTemplateComponent(arg)) {\n\t\t\tcomponents.push(arg);\n\t\t} else if (arg instanceof Path) {\n\t\t\tcomponents.push(arg.toString());\n\t\t} else if (arg instanceof Template) {\n\t\t\tcomponents.push(...arg.components());\n\t\t} else if (arg instanceof Array) {\n\t\t\tfor (let component of arg) {\n\t\t\t\tcollectComponents(component);\n\t\t\t}\n\t\t}\n\t};\n\tfor (let arg of await Promise.all(args.map(resolve))) {\n\t\tcollectComponents(arg);\n\t}\n\n\t// Normalize the components.\n\tlet normalizedComponents: Array<Template.Component> = [];\n\tfor (let component of components) {\n\t\tlet lastComponent = normalizedComponents.at(-1);\n\t\tif (component === \"\") {\n\t\t\t// Ignore empty string components.\n\t\t\tcontinue;\n\t\t} else if (\n\t\t\ttypeof lastComponent === \"string\" &&\n\t\t\ttypeof component === \"string\"\n\t\t) {\n\t\t\t// Merge adjacent string components.\n\t\t\tnormalizedComponents.splice(-1, 1, lastComponent + component);\n\t\t} else {\n\t\t\tnormalizedComponents.push(component);\n\t\t}\n\t}\n\tcomponents = normalizedComponents;\n\n\treturn new Template(components);\n};\n\nexport class Template {\n\t#components: Array<Template.Component>;\n\n\tconstructor(components: Array<Template.Component>) {\n\t\tthis.#components = components;\n\t}\n\n\tstatic isTemplate(value: unknown): value is Template {\n\t\treturn value instanceof Template;\n\t}\n\n\t/** Join an array of templates with a separator. */\n\tstatic async join(\n\t\tseparator: Unresolved<Template.Arg>,\n\t\t...args: Array<Unresolved<Template.Arg | nullish>>\n\t): Promise<Template> {\n\t\tlet resolvedSeparator = await template(separator);\n\t\tlet resolvedArgs = await Promise.all(args.map((arg) => template(arg)));\n\t\tlet components = [];\n\t\tfor (let i = 0; i < resolvedArgs.length; i++) {\n\t\t\tif (i > 0) {\n\t\t\t\tcomponents.push(resolvedSeparator);\n\t\t\t}\n\t\t\tlet arg = resolvedArgs[i];\n\t\t\tassert(arg);\n\t\t\tcomponents.push(arg);\n\t\t}\n\t\treturn template(...components);\n\t}\n\n\ttoSyscall(): syscall.Template {\n\t\tlet components = this.#components.map((component) =>\n\t\t\tTemplate.Component.toSyscall(component),\n\t\t);\n\t\treturn {\n\t\t\tcomponents,\n\t\t};\n\t}\n\n\tstatic fromSyscall(value: syscall.Template): Template {\n\t\tlet components = value.components.map((component) =>\n\t\t\tTemplate.Component.fromSyscall(component),\n\t\t);\n\t\treturn new Template(components);\n\t}\n\n\tcomponents(): Array<Template.Component> {\n\t\treturn [...this.#components];\n\t}\n}\n\nexport namespace Template {\n\texport type Component = string | Artifact | Placeholder;\n\n\texport namespace Component {\n\t\texport let isTemplateComponent = (value: unknown): value is Component => {\n\t\t\treturn (\n\t\t\t\ttypeof value === \"string\" ||\n\t\t\t\tArtifact.isArtifact(value) ||\n\t\t\t\tvalue instanceof Placeholder\n\t\t\t);\n\t\t};\n\n\t\texport let toSyscall = (\n\t\t\tcomponent: Component,\n\t\t): syscall.TemplateComponent => {\n\t\t\tif (typeof component === \"string\") {\n\t\t\t\treturn {\n\t\t\t\t\tkind: \"string\",\n\t\t\t\t\tvalue: component,\n\t\t\t\t};\n\t\t\t} else if (Artifact.isArtifact(component)) {\n\t\t\t\treturn {\n\t\t\t\t\tkind: \"artifact\",\n\t\t\t\t\tvalue: Artifact.toSyscall(component),\n\t\t\t\t};\n\t\t\t} else if (component instanceof Placeholder) {\n\t\t\t\treturn {\n\t\t\t\t\tkind: \"placeholder\",\n\t\t\t\t\tvalue: component.toSyscall(),\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\treturn unreachable();\n\t\t\t}\n\t\t};\n\n\t\texport let fromSyscall = (\n\t\t\tcomponent: syscall.TemplateComponent,\n\t\t): Component => {\n\t\t\tswitch (component.kind) {\n\t\t\t\tcase \"string\": {\n\t\t\t\t\treturn component.value;\n\t\t\t\t}\n\t\t\t\tcase \"artifact\": {\n\t\t\t\t\treturn Artifact.fromSyscall(component.value);\n\t\t\t\t}\n\t\t\t\tcase \"placeholder\": {\n\t\t\t\t\treturn Placeholder.fromSyscall(component.value);\n\t\t\t\t}\n\t\t\t\tdefault: {\n\t\t\t\t\treturn unreachable();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n}\n", "import { Artifact } from \"./artifact.ts\";\nimport { assert } from \"./assert.ts\";\nimport { Directory } from \"./directory.ts\";\nimport { File } from \"./file.ts\";\nimport { Path, path } from \"./path.ts\";\nimport { Unresolved, resolve } from \"./resolve.ts\";\nimport * as syscall from \"./syscall.ts\";\nimport { Template, t } from \"./template.ts\";\nimport { nullish } from \"./value.ts\";\n\nexport namespace Symlink {\n\texport type Arg = string | Path | Artifact | Template | ArgObject;\n\n\texport type ArgObject = {\n\t\tartifact?: Artifact | nullish;\n\t\tpath?: string | Path | nullish;\n\t};\n}\n\nexport let symlink = async (arg: Unresolved<Symlink.Arg>): Promise<Symlink> => {\n\t// Resolve the arg.\n\tlet resolvedArg = await resolve(arg);\n\n\t// Get the artifact and path.\n\tlet artifact: Artifact | nullish;\n\tlet path_: string | nullish;\n\tif (typeof resolvedArg === \"string\") {\n\t\tpath_ = resolvedArg;\n\t} else if (Path.isPath(resolvedArg)) {\n\t\tpath_ = resolvedArg.toString();\n\t} else if (Artifact.isArtifact(resolvedArg)) {\n\t\tartifact = resolvedArg;\n\t} else if (resolvedArg instanceof Template) {\n\t\tassert(resolvedArg.components().length <= 2);\n\t\tlet [firstComponent, secondComponent] = resolvedArg.components();\n\t\tif (typeof firstComponent === \"string\" && secondComponent === undefined) {\n\t\t\tpath_ = firstComponent;\n\t\t} else if (\n\t\t\tArtifact.isArtifact(firstComponent) &&\n\t\t\tsecondComponent === undefined\n\t\t) {\n\t\t\tartifact = firstComponent;\n\t\t} else if (\n\t\t\tArtifact.isArtifact(firstComponent) &&\n\t\t\ttypeof secondComponent === \"string\"\n\t\t) {\n\t\t\tartifact = firstComponent;\n\t\t\tassert(secondComponent.startsWith(\"/\"));\n\t\t\tpath_ = secondComponent.slice(1);\n\t\t} else {\n\t\t\tthrow new Error(\"Invalid template.\");\n\t\t}\n\t} else if (resolvedArg instanceof Symlink) {\n\t\treturn resolvedArg;\n\t} else if (typeof resolvedArg === \"object\") {\n\t\tartifact = resolvedArg.artifact;\n\t\tlet resolvedArgPath = resolvedArg.path;\n\t\tif (typeof resolvedArgPath === \"string\") {\n\t\t\tpath_ = resolvedArgPath;\n\t\t} else if (Path.isPath(resolvedArgPath)) {\n\t\t\tpath_ = resolvedArgPath.toString();\n\t\t}\n\t}\n\n\t// Create the target.\n\tlet target;\n\tif (artifact !== undefined && path_ !== undefined) {\n\t\ttarget = await t`${artifact}/${path_}`;\n\t} else if (artifact !== undefined && path_ === undefined) {\n\t\ttarget = await t`${artifact}`;\n\t} else if (artifact === undefined && path_ !== undefined) {\n\t\ttarget = await t`${path_}`;\n\t} else {\n\t\ttarget = await t``;\n\t}\n\n\treturn Symlink.fromSyscall(await syscall.symlink.new(target.toSyscall()));\n};\n\ntype ConstructorArgs = {\n\thash: Artifact.Hash;\n\ttarget: Template;\n};\n\nexport class Symlink {\n\t#hash: Artifact.Hash;\n\t#target: Template;\n\n\tconstructor(args: ConstructorArgs) {\n\t\tthis.#hash = args.hash;\n\t\tthis.#target = args.target;\n\t}\n\n\tstatic isSymlink(value: unknown): value is Symlink {\n\t\treturn value instanceof Symlink;\n\t}\n\n\ttoSyscall(): syscall.Symlink {\n\t\tlet hash = this.#hash;\n\t\tlet target = this.#target.toSyscall();\n\t\treturn {\n\t\t\thash,\n\t\t\ttarget,\n\t\t};\n\t}\n\n\tstatic fromSyscall(symlink: syscall.Symlink): Symlink {\n\t\tlet hash = symlink.hash;\n\t\tlet target = Template.fromSyscall(symlink.target);\n\t\treturn new Symlink({\n\t\t\thash,\n\t\t\ttarget,\n\t\t});\n\t}\n\n\thash(): Artifact.Hash {\n\t\treturn this.#hash;\n\t}\n\n\ttarget(): Template {\n\t\treturn this.#target;\n\t}\n\n\tartifact(): Artifact | undefined {\n\t\tlet firstComponent = this.#target.components().at(0);\n\t\tif (Artifact.isArtifact(firstComponent)) {\n\t\t\treturn firstComponent;\n\t\t} else {\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\tpath(): Path {\n\t\tlet [firstComponent, secondComponent] = this.#target.components();\n\t\tif (typeof firstComponent === \"string\" && secondComponent === undefined) {\n\t\t\treturn path(firstComponent);\n\t\t} else if (\n\t\t\tArtifact.isArtifact(firstComponent) &&\n\t\t\tsecondComponent === undefined\n\t\t) {\n\t\t\treturn path();\n\t\t} else if (\n\t\t\tArtifact.isArtifact(firstComponent) &&\n\t\t\ttypeof secondComponent === \"string\"\n\t\t) {\n\t\t\treturn path(secondComponent);\n\t\t} else {\n\t\t\tthrow new Error(\"Invalid template.\");\n\t\t}\n\t}\n\n\tasync resolve(): Promise<Directory | File | undefined> {\n\t\tlet result: Artifact = this;\n\t\twhile (Symlink.isSymlink(result)) {\n\t\t\tlet artifact = result.artifact();\n\t\t\tlet path = result.path();\n\t\t\tif (Directory.isDirectory(artifact)) {\n\t\t\t\tresult = await artifact.get(path);\n\t\t\t} else if (File.isFile(artifact)) {\n\t\t\t\tassert(path.components().length === 0);\n\t\t\t\tresult = artifact;\n\t\t\t} else if (Symlink.isSymlink(artifact)) {\n\t\t\t\tassert(path.components().length === 0);\n\t\t\t\tresult = artifact;\n\t\t\t} else {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t\"Cannot resolve a symlink without an artifact in its target.\",\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n}\n", "import { Artifact } from \"./artifact.ts\";\nimport { Blob } from \"./blob.ts\";\nimport { Directory } from \"./directory.ts\";\nimport { File } from \"./file.ts\";\nimport { Path } from \"./path.ts\";\nimport { Placeholder } from \"./placeholder.ts\";\nimport { Symlink } from \"./symlink.ts\";\nimport { Template } from \"./template.ts\";\nimport { Value, nullish } from \"./value.ts\";\n\nexport type Unresolved<T extends Value> = MaybePromise<\n\tT extends\n\t\t| nullish\n\t\t| boolean\n\t\t| number\n\t\t| string\n\t\t| Uint8Array\n\t\t| Path\n\t\t| Blob\n\t\t| Artifact\n\t\t| Placeholder\n\t\t| Template\n\t\t? T\n\t\t: T extends Array<infer U extends Value>\n\t\t? Array<Unresolved<U>>\n\t\t: T extends { [key: string]: Value }\n\t\t? { [K in keyof T]: Unresolved<T[K]> }\n\t\t: never\n>;\n\nexport type Resolved<T extends Unresolved<Value>> = T extends\n\t| nullish\n\t| boolean\n\t| number\n\t| string\n\t| Uint8Array\n\t| Path\n\t| Blob\n\t| Artifact\n\t| Placeholder\n\t| Template\n\t? T\n\t: T extends Promise<infer U extends Unresolved<Value>>\n\t? Resolved<U>\n\t: T extends Array<infer U extends Unresolved<Value>>\n\t? Array<Resolved<U>>\n\t: T extends { [key: string]: Unresolved<Value> }\n\t? { [K in keyof T]: Resolved<T[K]> }\n\t: never;\n\nexport type MaybePromise<T> = T | Promise<T>;\n\nexport let resolve = async <T extends Unresolved<Value>>(\n\tvalue: T,\n): Promise<Resolved<T>> => {\n\tvalue = await value;\n\tif (\n\t\tvalue === undefined ||\n\t\tvalue === null ||\n\t\ttypeof value === \"boolean\" ||\n\t\ttypeof value === \"number\" ||\n\t\ttypeof value === \"string\" ||\n\t\tvalue instanceof Uint8Array ||\n\t\tvalue instanceof Path ||\n\t\tvalue instanceof Blob ||\n\t\tvalue instanceof Directory ||\n\t\tvalue instanceof File ||\n\t\tvalue instanceof Symlink ||\n\t\tvalue instanceof Placeholder ||\n\t\tvalue instanceof Template\n\t) {\n\t\treturn value as unknown as Resolved<T>;\n\t} else if (value instanceof Array) {\n\t\treturn (await Promise.all(\n\t\t\tvalue.map((value) => resolve(value)),\n\t\t)) as Resolved<T>;\n\t} else if (typeof value === \"object\") {\n\t\treturn Object.fromEntries(\n\t\t\tawait Promise.all(\n\t\t\t\tObject.entries(value).map(async ([key, value]) => [\n\t\t\t\t\tkey,\n\t\t\t\t\tawait resolve(value),\n\t\t\t\t]),\n\t\t\t),\n\t\t) as Resolved<T>;\n\t} else {\n\t\tthrow new Error(\"Invalid value to resolve.\");\n\t}\n};\n", "import { Unresolved, resolve } from \"./resolve.ts\";\nimport * as syscall from \"./syscall.ts\";\n\nexport namespace Blob {\n\texport type Arg = Uint8Array | string | Blob;\n\n\texport type Hash = string;\n}\n\nexport let blob = async (arg: Unresolved<Blob.Arg>): Promise<Blob> => {\n\tlet resolvedArg = await resolve(arg);\n\tlet bytes: Uint8Array | string;\n\tif (resolvedArg instanceof Uint8Array || typeof resolvedArg === \"string\") {\n\t\tbytes = resolvedArg;\n\t} else {\n\t\treturn resolvedArg;\n\t}\n\treturn Blob.fromSyscall(await syscall.blob.new(bytes));\n};\n\ntype ConstructorArg = {\n\thash: Blob.Hash;\n};\n\nexport class Blob {\n\t#hash: Blob.Hash;\n\n\tconstructor(arg: ConstructorArg) {\n\t\tthis.#hash = arg.hash;\n\t}\n\n\tstatic isBlobArg(value: unknown): value is Blob.Arg {\n\t\treturn (\n\t\t\tvalue instanceof Uint8Array ||\n\t\t\ttypeof value === \"string\" ||\n\t\t\tvalue instanceof Blob\n\t\t);\n\t}\n\n\tstatic isBlob(value: unknown): value is Blob {\n\t\treturn value instanceof Blob;\n\t}\n\n\ttoSyscall(): syscall.Blob {\n\t\treturn {\n\t\t\thash: this.#hash,\n\t\t};\n\t}\n\n\tstatic fromSyscall(value: syscall.Blob): Blob {\n\t\tlet hash = value.hash;\n\t\treturn new Blob({ hash });\n\t}\n\n\thash(): Blob.Hash {\n\t\treturn this.#hash;\n\t}\n\n\tasync bytes(): Promise<Uint8Array> {\n\t\treturn await syscall.blob.bytes(this.toSyscall());\n\t}\n\n\tasync text(): Promise<string> {\n\t\treturn await syscall.blob.text(this.toSyscall());\n\t}\n}\n", "import { Artifact } from \"./artifact.ts\";\nimport { unreachable } from \"./assert.ts\";\nimport { Blob } from \"./blob.ts\";\nimport { Directory } from \"./directory.ts\";\nimport { File } from \"./file.ts\";\nimport { Path, path } from \"./path.ts\";\nimport { Placeholder } from \"./placeholder.ts\";\nimport { Symlink } from \"./symlink.ts\";\nimport * as syscall from \"./syscall.ts\";\nimport { Template } from \"./template.ts\";\n\nexport type Value =\n\t| nullish\n\t| boolean\n\t| number\n\t| string\n\t| Uint8Array\n\t| Path\n\t| Blob\n\t| Artifact\n\t| Placeholder\n\t| Template\n\t| Array<Value>\n\t| { [key: string]: Value };\n\nexport type nullish = undefined | null;\n\nexport namespace nullish {\n\texport let isNullish = (value: unknown): value is nullish => {\n\t\treturn value === undefined || value === null;\n\t};\n}\n\nexport let Value = {\n\tisValue: (value: unknown): value is Value => {\n\t\treturn (\n\t\t\tvalue === undefined ||\n\t\t\tvalue === null ||\n\t\t\ttypeof value === \"boolean\" ||\n\t\t\ttypeof value === \"number\" ||\n\t\t\ttypeof value === \"string\" ||\n\t\t\tvalue instanceof Uint8Array ||\n\t\t\tvalue instanceof Path ||\n\t\t\tvalue instanceof Blob ||\n\t\t\tvalue instanceof Directory ||\n\t\t\tvalue instanceof File ||\n\t\t\tvalue instanceof Symlink ||\n\t\t\tvalue instanceof Placeholder ||\n\t\t\tvalue instanceof Template ||\n\t\t\tvalue instanceof Array ||\n\t\t\ttypeof value === \"object\"\n\t\t);\n\t},\n\n\ttoSyscall: <T extends Value>(value: T): syscall.Value => {\n\t\tif (value === undefined || value === null) {\n\t\t\treturn {\n\t\t\t\tkind: \"null\",\n\t\t\t\tvalue,\n\t\t\t};\n\t\t} else if (typeof value === \"boolean\") {\n\t\t\treturn {\n\t\t\t\tkind: \"bool\",\n\t\t\t\tvalue,\n\t\t\t};\n\t\t} else if (typeof value === \"number\") {\n\t\t\treturn {\n\t\t\t\tkind: \"number\",\n\t\t\t\tvalue,\n\t\t\t};\n\t\t} else if (typeof value === \"string\") {\n\t\t\treturn {\n\t\t\t\tkind: \"string\",\n\t\t\t\tvalue,\n\t\t\t};\n\t\t} else if (value instanceof Uint8Array) {\n\t\t\treturn {\n\t\t\t\tkind: \"bytes\",\n\t\t\t\tvalue,\n\t\t\t};\n\t\t} else if (value instanceof Path) {\n\t\t\treturn {\n\t\t\t\tkind: \"path\",\n\t\t\t\tvalue: value.toSyscall(),\n\t\t\t};\n\t\t} else if (value instanceof Blob) {\n\t\t\treturn {\n\t\t\t\tkind: \"blob\",\n\t\t\t\tvalue: value.toSyscall(),\n\t\t\t};\n\t\t} else if (Artifact.isArtifact(value)) {\n\t\t\treturn {\n\t\t\t\tkind: \"artifact\",\n\t\t\t\tvalue: Artifact.toSyscall(value),\n\t\t\t};\n\t\t} else if (value instanceof Placeholder) {\n\t\t\treturn {\n\t\t\t\tkind: \"placeholder\",\n\t\t\t\tvalue: value.toSyscall(),\n\t\t\t};\n\t\t} else if (value instanceof Template) {\n\t\t\treturn {\n\t\t\t\tkind: \"template\",\n\t\t\t\tvalue: value.toSyscall(),\n\t\t\t};\n\t\t} else if (value instanceof Array) {\n\t\t\tlet syscallValue = value.map((value) => Value.toSyscall(value));\n\t\t\treturn {\n\t\t\t\tkind: \"array\",\n\t\t\t\tvalue: syscallValue,\n\t\t\t};\n\t\t} else if (typeof value === \"object\") {\n\t\t\tlet syscallValue = Object.fromEntries(\n\t\t\t\tObject.entries(value).map(([key, value]) => [\n\t\t\t\t\tkey,\n\t\t\t\t\tValue.toSyscall(value),\n\t\t\t\t]),\n\t\t\t);\n\t\t\treturn {\n\t\t\t\tkind: \"object\",\n\t\t\t\tvalue: syscallValue,\n\t\t\t};\n\t\t} else {\n\t\t\treturn unreachable();\n\t\t}\n\t},\n\n\tfromSyscall: (value: syscall.Value): Value => {\n\t\tswitch (value.kind) {\n\t\t\tcase \"null\": {\n\t\t\t\treturn value.value;\n\t\t\t}\n\t\t\tcase \"bool\": {\n\t\t\t\treturn value.value;\n\t\t\t}\n\t\t\tcase \"number\": {\n\t\t\t\treturn value.value;\n\t\t\t}\n\t\t\tcase \"string\": {\n\t\t\t\treturn value.value;\n\t\t\t}\n\t\t\tcase \"bytes\": {\n\t\t\t\treturn value.value;\n\t\t\t}\n\t\t\tcase \"path\": {\n\t\t\t\treturn Path.fromSyscall(value.value);\n\t\t\t}\n\t\t\tcase \"blob\": {\n\t\t\t\treturn Blob.fromSyscall(value.value);\n\t\t\t}\n\t\t\tcase \"artifact\": {\n\t\t\t\treturn Artifact.fromSyscall(value.value);\n\t\t\t}\n\t\t\tcase \"placeholder\": {\n\t\t\t\treturn Placeholder.fromSyscall(value.value);\n\t\t\t}\n\t\t\tcase \"template\": {\n\t\t\t\treturn Template.fromSyscall(value.value);\n\t\t\t}\n\t\t\tcase \"array\": {\n\t\t\t\treturn value.value.map((value) => Value.fromSyscall(value));\n\t\t\t}\n\t\t\tcase \"object\": {\n\t\t\t\treturn Object.fromEntries(\n\t\t\t\t\tObject.entries(value.value).map(([key, value]) => [\n\t\t\t\t\t\tkey,\n\t\t\t\t\t\tValue.fromSyscall(value),\n\t\t\t\t\t]),\n\t\t\t\t);\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\treturn unreachable();\n\t\t\t}\n\t\t}\n\t},\n};\n", "import { Artifact } from \"./artifact.ts\";\nimport { assert } from \"./assert.ts\";\nimport { Blob } from \"./blob.ts\";\nimport { File, file } from \"./file.ts\";\nimport { Path, path } from \"./path.ts\";\nimport { Unresolved, resolve } from \"./resolve.ts\";\nimport { Symlink } from \"./symlink.ts\";\nimport * as syscall from \"./syscall.ts\";\nimport { nullish } from \"./value.ts\";\n\nexport namespace Directory {\n\texport type Arg = nullish | Directory | ArgObject;\n\n\texport type ArgObject = { [name: string]: ArgObjectValue };\n\n\texport type ArgObjectValue = nullish | Blob.Arg | Artifact | ArgObject;\n\n\texport type ConstructorArg = {\n\t\thash: Artifact.Hash;\n\t\tentries: Map<string, Artifact.Hash>;\n\t};\n}\n\nexport let directory = async (\n\t...args: Array<Unresolved<Directory.Arg>>\n): Promise<Directory> => {\n\t// Create the entries.\n\tlet entries: Map<string, Artifact> = new Map();\n\n\t// Apply each arg.\n\tfor (let arg of await Promise.all(args.map(resolve))) {\n\t\tif (nullish.isNullish(arg)) {\n\t\t\t// If the arg is null, then continue.\n\t\t} else if (arg instanceof Directory) {\n\t\t\t// If the arg is a directory, then apply each entry.\n\t\t\tfor (let [name, entry] of await arg.entries()) {\n\t\t\t\t// Get an existing entry.\n\t\t\t\tlet existingEntry = entries.get(name);\n\n\t\t\t\t// Merge the existing entry with the entry if they are both directories.\n\t\t\t\tif (existingEntry instanceof Directory && entry instanceof Directory) {\n\t\t\t\t\tentry = await directory(existingEntry, entry);\n\t\t\t\t}\n\n\t\t\t\t// Set the entry.\n\t\t\t\tentries.set(name, entry);\n\t\t\t}\n\t\t} else if (typeof arg === \"object\") {\n\t\t\t// If the arg is an object, then apply each entry.\n\t\t\tfor (let [key, value] of Object.entries(arg)) {\n\t\t\t\t// Separate the first path component from the trailing path components.\n\t\t\t\tlet [firstComponent, ...trailingComponents] = path(key).components();\n\t\t\t\tif (firstComponent === undefined) {\n\t\t\t\t\tthrow new Error(\"The path must have at least one component.\");\n\t\t\t\t}\n\n\t\t\t\t// All path components must be normal.\n\t\t\t\tif (firstComponent.kind !== \"normal\") {\n\t\t\t\t\tthrow new Error(`Invalid path component.`);\n\t\t\t\t}\n\t\t\t\tlet name = firstComponent.value;\n\n\t\t\t\t// Get an existing entry.\n\t\t\t\tlet existingEntry = entries.get(name);\n\n\t\t\t\t// Remove the entry if it is not a directory.\n\t\t\t\tif (!(existingEntry instanceof Directory)) {\n\t\t\t\t\texistingEntry = undefined;\n\t\t\t\t}\n\n\t\t\t\tif (trailingComponents.length > 0) {\n\t\t\t\t\t// If there are trailing path components, then recurse.\n\t\t\t\t\tlet trailingPath = path(trailingComponents).toString();\n\n\t\t\t\t\t// Merge the entry with the trailing path.\n\t\t\t\t\tlet newEntry = await directory(existingEntry, {\n\t\t\t\t\t\t[trailingPath]: value,\n\t\t\t\t\t});\n\n\t\t\t\t\t// Add the entry.\n\t\t\t\t\tentries.set(name, newEntry);\n\t\t\t\t} else {\n\t\t\t\t\t// If there are no trailing path components, then create the artifact specified by the value.\n\t\t\t\t\tif (nullish.isNullish(value)) {\n\t\t\t\t\t\tentries.delete(name);\n\t\t\t\t\t} else if (Blob.isBlobArg(value)) {\n\t\t\t\t\t\tlet newEntry = await file(value);\n\t\t\t\t\t\tentries.set(name, newEntry);\n\t\t\t\t\t} else if (File.isFile(value) || Symlink.isSymlink(value)) {\n\t\t\t\t\t\tentries.set(name, value);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlet newEntry = await directory(existingEntry, value);\n\t\t\t\t\t\tentries.set(name, newEntry);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Create the directory.\n\treturn Directory.fromSyscall(\n\t\tawait syscall.directory.new(\n\t\t\tnew Map(\n\t\t\t\tArray.from(entries, ([name, entry]) => [\n\t\t\t\t\tname,\n\t\t\t\t\tArtifact.toSyscall(entry),\n\t\t\t\t]),\n\t\t\t),\n\t\t),\n\t);\n};\n\nexport class Directory {\n\t#hash: Artifact.Hash;\n\t#entries: Map<string, Artifact.Hash>;\n\n\tconstructor(arg: Directory.ConstructorArg) {\n\t\tthis.#hash = arg.hash;\n\t\tthis.#entries = arg.entries;\n\t}\n\n\tstatic isDirectory(value: unknown): value is Directory {\n\t\treturn value instanceof Directory;\n\t}\n\n\ttoSyscall(): syscall.Directory {\n\t\treturn {\n\t\t\thash: this.#hash,\n\t\t\tentries: Object.fromEntries(this.#entries),\n\t\t};\n\t}\n\n\tstatic fromSyscall(directory: syscall.Directory): Directory {\n\t\tlet hash = directory.hash;\n\t\tlet entries = new Map(Object.entries(directory.entries));\n\t\treturn new Directory({ hash, entries });\n\t}\n\n\thash(): Artifact.Hash {\n\t\treturn this.#hash;\n\t}\n\n\tasync get(arg: Path.Arg): Promise<Artifact> {\n\t\tlet artifact = await this.tryGet(arg);\n\t\tassert(artifact, `Failed to get the directory entry \"${arg}\".`);\n\t\treturn artifact;\n\t}\n\n\tasync tryGet(arg: Path.Arg): Promise<Artifact | undefined> {\n\t\tlet artifact: Artifact = this;\n\t\tfor (let component of path(arg).components()) {\n\t\t\tassert(component.kind === \"normal\");\n\t\t\tif (!(artifact instanceof Directory)) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\tlet hash = artifact.#entries.get(component.value);\n\t\t\tif (!hash) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\tartifact = await Artifact.get(hash);\n\t\t}\n\t\treturn artifact;\n\t}\n\n\tasync entries(): Promise<Map<string, Artifact>> {\n\t\tlet entries = new Map();\n\t\tfor await (let [name, artifact] of this) {\n\t\t\tentries.set(name, artifact);\n\t\t}\n\t\treturn entries;\n\t}\n\n\tasync bundle(): Promise<Directory> {\n\t\tlet bundledArtifact = Artifact.fromSyscall(\n\t\t\tawait syscall.artifact.bundle(Artifact.toSyscall(this)),\n\t\t);\n\t\tassert(Directory.isDirectory(bundledArtifact));\n\t\treturn bundledArtifact;\n\t}\n\n\tasync *walk(): AsyncIterableIterator<[Path, Artifact]> {\n\t\tfor await (let [name, artifact] of this) {\n\t\t\tyield [path(name), artifact];\n\t\t\tif (Directory.isDirectory(artifact)) {\n\t\t\t\tfor await (let [entryName, entryArtifact] of artifact.walk()) {\n\t\t\t\t\tyield [path(name).join(entryName), entryArtifact];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t*[Symbol.iterator](): Iterator<[string, Artifact.Hash]> {\n\t\tfor (let [name, entry] of this.#entries) {\n\t\t\tyield [name, entry];\n\t\t}\n\t}\n\n\tasync *[Symbol.asyncIterator](): AsyncIterator<[string, Artifact]> {\n\t\tfor (let name of this.#entries.keys()) {\n\t\t\tyield [name, await this.get(name)];\n\t\t}\n\t}\n}\n", "import { unreachable } from \"./assert.ts\";\nimport { Directory } from \"./directory.ts\";\nimport { File } from \"./file.ts\";\nimport { Symlink } from \"./symlink.ts\";\nimport * as syscall from \"./syscall.ts\";\n\nexport type Artifact = Directory | File | Symlink;\n\nexport namespace Artifact {\n\texport type Hash = string;\n\n\texport let isArtifact = (value: unknown): value is Artifact => {\n\t\treturn (\n\t\t\tvalue instanceof Directory ||\n\t\t\tvalue instanceof File ||\n\t\t\tvalue instanceof Symlink\n\t\t);\n\t};\n\n\texport let get = async (hash: Hash): Promise<Artifact> => {\n\t\treturn Artifact.fromSyscall(await syscall.artifact.get(hash));\n\t};\n\n\texport let toSyscall = (artifact: Artifact): syscall.Artifact => {\n\t\tif (artifact instanceof Directory) {\n\t\t\treturn {\n\t\t\t\tkind: \"directory\",\n\t\t\t\tvalue: artifact.toSyscall(),\n\t\t\t};\n\t\t} else if (artifact instanceof File) {\n\t\t\treturn {\n\t\t\t\tkind: \"file\",\n\t\t\t\tvalue: artifact.toSyscall(),\n\t\t\t};\n\t\t} else if (artifact instanceof Symlink) {\n\t\t\treturn {\n\t\t\t\tkind: \"symlink\",\n\t\t\t\tvalue: artifact.toSyscall(),\n\t\t\t};\n\t\t} else {\n\t\t\treturn unreachable();\n\t\t}\n\t};\n\n\texport let fromSyscall = (artifact: syscall.Artifact): Artifact => {\n\t\tswitch (artifact.kind) {\n\t\t\tcase \"directory\": {\n\t\t\t\treturn Directory.fromSyscall(artifact.value);\n\t\t\t}\n\t\t\tcase \"file\": {\n\t\t\t\treturn File.fromSyscall(artifact.value);\n\t\t\t}\n\t\t\tcase \"symlink\": {\n\t\t\t\treturn Symlink.fromSyscall(artifact.value);\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\treturn unreachable();\n\t\t\t}\n\t\t}\n\t};\n}\n", "import { Value } from \"./value.ts\";\n\nexport let env: Map<string, Value> = new Map();\n", "import { assert } from \"./assert.ts\";\nimport { call } from \"./call.ts\";\nimport { env } from \"./env.ts\";\nimport { PackageInstance } from \"./package.ts\";\nimport { MaybePromise, Unresolved, resolve } from \"./resolve.ts\";\nimport * as syscall from \"./syscall.ts\";\nimport { Value } from \"./value.ts\";\n\nexport let function_ = <\n\tA extends Array<Value> = Array<Value>,\n\tR extends Value = Value,\n>(\n\tf: (...args: A) => MaybePromise<R>,\n): Function<A, R> => {\n\t// Get the function's caller.\n\tlet { module, line } = syscall.caller();\n\n\t// Get the function's package instance hash.\n\tassert(module.kind === \"normal\");\n\tlet packageInstanceHash = module.value.packageInstanceHash;\n\n\t// Get the function's name.\n\tlet name;\n\tif (line.startsWith(\"export default \")) {\n\t\tname = \"default\";\n\t} else if (line.startsWith(\"export let \")) {\n\t\tlet exportName = line.match(/^export let ([a-zA-Z0-9]+)\\b/)?.at(1);\n\t\tif (!exportName) {\n\t\t\tthrow new Error(\"Invalid use of tg.function.\");\n\t\t}\n\t\tname = exportName;\n\t} else {\n\t\tthrow new Error(\"Invalid use of tg.function.\");\n\t}\n\n\treturn new Function({\n\t\tpackageInstanceHash,\n\t\tname,\n\t\tf,\n\t});\n};\n\ntype ConstructorArgs<A extends Array<Value>, R extends Value> = {\n\tpackageInstanceHash: PackageInstance.Hash;\n\tname: string;\n\tf?: (...args: A) => MaybePromise<R>;\n};\n\nexport interface Function<\n\tA extends Array<Value> = Array<Value>,\n\tR extends Value = Value,\n> {\n\t(...args: { [K in keyof A]: Unresolved<A[K]> }): Promise<R>;\n}\n\nexport class Function<\n\tA extends Array<Value> = Array<Value>,\n\tR extends Value = Value,\n> extends globalThis.Function {\n\tpackageInstanceHash: PackageInstance.Hash;\n\tname: string;\n\tf?: (...args: A) => MaybePromise<R>;\n\n\tconstructor(args: ConstructorArgs<A, R>) {\n\t\tsuper();\n\n\t\tthis.packageInstanceHash = args.packageInstanceHash;\n\t\tthis.name = args.name;\n\t\tthis.f = args.f;\n\n\t\t// Proxy this object so that it is callable.\n\t\treturn new Proxy(this, {\n\t\t\tapply: async (target, _, args) => {\n\t\t\t\tlet resolvedArgs = await Promise.all(args.map(resolve));\n\t\t\t\treturn await call({\n\t\t\t\t\tfunction: target,\n\t\t\t\t\targs: resolvedArgs as A,\n\t\t\t\t});\n\t\t\t},\n\t\t});\n\t}\n\n\tstatic isFunction(value: unknown): value is Function {\n\t\treturn value instanceof Function;\n\t}\n\n\ttoSyscall(): syscall.Function {\n\t\tlet packageInstanceHash = this.packageInstanceHash;\n\t\tlet name = this.name?.toString();\n\t\treturn {\n\t\t\tpackageInstanceHash,\n\t\t\tname,\n\t\t};\n\t}\n\n\tstatic fromSyscall<A extends Array<Value>, R extends Value>(\n\t\tfunction_: syscall.Function,\n\t): Function<A, R> {\n\t\tlet packageInstanceHash = function_.packageInstanceHash;\n\t\tlet name = function_.name;\n\t\treturn new Function({\n\t\t\tpackageInstanceHash,\n\t\t\tname,\n\t\t});\n\t}\n\n\tasync run(\n\t\tsyscallEnv: { [key: string]: syscall.Value },\n\t\tsyscallArgs: Array<syscall.Value>,\n\t): Promise<syscall.Value> {\n\t\t// Set the env.\n\t\tfor (let [key, value] of Object.entries(syscallEnv)) {\n\t\t\tenv.set(key, Value.fromSyscall(value));\n\t\t}\n\n\t\t// Get the args.\n\t\tlet args = syscallArgs.map(Value.fromSyscall) as A;\n\n\t\t// Call the function.\n\t\tassert(this.f);\n\t\tlet output = await this.f(...args);\n\n\t\treturn Value.toSyscall(output);\n\t}\n}\n", "import { Artifact } from \"./artifact.ts\";\nimport { Checksum } from \"./checksum.ts\";\nimport { Operation } from \"./operation.ts\";\nimport * as syscall from \"./syscall.ts\";\nimport { Value, nullish } from \"./value.ts\";\n\nexport namespace Download {\n\texport type Arg = {\n\t\turl: string;\n\t\tunpack?: boolean | nullish;\n\t\tchecksum?: Checksum | nullish;\n\t\tunsafe?: boolean | nullish;\n\t};\n\n\texport type ConstructorArg = {\n\t\thash: Operation.Hash;\n\t\turl: string;\n\t\tunpack?: boolean | nullish;\n\t\tchecksum?: Checksum | nullish;\n\t\tunsafe?: boolean | nullish;\n\t};\n}\n\nexport let download = async (arg: Download.Arg): Promise<Artifact> => {\n\t// Create the download.\n\tlet download = Download.fromSyscall(\n\t\tawait syscall.download.new(\n\t\t\targ.url,\n\t\t\targ.unpack ?? false,\n\t\t\targ.checksum ?? null,\n\t\t\targ.unsafe ?? false,\n\t\t),\n\t);\n\n\t// Run the operation.\n\tlet output = await download.run();\n\n\treturn output;\n};\n\nexport class Download {\n\t#hash: Operation.Hash;\n\t#url: string;\n\t#unpack: boolean;\n\t#checksum: Checksum | nullish;\n\t#unsafe: boolean;\n\n\tconstructor(arg: Download.ConstructorArg) {\n\t\tthis.#hash = arg.hash;\n\t\tthis.#url = arg.url;\n\t\tthis.#unpack = arg.unpack ?? false;\n\t\tthis.#checksum = arg.checksum ?? null;\n\t\tthis.#unsafe = arg.unsafe ?? false;\n\t}\n\n\tstatic isDownload(value: unknown): value is Download {\n\t\treturn value instanceof Download;\n\t}\n\n\thash(): Operation.Hash {\n\t\treturn this.#hash;\n\t}\n\n\ttoSyscall(): syscall.Download {\n\t\treturn {\n\t\t\thash: this.#hash,\n\t\t\turl: this.#url,\n\t\t\tunpack: this.#unpack,\n\t\t\tchecksum: this.#checksum,\n\t\t\tunsafe: this.#unsafe,\n\t\t};\n\t}\n\n\tstatic fromSyscall(download: syscall.Download): Download {\n\t\treturn new Download({\n\t\t\thash: download.hash,\n\t\t\turl: download.url,\n\t\t\tunpack: download.unpack,\n\t\t\tchecksum: download.checksum,\n\t\t\tunsafe: download.unsafe,\n\t\t});\n\t}\n\n\tasync run(): Promise<Artifact> {\n\t\tlet outputFromSyscall = await syscall.operation.run(\n\t\t\tOperation.toSyscall(this),\n\t\t);\n\t\tlet output = Value.fromSyscall(outputFromSyscall);\n\t\treturn output as Artifact;\n\t}\n}\n", "import { Artifact } from \"./artifact.ts\";\nimport { Checksum } from \"./checksum.ts\";\nimport { Operation } from \"./operation.ts\";\nimport { placeholder } from \"./placeholder.ts\";\nimport { Unresolved, resolve } from \"./resolve.ts\";\nimport * as syscall from \"./syscall.ts\";\nimport { System } from \"./system.ts\";\nimport { Template, template } from \"./template.ts\";\nimport { Value, nullish } from \"./value.ts\";\n\nexport namespace Process {\n\texport type Arg = {\n\t\tsystem: System;\n\t\texecutable: Template.Arg;\n\t\tenv?: Record<string, Template.Arg> | nullish;\n\t\targs?: Array<Template.Arg> | nullish;\n\t\tchecksum?: Checksum | nullish;\n\t\tunsafe?: boolean | nullish;\n\t\tnetwork?: boolean | nullish;\n\t\thostPaths?: Array<string> | nullish;\n\t};\n}\n\nexport let process = async (\n\targ: Unresolved<Process.Arg>,\n): Promise<Artifact> => {\n\t// Resolve the args.\n\tlet resolvedArg = await resolve(arg);\n\n\t// Create the process.\n\tlet system = resolvedArg.system;\n\tlet executable = await template(resolvedArg.executable);\n\tlet env = Object.fromEntries(\n\t\tawait Promise.all(\n\t\t\tObject.entries(resolvedArg.env ?? {}).map(async ([key, value]) => [\n\t\t\t\tkey,\n\t\t\t\tawait template(value),\n\t\t\t]),\n\t\t),\n\t);\n\tlet args_ = await Promise.all(\n\t\t(resolvedArg.args ?? []).map(async (arg) => await template(arg)),\n\t);\n\tlet checksum = resolvedArg.checksum ?? null;\n\tlet unsafe = resolvedArg.unsafe ?? false;\n\tlet network = resolvedArg.network ?? false;\n\tlet hostPaths = resolvedArg.hostPaths ?? [];\n\tlet process = Process.fromSyscall(\n\t\tawait syscall.process.new(\n\t\t\tsystem,\n\t\t\texecutable.toSyscall(),\n\t\t\tenv,\n\t\t\targs_.map((arg) => arg.toSyscall()),\n\t\t\tchecksum,\n\t\t\tunsafe,\n\t\t\tnetwork,\n\t\t\thostPaths,\n\t\t),\n\t);\n\n\t// Run the process.\n\tlet output = await process.run();\n\n\treturn output;\n};\n\nexport let output = placeholder(\"output\");\n\nexport type ConstructorArgs = {\n\thash: Operation.Hash;\n\tsystem: System;\n\texecutable: Template;\n\tenv: Record<string, Template>;\n\targs: Array<Template>;\n\tchecksum: Checksum | nullish;\n\tunsafe: boolean;\n\tnetwork: boolean;\n\thostPaths: Array<string>;\n};\n\nexport class Process {\n\t#hash: Operation.Hash;\n\t#system: System;\n\t#executable: Template;\n\t#env: Record<string, Template>;\n\t#args: Array<Template>;\n\t#checksum: Checksum | nullish;\n\t#unsafe: boolean;\n\t#network: boolean;\n\t#hostPaths: Array<string>;\n\n\tconstructor(args: ConstructorArgs) {\n\t\tthis.#hash = args.hash;\n\t\tthis.#system = args.system;\n\t\tthis.#executable = args.executable;\n\t\tthis.#env = args.env;\n\t\tthis.#args = args.args;\n\t\tthis.#checksum = args.checksum;\n\t\tthis.#unsafe = args.unsafe;\n\t\tthis.#network = args.network;\n\t\tthis.#hostPaths = args.hostPaths;\n\t}\n\n\thash(): Operation.Hash {\n\t\treturn this.#hash;\n\t}\n\n\ttoSyscall(): syscall.Process {\n\t\tlet hash = this.#hash;\n\t\tlet system = this.#system;\n\t\tlet executable = this.#executable.toSyscall();\n\t\tlet env = Object.fromEntries(\n\t\t\tObject.entries(this.#env).map(([key, value]) => [key, value.toSyscall()]),\n\t\t);\n\t\tlet args = this.#args.map((arg) => arg.toSyscall());\n\t\tlet checksum = this.#checksum;\n\t\tlet unsafe = this.#unsafe;\n\t\tlet network = this.#network;\n\t\tlet hostPaths = this.#hostPaths;\n\t\treturn {\n\t\t\thash,\n\t\t\tsystem,\n\t\t\texecutable,\n\t\t\tenv,\n\t\t\targs,\n\t\t\tchecksum,\n\t\t\tunsafe,\n\t\t\tnetwork,\n\t\t\thostPaths,\n\t\t};\n\t}\n\n\tstatic fromSyscall(process: syscall.Process): Process {\n\t\tlet hash = process.hash;\n\t\tlet system = process.system;\n\t\tlet executable = Template.fromSyscall(process.executable);\n\t\tlet env = Object.fromEntries(\n\t\t\tObject.entries(process.env).map(([key, value]) => [\n\t\t\t\tkey,\n\t\t\t\tTemplate.fromSyscall(value),\n\t\t\t]),\n\t\t);\n\t\tlet args = process.args.map((arg) => Template.fromSyscall(arg));\n\t\tlet checksum = process.checksum;\n\t\tlet unsafe = process.unsafe;\n\t\tlet network = process.network;\n\t\tlet hostPaths = process.hostPaths;\n\t\treturn new Process({\n\t\t\thash,\n\t\t\tsystem,\n\t\t\texecutable,\n\t\t\tenv,\n\t\t\targs,\n\t\t\tchecksum,\n\t\t\tunsafe,\n\t\t\tnetwork,\n\t\t\thostPaths,\n\t\t});\n\t}\n\n\tasync run(): Promise<Artifact> {\n\t\tlet outputFromSyscall = await syscall.operation.run(\n\t\t\tOperation.toSyscall(this),\n\t\t);\n\t\tlet output = Value.fromSyscall(outputFromSyscall);\n\t\treturn output as Artifact;\n\t}\n}\n", "import { unreachable } from \"./assert.ts\";\nimport { Call } from \"./call.ts\";\nimport { Download } from \"./download.ts\";\nimport { Process } from \"./process.ts\";\nimport * as syscall from \"./syscall.ts\";\n\nexport type Operation = Call | Download | Process;\n\nexport namespace Operation {\n\texport type Hash = string;\n\n\texport type Kind = \"download\" | \"process\" | \"call\";\n\n\texport let isOperation = (value: unknown): value is Operation => {\n\t\treturn (\n\t\t\tvalue instanceof Call ||\n\t\t\tvalue instanceof Download ||\n\t\t\tvalue instanceof Process\n\t\t);\n\t};\n\n\texport let toSyscall = (operation: Operation): syscall.Operation => {\n\t\tif (operation instanceof Download) {\n\t\t\treturn {\n\t\t\t\tkind: \"download\",\n\t\t\t\tvalue: operation.toSyscall(),\n\t\t\t};\n\t\t} else if (operation instanceof Process) {\n\t\t\treturn {\n\t\t\t\tkind: \"process\",\n\t\t\t\tvalue: operation.toSyscall(),\n\t\t\t};\n\t\t} else if (operation instanceof Call) {\n\t\t\treturn {\n\t\t\t\tkind: \"call\",\n\t\t\t\tvalue: operation.toSyscall(),\n\t\t\t};\n\t\t} else {\n\t\t\treturn unreachable();\n\t\t}\n\t};\n\n\texport let fromSyscall = (\n\t\thash: Operation.Hash,\n\t\toperation: syscall.Operation,\n\t): Operation => {\n\t\tswitch (operation.kind) {\n\t\t\tcase \"download\": {\n\t\t\t\treturn Download.fromSyscall(operation.value);\n\t\t\t}\n\t\t\tcase \"process\": {\n\t\t\t\treturn Process.fromSyscall(operation.value);\n\t\t\t}\n\t\t\tcase \"call\": {\n\t\t\t\treturn Call.fromSyscall(operation.value);\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\treturn unreachable();\n\t\t\t}\n\t\t}\n\t};\n}\n", "import { Function } from \"./function.ts\";\nimport { Operation } from \"./operation.ts\";\nimport * as syscall from \"./syscall.ts\";\nimport { Value, nullish } from \"./value.ts\";\n\nexport namespace Call {\n\texport type Arg<A extends Array<Value>, R extends Value> = {\n\t\tfunction: Function<A, R>;\n\t\tenv?: Record<string, Value> | nullish;\n\t\targs: A;\n\t};\n}\n\nexport let call = async <A extends Array<Value>, R extends Value>(\n\targ: Call.Arg<A, R>,\n): Promise<R> => {\n\t// Get the function, env, and args.\n\tlet function_ = arg.function.toSyscall();\n\tlet env = Object.fromEntries(\n\t\tObject.entries(arg.env ?? {}).map(([key, value]) => [\n\t\t\tkey,\n\t\t\tValue.toSyscall(value),\n\t\t]),\n\t);\n\tlet args_ = (arg.args ?? []).map((arg) => Value.toSyscall(arg));\n\n\t// Create the call.\n\tlet call: Call<A, R> = Call.fromSyscall(\n\t\tawait syscall.call.new(function_, env, args_),\n\t);\n\n\t// Run the operation.\n\tlet output = await call.run();\n\n\treturn output;\n};\n\ntype ConstructorArgs<T extends Value> = {\n\thash: Operation.Hash;\n\tfunction: Function<any, T>;\n\tenv: Map<string, Value>;\n\targs: Array<Value>;\n};\n\nexport class Call<A extends Array<Value> = [], R extends Value = Value> {\n\t#hash: Operation.Hash;\n\t#function: Function<A, R>;\n\t#env: Map<string, Value>;\n\t#args: Array<Value>;\n\n\tconstructor(args: ConstructorArgs<R>) {\n\t\tthis.#hash = args.hash;\n\t\tthis.#function = args.function;\n\t\tthis.#env = args.env;\n\t\tthis.#args = args.args;\n\t}\n\n\tstatic isCall(value: unknown): value is Call<any, any> {\n\t\treturn value instanceof Call;\n\t}\n\n\thash(): Operation.Hash {\n\t\treturn this.#hash;\n\t}\n\n\ttoSyscall(): syscall.Call {\n\t\tlet hash = this.#hash;\n\t\tlet function_ = this.#function.toSyscall();\n\t\tlet env = Object.fromEntries(\n\t\t\tArray.from(this.#env.entries()).map(([key, value]) => [\n\t\t\t\tkey,\n\t\t\t\tValue.toSyscall(value),\n\t\t\t]),\n\t\t);\n\t\tlet args = this.#args.map((arg) => Value.toSyscall(arg));\n\t\treturn {\n\t\t\thash,\n\t\t\tfunction: function_,\n\t\t\tenv,\n\t\t\targs,\n\t\t};\n\t}\n\n\tstatic fromSyscall<A extends Array<Value>, R extends Value>(\n\t\tcall: syscall.Call,\n\t): Call<A, R> {\n\t\tlet hash = call.hash;\n\t\tlet function_ = Function.fromSyscall<Array<Value>, R>(call.function);\n\t\tlet env = new Map(\n\t\t\tObject.entries(call.env).map(([key, value]) => [\n\t\t\t\tkey,\n\t\t\t\tValue.fromSyscall(value),\n\t\t\t]),\n\t\t);\n\t\tlet args = call.args.map((arg) => Value.fromSyscall(arg));\n\t\treturn new Call<A, R>({\n\t\t\thash,\n\t\t\tfunction: function_,\n\t\t\tenv,\n\t\t\targs,\n\t\t});\n\t}\n\n\tasync run(): Promise<R> {\n\t\tlet outputFromSyscall = await syscall.operation.run(\n\t\t\tOperation.toSyscall(this),\n\t\t);\n\t\tlet output = Value.fromSyscall(outputFromSyscall);\n\t\treturn output as R;\n\t}\n}\n", "export function prepareStackTrace(\n\t_error: unknown,\n\tstructuredStackTrace: Array<CallSite>,\n) {\n\tlet callSites = structuredStackTrace.map((callSite) => {\n\t\treturn {\n\t\t\ttypeName: callSite.getTypeName(),\n\t\t\tfunctionName: callSite.getFunctionName(),\n\t\t\tmethodName: callSite.getMethodName(),\n\t\t\tfileName: callSite.getFileName(),\n\t\t\tlineNumber: callSite.getLineNumber(),\n\t\t\tcolumnNumber: callSite.getColumnNumber(),\n\t\t\tisEval: callSite.isEval(),\n\t\t\tisNative: callSite.isNative(),\n\t\t\tisConstructor: callSite.isConstructor(),\n\t\t\tisAsync: callSite.isAsync(),\n\t\t\tisPromiseAll: callSite.isPromiseAll(),\n\t\t\t// isPromiseAny: callSite.isPromiseAny(),\n\t\t\tpromiseIndex: callSite.getPromiseIndex(),\n\t\t};\n\t});\n\treturn { callSites };\n}\n\n/** This type is derived from <https://v8.dev/docs/stack-trace-api#customizing-stack-traces>. */\ntype CallSite = {\n\t/** Returns the type of this as a string. This is the name of the function stored in the constructor field of this, if available, otherwise the object\u2019s [[Class]] internal property. **/\n\tgetTypeName(): string;\n\n\t/** Returns the name of the current function, typically its name property. If a name property is not available an attempt is made to infer a name from the function\u2019s context. **/\n\tgetFunctionName(): string;\n\n\t/** Returns the name of the property of this or one of its prototypes that holds the current function. **/\n\tgetMethodName(): string;\n\n\t/** If this function was defined in a script returns the name of the script. **/\n\tgetFileName(): string | undefined;\n\n\t/** If this function was defined in a script returns the current line number. **/\n\tgetLineNumber(): number | undefined;\n\n\t/** If this function was defined in a script returns the current column number. **/\n\tgetColumnNumber(): number | undefined;\n\n\t/** If this function was created using a call to eval returns a string representing the location where eval was called. **/\n\tgetEvalOrigin(): unknown | undefined;\n\n\t/** does this call take place in code defined by a call to eval? **/\n\tisEval(): boolean;\n\n\t/** is this call in native V8 code? **/\n\tisNative(): boolean;\n\n\t/** is this a constructor call? **/\n\tisConstructor(): boolean;\n\n\t/** Is this an async call (i.e. await, Promise.all(), or Promise.any())? **/\n\tisAsync(): boolean;\n\n\t/** Is this an async call to Promise.all()? **/\n\tisPromiseAll(): boolean;\n\n\t// /** Is this an async call to Promise.any()? **/\n\t// isPromiseAny(): boolean;\n\n\t/** Returns the index of the promise element that was followed in Promise.all() or Promise.any() for async stack traces, or null if the CallSite is not an async Promise.all() or Promise.any() call. **/\n\tgetPromiseIndex(): number | null;\n};\n", "import { Artifact } from \"./artifact.ts\";\nimport * as syscall from \"./syscall.ts\";\n\nexport let include = async (path: string): Promise<Artifact> => {\n\tlet caller = syscall.caller();\n\tlet artifact = Artifact.fromSyscall(await syscall.include(caller, path));\n\treturn artifact;\n};\n", "import * as syscall from \"./syscall.ts\";\n\n/** Write to the log. */\nexport let log = (...args: Array<unknown>) => {\n\tlet string = args.map((arg) => stringify(arg)).join(\" \");\n\tsyscall.log(string);\n};\n\nlet stringify = (value: unknown): string => {\n\treturn stringifyInner(value, new Set());\n};\n\nlet stringifyInner = (value: unknown, visited: Set<unknown>): string => {\n\tswitch (typeof value) {\n\t\tcase \"string\": {\n\t\t\treturn `\"${value}\"`;\n\t\t}\n\t\tcase \"number\": {\n\t\t\treturn value.toString();\n\t\t}\n\t\tcase \"boolean\": {\n\t\t\treturn value ? \"true\" : \"false\";\n\t\t}\n\t\tcase \"undefined\": {\n\t\t\treturn \"undefined\";\n\t\t}\n\t\tcase \"object\": {\n\t\t\treturn stringifyObject(value, visited);\n\t\t}\n\t\tcase \"function\": {\n\t\t\treturn `[function ${value.name ?? \"(anonymous)\"}]`;\n\t\t}\n\t\tcase \"symbol\": {\n\t\t\treturn \"[symbol]\";\n\t\t}\n\t\tcase \"bigint\": {\n\t\t\treturn value.toString();\n\t\t}\n\t}\n};\n\nlet stringifyObject = (value: object | null, visited: Set<unknown>): string => {\n\t// Handle null.\n\tif (value === null) {\n\t\treturn \"null\";\n\t}\n\n\t// If the value is in the visited set, then indicate that this is a circular reference.\n\tif (visited.has(value)) {\n\t\treturn \"[circular]\";\n\t}\n\n\t// Add the value to the visited set.\n\tvisited.add(value);\n\n\tif (value instanceof Array) {\n\t\t// Handle an array.\n\t\treturn `[${value\n\t\t\t.map((value) => stringifyInner(value, visited))\n\t\t\t.join(\", \")}]`;\n\t} else if (value instanceof Error) {\n\t\t// Handle an error.\n\t\treturn value.stack ?? \"\";\n\t} else if (value instanceof Promise) {\n\t\t// Handle a promise.\n\t\treturn \"[promise]\";\n\t} else {\n\t\t// Handle any other object.\n\t\tlet constructorName = \"\";\n\t\tif (\n\t\t\tvalue.constructor !== undefined &&\n\t\t\tvalue.constructor.name !== \"Object\"\n\t\t) {\n\t\t\tconstructorName = `${value.constructor.name} `;\n\t\t}\n\t\tlet entries = Object.entries(value).map(\n\t\t\t([key, value]) => `${key}: ${stringifyInner(value, visited)}`,\n\t\t);\n\t\treturn `${constructorName}{ ${entries.join(\", \")} }`;\n\t}\n};\n", "export namespace System {\n\texport type Arg = System | ArgObject;\n\n\texport type ArgObject = {\n\t\tarch: Arch;\n\t\tos: Os;\n\t};\n}\n\nexport let system = (arg: System.Arg): System => {\n\tif (typeof arg === \"string\") {\n\t\treturn arg;\n\t} else {\n\t\tlet { arch, os } = arg;\n\t\treturn `${arch}_${os}` as System;\n\t}\n};\n\nexport type System =\n\t| \"amd64_linux\"\n\t| \"arm64_linux\"\n\t| \"amd64_macos\"\n\t| \"arm64_macos\";\n\nexport namespace System {\n\texport type Arch = \"amd64\" | \"arm64\";\n\n\texport type Os = \"linux\" | \"macos\";\n\n\texport let arch = (system: System): Arch => {\n\t\tswitch (system) {\n\t\t\tcase \"amd64_linux\":\n\t\t\tcase \"amd64_macos\": {\n\t\t\t\treturn \"amd64\";\n\t\t\t}\n\t\t\tcase \"arm64_linux\":\n\t\t\tcase \"arm64_macos\": {\n\t\t\t\treturn \"arm64\";\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\tthrow new Error(\"Invalid system.\");\n\t\t\t}\n\t\t}\n\t};\n\n\texport let os = (system: System): Os => {\n\t\tswitch (system) {\n\t\t\tcase \"amd64_linux\":\n\t\t\tcase \"arm64_linux\": {\n\t\t\t\treturn \"linux\";\n\t\t\t}\n\t\t\tcase \"amd64_macos\":\n\t\t\tcase \"arm64_macos\": {\n\t\t\t\treturn \"macos\";\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\tthrow new Error(\"Invalid system.\");\n\t\t\t}\n\t\t}\n\t};\n}\n", "import { Artifact } from \"./artifact.ts\";\nimport { Blob, blob } from \"./blob.ts\";\nimport { call } from \"./call.ts\";\nimport { Directory, directory } from \"./directory.ts\";\nimport { download } from \"./download.ts\";\nimport { env } from \"./env.ts\";\nimport { prepareStackTrace } from \"./error.ts\";\nimport { File, file } from \"./file.ts\";\nimport { Function, function_ } from \"./function.ts\";\nimport { include } from \"./include.ts\";\nimport { log } from \"./log.ts\";\nimport { Path, path } from \"./path.ts\";\nimport { Placeholder, placeholder } from \"./placeholder.ts\";\nimport { output, process } from \"./process.ts\";\nimport { resolve } from \"./resolve.ts\";\nimport { Symlink, symlink } from \"./symlink.ts\";\nimport { System, system } from \"./system.ts\";\nimport { Template, t, template } from \"./template.ts\";\nimport { Value, nullish } from \"./value.ts\";\n\n// Set `Error.prepareStackTrace`.\nObject.defineProperties(Error, {\n\tprepareStackTrace: { value: prepareStackTrace },\n});\n\n// Create the console global.\nlet console = {\n\tlog,\n};\nObject.defineProperties(globalThis, {\n\tconsole: { value: console },\n});\n\n// Create the tg global.\nlet tg = {\n\tArtifact,\n\tBlob,\n\tDirectory,\n\tFile,\n\tFunction,\n\tPath,\n\tPlaceholder,\n\tSymlink,\n\tSystem,\n\tTemplate,\n\tValue,\n\tblob,\n\tcall,\n\tdirectory,\n\tdownload,\n\tenv,\n\tfile,\n\tfunction: function_,\n\tinclude,\n\tlog,\n\tnullish,\n\toutput,\n\tpath,\n\tplaceholder,\n\tprocess,\n\tresolve,\n\tsymlink,\n\tsystem,\n\ttemplate,\n};\nObject.defineProperties(globalThis, {\n\ttg: { value: tg },\n\tt: { value: t },\n});\n"],
  "mappings": "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",
  "names": ["assert", "condition", "message", "unreachable", "artifact", "cause", "hash", "blob", "cause", "bytes", "call", "function_", "env", "args", "caller", "download", "url", "unpack", "checksum", "unsafe", "directory", "entries", "file", "executable", "references", "include", "caller", "path", "cause", "log", "value", "cause", "operation", "hash", "process", "system", "executable", "env", "args", "checksum", "unsafe", "network", "hostPaths", "symlink", "target", "file", "arg", "resolvedArg", "resolve", "blob_", "executable", "references", "Blob", "blob", "File", "reference", "Artifact", "#hash", "#blob", "#executable", "#references", "value", "path", "args", "components", "collectComponents", "arg", "component", "Path", "path_", "#components", "value", "lastComponent", "other", "result", "src", "srcPath", "dstPath", "srcComponent", "dstComponent", "Component", "a", "b", "placeholder", "name", "Placeholder", "#name", "value", "t", "strings", "placeholders", "components", "i", "string", "placeholder", "template", "args", "collectComponents", "arg", "Template", "Path", "component", "resolve", "normalizedComponents", "lastComponent", "#components", "value", "separator", "resolvedSeparator", "resolvedArgs", "assert", "Component", "Artifact", "Placeholder", "unreachable", "symlink", "arg", "resolvedArg", "resolve", "artifact", "path_", "Path", "Artifact", "Template", "assert", "firstComponent", "secondComponent", "Symlink", "resolvedArgPath", "target", "t", "#hash", "#target", "args", "value", "hash", "path", "result", "Directory", "File", "resolve", "value", "Path", "Blob", "Directory", "File", "Symlink", "Placeholder", "Template", "key", "blob", "arg", "resolvedArg", "resolve", "bytes", "Blob", "#hash", "value", "hash", "nullish", "value", "Value", "Path", "Blob", "Directory", "File", "Symlink", "Placeholder", "Template", "Artifact", "key", "unreachable", "directory", "args", "entries", "arg", "resolve", "nullish", "Directory", "name", "entry", "existingEntry", "key", "value", "firstComponent", "trailingComponents", "path", "trailingPath", "newEntry", "Blob", "file", "File", "Symlink", "Artifact", "#hash", "#entries", "hash", "artifact", "assert", "component", "bundledArtifact", "entryName", "entryArtifact", "Artifact", "value", "Directory", "File", "Symlink", "hash", "artifact", "unreachable", "env", "function_", "f", "module", "line", "caller", "assert", "packageInstanceHash", "name", "exportName", "Function", "args", "target", "_", "resolvedArgs", "resolve", "call", "value", "syscallEnv", "syscallArgs", "key", "env", "Value", "output", "download", "arg", "Download", "#hash", "#url", "#unpack", "#checksum", "#unsafe", "value", "outputFromSyscall", "operation", "Operation", "Value", "process", "arg", "resolvedArg", "resolve", "system", "executable", "template", "env", "key", "value", "args_", "checksum", "unsafe", "network", "hostPaths", "Process", "output", "placeholder", "#hash", "#system", "#executable", "#env", "#args", "#checksum", "#unsafe", "#network", "#hostPaths", "args", "hash", "Template", "outputFromSyscall", "operation", "Operation", "Value", "Operation", "value", "Call", "Download", "Process", "operation", "unreachable", "hash", "call", "arg", "function_", "env", "key", "value", "Value", "args_", "Call", "#hash", "#function", "#env", "#args", "args", "hash", "Function", "outputFromSyscall", "operation", "Operation", "prepareStackTrace", "_error", "structuredStackTrace", "callSite", "include", "path", "caller", "Artifact", "log", "args", "string", "arg", "stringify", "value", "stringifyInner", "visited", "stringifyObject", "constructorName", "entries", "key", "system", "arg", "arch", "os", "System", "prepareStackTrace", "console", "log", "tg", "Artifact", "Blob", "Directory", "File", "Function", "Path", "Placeholder", "Symlink", "System", "Template", "Value", "blob", "call", "directory", "download", "env", "file", "function_", "include", "nullish", "output", "path", "placeholder", "process", "resolve", "symlink", "system", "template", "t"]
}
