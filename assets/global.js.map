{
  "version": 3,
  "sources": ["../src/global/array.ts", "../src/global/syscall.ts", "../src/global/blob.ts", "../src/global/file.ts", "../src/global/path.ts", "../src/global/util.ts", "../src/global/placeholder.ts", "../src/global/resolve.ts", "../src/global/template.ts", "../src/global/symlink.ts", "../src/global/value.ts", "../src/global/directory.ts", "../src/global/artifact.ts", "../src/global/bundle.ts", "../src/global/checksum.ts", "../src/global/context.ts", "../src/global/function.ts", "../src/global/call.ts", "../src/global/process.ts", "../src/global/operation.ts", "../src/global/download.ts", "../src/global/error.ts", "../src/global/include.ts", "../src/global/log.ts", "../src/global/map.ts", "../src/global/main.ts"],
  "sourcesContent": ["export type MaybeArray<T> = T | Array<T>;\n\nexport type ArrayLike<T> = Iterable<T> | Array<T>;\n\nexport let array = <T>(value: ArrayLike<T>): Array<T> => {\n\treturn Array.from(value);\n};\n", "export type ArtifactHash = string;\n\nexport type Artifact =\n\t| { kind: \"directory\"; value: Directory }\n\t| { kind: \"file\"; value: File }\n\t| { kind: \"symlink\"; value: Symlink };\n\nexport type BlobHash = string;\n\nexport type Blob = Uint8Array;\n\nexport type Directory = {\n\tentries: Record<string, ArtifactHash>;\n};\n\nexport type File = {\n\tblobHash: BlobHash;\n\texecutable: boolean;\n\treferences: Array<ArtifactHash>;\n};\n\nexport type Symlink = {\n\ttarget: Template;\n};\n\nexport type Value =\n\t| { kind: \"null\"; value: nullish }\n\t| { kind: \"bool\"; value: boolean }\n\t| { kind: \"number\"; value: number }\n\t| { kind: \"string\"; value: string }\n\t| { kind: \"artifact\"; value: ArtifactHash }\n\t| { kind: \"placeholder\"; value: Placeholder }\n\t| { kind: \"template\"; value: Template }\n\t| { kind: \"array\"; value: Array<Value> }\n\t| { kind: \"map\"; value: Record<string, Value> };\n\nexport type Placeholder = {\n\tname: string;\n};\n\nexport type Template = {\n\tcomponents: Array<TemplateComponent>;\n};\n\nexport type TemplateComponent =\n\t| { kind: \"string\"; value: string }\n\t| { kind: \"artifact\"; value: ArtifactHash }\n\t| { kind: \"placeholder\"; value: Placeholder };\n\nexport type OperationHash = string;\n\nexport type Operation =\n\t| { kind: \"call\"; value: Call }\n\t| { kind: \"download\"; value: Download }\n\t| { kind: \"process\"; value: Process };\n\nexport type Download = {\n\turl: string;\n\tunpack: boolean;\n\tchecksum: Checksum | nullish;\n\tunsafe: boolean;\n};\n\nexport type UnpackFormat =\n\t| \".bz2\"\n\t| \".gz\"\n\t| \".lz\"\n\t| \".xz\"\n\t| \".zstd\"\n\t| \".tar\"\n\t| \".tar.bz2\"\n\t| \".tar.gz\"\n\t| \".tar.lz\"\n\t| \".tar.xz\"\n\t| \".tar.zstd\"\n\t| \".zip\";\n\nexport type Process = {\n\tsystem: System;\n\tenv: Record<string, Template>;\n\tcommand: Template;\n\targs: Array<Template>;\n\tchecksum: Checksum | nullish;\n\tunsafe: boolean;\n\tnetwork: boolean;\n\thostPaths: Array<string>;\n};\n\nexport type System =\n\t| \"amd64_linux\"\n\t| \"arm64_linux\"\n\t| \"amd64_macos\"\n\t| \"arm64_macos\";\n\nexport type Call = {\n\tfunction: Function;\n\tcontext: Record<string, Value>;\n\targs: Array<Value>;\n};\n\nexport type Function = {\n\tpackageInstanceHash: PackageInstanceHash;\n\tname: string;\n};\n\nexport type PackageInstanceHash = string;\n\nexport type PackageInstance = {\n\tpackageHash: ArtifactHash;\n\tdependencies: Record<string, PackageInstanceHash>;\n};\n\nexport type Checksum = `${ChecksumAlgorithm}${\":\" | \"-\"}${string}`;\n\nexport type ChecksumAlgorithm = \"blake3\" | \"sha256\";\n\nexport type nullish = undefined | null;\n\nexport type Caller = {\n\tmoduleIdentifier: unknown;\n\tposition: Position;\n\tpackageInstanceHash: PackageInstanceHash;\n\tline: string;\n};\n\nexport type Position = {\n\tline: number;\n\tcharacter: number;\n};\n\ndeclare global {\n\tfunction syscall(syscall: \"log\", value: string): void;\n\n\tfunction syscall(syscall: \"caller\"): Caller;\n\n\tfunction syscall(\n\t\tsyscall: \"include\",\n\t\tcaller: Caller,\n\t\tpath: string,\n\t): Promise<Artifact>;\n\n\tfunction syscall(\n\t\tsyscall: \"checksum\",\n\t\talgorithm: ChecksumAlgorithm,\n\t\tbytes: Uint8Array | string,\n\t): Checksum;\n\n\tfunction syscall(syscall: \"encode_utf8\", string: string): Uint8Array;\n\n\tfunction syscall(syscall: \"decode_utf8\", bytes: Uint8Array): string;\n\n\tfunction syscall(syscall: \"add_blob\", blob: Uint8Array): Promise<BlobHash>;\n\n\tfunction syscall(syscall: \"get_blob\", hash: BlobHash): Promise<Uint8Array>;\n\n\tfunction syscall(\n\t\tsyscall: \"add_artifact\",\n\t\tartifact: Artifact,\n\t): Promise<ArtifactHash>;\n\n\tfunction syscall(\n\t\tsyscall: \"get_artifact\",\n\t\thash: ArtifactHash,\n\t): Promise<Artifact>;\n\n\tfunction syscall(\n\t\tsyscall: \"add_package_instance\",\n\t\tpackageInstance: PackageInstance,\n\t): Promise<PackageInstanceHash>;\n\n\tfunction syscall(\n\t\tsyscall: \"get_package_instance\",\n\t\thash: PackageInstanceHash,\n\t): Promise<PackageInstance>;\n\n\tfunction syscall(\n\t\tsyscall: \"add_operation\",\n\t\toperation: Operation,\n\t): Promise<OperationHash>;\n\n\tfunction syscall(\n\t\tsyscall: \"get_operation\",\n\t\thash: OperationHash,\n\t): Promise<Operation>;\n\n\tfunction syscall(\n\t\tsyscall: \"run_operation\",\n\t\thash: OperationHash,\n\t): Promise<Value>;\n\n\tfunction syscall(\n\t\tsyscall: \"bundle\",\n\t\thash: ArtifactHash,\n\t): Promise<ArtifactHash>;\n}\n\nexport let log = (value: string) => {\n\ttry {\n\t\treturn syscall(\"log\", value);\n\t} catch (cause) {\n\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t}\n};\n\nexport let caller = (): Caller => {\n\ttry {\n\t\treturn syscall(\"caller\");\n\t} catch (cause) {\n\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t}\n};\n\nexport let include = async (\n\tcaller: Caller,\n\tpath: string,\n): Promise<Artifact> => {\n\ttry {\n\t\treturn await syscall(\"include\", caller, path);\n\t} catch (cause) {\n\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t}\n};\n\nexport let checksum = (\n\talgorithm: ChecksumAlgorithm,\n\tbytes: Uint8Array | string,\n): Checksum => {\n\ttry {\n\t\treturn syscall(\"checksum\", algorithm, bytes);\n\t} catch (cause) {\n\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t}\n};\n\nexport let encodeUtf8 = (string: string): Uint8Array => {\n\ttry {\n\t\treturn syscall(\"encode_utf8\", string);\n\t} catch (cause) {\n\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t}\n};\n\nexport let decodeUtf8 = (bytes: Uint8Array): string => {\n\ttry {\n\t\treturn syscall(\"decode_utf8\", bytes);\n\t} catch (cause) {\n\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t}\n};\n\nexport let addBlob = async (blob: Uint8Array): Promise<BlobHash> => {\n\ttry {\n\t\treturn await syscall(\"add_blob\", blob);\n\t} catch (cause) {\n\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t}\n};\n\nexport let getBlob = async (hash: BlobHash): Promise<Uint8Array> => {\n\ttry {\n\t\treturn await syscall(\"get_blob\", hash);\n\t} catch (cause) {\n\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t}\n};\n\nexport let addArtifact = async (artifact: Artifact): Promise<ArtifactHash> => {\n\ttry {\n\t\treturn await syscall(\"add_artifact\", artifact);\n\t} catch (cause) {\n\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t}\n};\n\nexport let getArtifact = async (hash: ArtifactHash): Promise<Artifact> => {\n\ttry {\n\t\treturn await syscall(\"get_artifact\", hash);\n\t} catch (cause) {\n\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t}\n};\n\nexport let addPackageInstance = async (\n\tpackageInstance: PackageInstance,\n): Promise<PackageInstanceHash> => {\n\ttry {\n\t\treturn await syscall(\"add_package_instance\", packageInstance);\n\t} catch (cause) {\n\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t}\n};\n\nexport let getPackageInstance = async (\n\thash: PackageInstanceHash,\n): Promise<PackageInstance> => {\n\ttry {\n\t\treturn await syscall(\"get_package_instance\", hash);\n\t} catch (cause) {\n\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t}\n};\n\nexport let addOperation = async (\n\toperation: Operation,\n): Promise<OperationHash> => {\n\ttry {\n\t\treturn await syscall(\"add_operation\", operation);\n\t} catch (cause) {\n\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t}\n};\n\nexport let getOperation = async (hash: OperationHash): Promise<Operation> => {\n\ttry {\n\t\treturn await syscall(\"get_operation\", hash);\n\t} catch (cause) {\n\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t}\n};\n\nexport let runOperation = async (hash: OperationHash): Promise<Value> => {\n\ttry {\n\t\treturn await syscall(\"run_operation\", hash);\n\t} catch (cause) {\n\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t}\n};\n\nexport let bundle = async (hash: ArtifactHash): Promise<ArtifactHash> => {\n\ttry {\n\t\treturn await syscall(\"bundle\", hash);\n\t} catch (cause) {\n\t\tthrow new Error(\"The syscall failed.\", { cause });\n\t}\n};\n", "import { MaybePromise } from \"./resolve.ts\";\nimport * as syscall from \"./syscall.ts\";\n\nexport type BlobHash = string;\n\nexport type BlobLike = Uint8Array | string | Blob;\n\nexport let isBlobLike = (value: unknown): value is BlobLike => {\n\treturn (\n\t\tvalue instanceof Uint8Array ||\n\t\ttypeof value === \"string\" ||\n\t\tvalue instanceof Blob\n\t);\n};\n\nexport let blob = async (blobLike: MaybePromise<BlobLike>): Promise<Blob> => {\n\tblobLike = await blobLike;\n\tif (blobLike instanceof Uint8Array) {\n\t\treturn new Blob(await addBlob(blobLike));\n\t} else if (typeof blobLike === \"string\") {\n\t\tlet bytes = syscall.encodeUtf8(blobLike);\n\t\treturn new Blob(await addBlob(bytes));\n\t} else {\n\t\treturn blobLike;\n\t}\n};\n\nexport class Blob {\n\t#hash: BlobHash;\n\n\tconstructor(hash: BlobHash) {\n\t\tthis.#hash = hash;\n\t}\n\n\thash(): BlobHash {\n\t\treturn this.#hash;\n\t}\n\n\tasync bytes(): Promise<Uint8Array> {\n\t\treturn await getBlob(this.#hash);\n\t}\n\n\tasync text(): Promise<string> {\n\t\tlet bytes = await this.bytes();\n\t\treturn syscall.decodeUtf8(bytes);\n\t}\n}\n\nexport let addBlob = async (bytes: Uint8Array): Promise<BlobHash> => {\n\treturn await syscall.addBlob(bytes);\n};\n\nexport let getBlob = async (hash: BlobHash): Promise<Uint8Array> => {\n\treturn await syscall.getBlob(hash);\n};\n", "import {\n\tArtifact,\n\tArtifactHash,\n\taddArtifact,\n\tgetArtifact,\n} from \"./artifact.ts\";\nimport { Blob, BlobHash, BlobLike, blob, isBlobLike } from \"./blob.ts\";\nimport { MaybePromise } from \"./resolve.ts\";\nimport * as syscall from \"./syscall.ts\";\n\nexport type FileLike = BlobLike | File;\n\nexport let isFileLike = (value: unknown): value is FileLike => {\n\treturn isBlobLike(value) || value instanceof File;\n};\n\nexport type FileArg = MaybePromise<BlobLike | File | FileObject>;\n\nexport type FileObject = {\n\tblob: MaybePromise<BlobLike>;\n\texecutable?: boolean;\n\treferences?: Array<MaybePromise<Artifact>>;\n};\n\nexport let file = async (arg: FileArg): Promise<File> => {\n\targ = await arg;\n\tif (isBlobLike(arg)) {\n\t\treturn new File({\n\t\t\tblobHash: (await blob(arg)).hash(),\n\t\t\texecutable: false,\n\t\t\treferences: [],\n\t\t});\n\t} else if (isFile(arg)) {\n\t\treturn arg;\n\t} else {\n\t\tlet blobHash = (await blob(arg.blob)).hash();\n\t\tlet executable = arg.executable ?? false;\n\t\tlet references = await Promise.all(\n\t\t\t(arg.references ?? []).map(async (reference) => {\n\t\t\t\treference = await reference;\n\t\t\t\treturn await reference.hash();\n\t\t\t}),\n\t\t);\n\t\treturn new File({ blobHash, executable, references });\n\t}\n};\n\nexport let isFile = (value: unknown): value is File => {\n\treturn value instanceof File;\n};\n\ntype FileConstructorArgs = {\n\tblobHash: BlobHash;\n\texecutable: boolean;\n\treferences: Array<ArtifactHash>;\n};\n\nexport class File {\n\t#blobHash: BlobHash;\n\t#executable: boolean;\n\t#references: Array<ArtifactHash>;\n\n\tconstructor(args: FileConstructorArgs) {\n\t\tthis.#blobHash = args.blobHash;\n\t\tthis.#executable = args.executable;\n\t\tthis.#references = args.references;\n\t}\n\n\tasync serialize(): Promise<syscall.File> {\n\t\tlet blobHash = this.#blobHash;\n\t\tlet executable = this.#executable;\n\t\tlet references = this.#references;\n\t\treturn {\n\t\t\tblobHash,\n\t\t\texecutable,\n\t\t\treferences,\n\t\t};\n\t}\n\n\tstatic async deserialize(file: syscall.File): Promise<File> {\n\t\tlet blobHash = file.blobHash;\n\t\tlet executable = file.executable;\n\t\tlet references = file.references;\n\t\treturn new File({ blobHash, executable, references });\n\t}\n\n\tasync hash(): Promise<ArtifactHash> {\n\t\treturn await addArtifact(this);\n\t}\n\n\tblobHash(): BlobHash {\n\t\treturn this.#blobHash;\n\t}\n\n\tblob(): Blob {\n\t\treturn new Blob(this.#blobHash);\n\t}\n\n\tasync bytes(): Promise<Uint8Array> {\n\t\treturn await this.blob().bytes();\n\t}\n\n\tasync text(): Promise<string> {\n\t\treturn await this.blob().text();\n\t}\n\n\texecutable(): boolean {\n\t\treturn this.#executable;\n\t}\n\n\tasync references(): Promise<Array<Artifact>> {\n\t\treturn await Promise.all(this.#references.map(getArtifact));\n\t}\n}\n", "export type PathLike = string | Array<PathComponent> | Path;\n\nexport type PathComponentKind = \"parent_dir\" | \"normal\";\n\nexport type PathComponent =\n\t| { kind: \"parent_dir\" }\n\t| { kind: \"normal\"; value: string };\n\nexport let path = (path: PathLike): Path => {\n\treturn new Path(path);\n};\n\nexport let isPath = (value: unknown): value is Path => {\n\treturn value instanceof Path;\n};\n\nexport class Path {\n\t#components: Array<PathComponent>;\n\n\tconstructor(pathLike: PathLike) {\n\t\tif (typeof pathLike === \"string\") {\n\t\t\t// Create the components.\n\t\t\tthis.#components = [];\n\n\t\t\t// Split the string by the path separator.\n\t\t\tlet components = pathLike.split(\"/\");\n\n\t\t\t// Push each component.\n\t\t\tfor (let component of components) {\n\t\t\t\tif (component === \"\" || component === \".\") {\n\t\t\t\t\t// Ignore empty and current dir components.\n\t\t\t\t} else if (component === \"..\") {\n\t\t\t\t\tthis.push({ kind: \"parent_dir\" });\n\t\t\t\t} else {\n\t\t\t\t\tthis.push({\n\t\t\t\t\t\tkind: \"normal\",\n\t\t\t\t\t\tvalue: component,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (pathLike instanceof Array) {\n\t\t\tthis.#components = pathLike;\n\t\t} else {\n\t\t\tthis.#components = pathLike.components();\n\t\t}\n\t}\n\n\tcomponents(): Array<PathComponent> {\n\t\treturn [...this.#components];\n\t}\n\n\tpush(component: PathComponent) {\n\t\tif (component.kind === \"parent_dir\") {\n\t\t\tlet lastComponent = this.#components.at(-1);\n\t\t\tif (lastComponent === undefined || lastComponent.kind === \"parent_dir\") {\n\t\t\t\tthis.#components.push(component);\n\t\t\t} else {\n\t\t\t\tthis.#components.pop();\n\t\t\t}\n\t\t} else {\n\t\t\tthis.#components.push(component);\n\t\t}\n\t}\n\n\tparent(): Path {\n\t\tlet result = path(this);\n\t\tresult.push({ kind: \"parent_dir\" });\n\t\treturn result;\n\t}\n\n\tjoin(other: PathLike): Path {\n\t\tlet result = path(this);\n\t\tfor (let component of path(other).components()) {\n\t\t\tresult.push(component);\n\t\t}\n\t\treturn result;\n\t}\n\n\ttoString(): string {\n\t\treturn this.#components\n\t\t\t.map((component) => {\n\t\t\t\tswitch (component.kind) {\n\t\t\t\t\tcase \"parent_dir\": {\n\t\t\t\t\t\treturn \"..\";\n\t\t\t\t\t}\n\t\t\t\t\tcase \"normal\": {\n\t\t\t\t\t\treturn component.value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})\n\t\t\t.join(\"/\");\n\t}\n}\n", "export let assert: (condition: any, message?: string) => asserts condition = (\n\tcondition,\n\tmessage,\n) => {\n\tif (!condition) {\n\t\tmessage = message ?? \"Failed assertion.\";\n\t\tthrow new Error(message);\n\t}\n};\n", "import * as syscall from \"./syscall.ts\";\n\nexport let placeholder = (name: string): Placeholder => {\n\treturn new Placeholder(name);\n};\n\nexport let isPlaceholder = (value: unknown): value is Placeholder => {\n\treturn value instanceof Placeholder;\n};\n\nexport class Placeholder {\n\t#name: string;\n\n\tconstructor(name: string) {\n\t\tthis.#name = name;\n\t}\n\n\tasync serialize(): Promise<syscall.Placeholder> {\n\t\treturn {\n\t\t\tname: this.#name,\n\t\t};\n\t}\n\n\tstatic async deserialize(\n\t\tplaceholder: syscall.Placeholder,\n\t): Promise<Placeholder> {\n\t\tlet name = placeholder.name;\n\t\treturn new Placeholder(name);\n\t}\n\n\tname(): string {\n\t\treturn this.#name;\n\t}\n}\n", "import { Artifact } from \"./artifact.ts\";\nimport { Directory } from \"./directory.ts\";\nimport { File } from \"./file.ts\";\nimport { Placeholder } from \"./placeholder.ts\";\nimport { Symlink } from \"./symlink.ts\";\nimport { Template } from \"./template.ts\";\nimport { Value, nullish } from \"./value.ts\";\n\nexport type Unresolved<T extends Value> = T extends\n\t| nullish\n\t| boolean\n\t| number\n\t| string\n\t| Artifact\n\t| Placeholder\n\t| Template\n\t? MaybePromise<T>\n\t: T extends Array<infer U extends Value>\n\t? MaybePromise<Array<Unresolved<U>>>\n\t: T extends { [key: string]: Value }\n\t? MaybePromise<{ [K in keyof T]: Unresolved<T[K]> }>\n\t: never;\n\nexport type Resolved<T extends Unresolved<Value>> = T extends\n\t| nullish\n\t| boolean\n\t| number\n\t| string\n\t| Artifact\n\t| Placeholder\n\t| Template\n\t? T\n\t: T extends Array<infer U extends Unresolved<Value>>\n\t? Array<Resolved<U>>\n\t: T extends { [key: string]: Unresolved<Value> }\n\t? { [K in keyof T]: Resolved<T[K]> }\n\t: T extends Promise<infer U extends Unresolved<Value>>\n\t? Resolved<U>\n\t: never;\n\nexport type MaybeThunk<T> = T | (() => T);\n\nexport type MaybePromise<T> = T | PromiseLike<T>;\n\nexport type MaybeArray<T> = T | Array<T>;\n\nexport let resolve = async <T extends Unresolved<Value>>(\n\tvalue: T,\n): Promise<Resolved<T>> => {\n\tvalue = await value;\n\tif (\n\t\tvalue === undefined ||\n\t\tvalue === null ||\n\t\ttypeof value === \"boolean\" ||\n\t\ttypeof value === \"number\" ||\n\t\ttypeof value === \"string\" ||\n\t\tvalue instanceof Directory ||\n\t\tvalue instanceof File ||\n\t\tvalue instanceof Symlink ||\n\t\tvalue instanceof Placeholder ||\n\t\tvalue instanceof Template\n\t) {\n\t\treturn value as unknown as Resolved<T>;\n\t} else if (value instanceof Array) {\n\t\treturn (await Promise.all(\n\t\t\tvalue.map((value) => resolve(value)),\n\t\t)) as Resolved<T>;\n\t} else if (typeof value === \"object\") {\n\t\treturn Object.fromEntries(\n\t\t\tawait Promise.all(\n\t\t\t\tObject.entries(value).map(async ([key, value]) => [\n\t\t\t\t\tkey,\n\t\t\t\t\tawait resolve(value),\n\t\t\t\t]),\n\t\t\t),\n\t\t) as Resolved<T>;\n\t} else {\n\t\tthrow new Error(\"Invalid value to resolve.\");\n\t}\n};\n", "import { Artifact, addArtifact, getArtifact, isArtifact } from \"./artifact.ts\";\nimport { Placeholder } from \"./placeholder.ts\";\nimport { Unresolved, resolve } from \"./resolve.ts\";\nimport * as syscall from \"./syscall.ts\";\n\nexport type TemplateLike = TemplateComponent | Template | Array<TemplateLike>;\n\nexport let t = async (\n\tstrings: TemplateStringsArray,\n\t...placeholders: Array<Unresolved<TemplateLike>>\n): Promise<Template> => {\n\t// Collect the strings and placeholders.\n\tlet components: Array<Unresolved<TemplateLike>> = [];\n\tfor (let i = 0; i < strings.length - 1; i++) {\n\t\t// eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\t\tlet string = strings[i]!;\n\t\tcomponents.push(string);\n\t\t// eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\t\tlet placeholder = placeholders[i]!;\n\t\tcomponents.push(placeholder);\n\t}\n\t// eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\tcomponents.push(strings[strings.length - 1]!);\n\n\treturn await template(components);\n};\n\nexport let template = async (\n\ttemplateLike: Unresolved<TemplateLike>,\n): Promise<Template> => {\n\t// Resolve the input.\n\tlet resolvedTemplateLike = await resolve(templateLike);\n\n\t// Collect all components recursively.\n\tlet components: Array<TemplateComponent> = [];\n\tlet collectComponents = (templateLike: TemplateLike) => {\n\t\tif (templateLike instanceof Array) {\n\t\t\ttemplateLike.forEach(collectComponents);\n\t\t} else if (templateLike instanceof Template) {\n\t\t\tcomponents.push(...templateLike.components());\n\t\t} else {\n\t\t\tcomponents.push(templateLike);\n\t\t}\n\t};\n\tcollectComponents(resolvedTemplateLike);\n\n\treturn new Template(components);\n};\n\nexport let isTemplate = (value: unknown): value is Template => {\n\treturn value instanceof Template;\n};\n\nexport class Template {\n\t#components: Array<TemplateComponent>;\n\n\tconstructor(components: Array<TemplateComponent>) {\n\t\tthis.#components = components;\n\t}\n\n\tasync serialize(): Promise<syscall.Template> {\n\t\tlet components = await Promise.all(\n\t\t\tthis.#components.map(\n\t\t\t\tasync (component) => await serializeTemplateComponent(component),\n\t\t\t),\n\t\t);\n\t\treturn {\n\t\t\tcomponents,\n\t\t};\n\t}\n\n\tstatic async deserialize(template: syscall.Template): Promise<Template> {\n\t\treturn new Template(\n\t\t\tawait Promise.all(\n\t\t\t\ttemplate.components.map(\n\t\t\t\t\tasync (component) => await deserializeTemplateComponent(component),\n\t\t\t\t),\n\t\t\t),\n\t\t);\n\t}\n\n\tcomponents(): Array<TemplateComponent> {\n\t\treturn [...this.#components];\n\t}\n\n\trender(f: (component: TemplateComponent) => string): string {\n\t\treturn this.#components.map(f).join(\"\");\n\t}\n}\n\nexport type TemplateComponent = string | Artifact | Placeholder;\n\nexport let serializeTemplateComponent = async (\n\tcomponent: TemplateComponent,\n): Promise<syscall.TemplateComponent> => {\n\tif (typeof component === \"string\") {\n\t\treturn {\n\t\t\tkind: \"string\",\n\t\t\tvalue: component,\n\t\t};\n\t} else if (isArtifact(component)) {\n\t\treturn {\n\t\t\tkind: \"artifact\",\n\t\t\tvalue: await addArtifact(component),\n\t\t};\n\t} else if (component instanceof Placeholder) {\n\t\treturn {\n\t\t\tkind: \"placeholder\",\n\t\t\tvalue: await component.serialize(),\n\t\t};\n\t} else {\n\t\tthrow new Error(\"Invalid template component.\");\n\t}\n};\n\nexport let deserializeTemplateComponent = async (\n\tcomponent: syscall.TemplateComponent,\n): Promise<TemplateComponent> => {\n\tswitch (component.kind) {\n\t\tcase \"string\": {\n\t\t\treturn component.value;\n\t\t}\n\t\tcase \"artifact\": {\n\t\t\treturn await getArtifact(component.value);\n\t\t}\n\t\tcase \"placeholder\": {\n\t\t\treturn await Placeholder.deserialize(component.value);\n\t\t}\n\t}\n};\n", "import { ArtifactHash, addArtifact } from \"./artifact.ts\";\nimport { Unresolved } from \"./resolve.ts\";\nimport * as syscall from \"./syscall.ts\";\nimport { Template, TemplateLike, template } from \"./template.ts\";\n\nexport let symlink = async (\n\ttarget: Unresolved<TemplateLike>,\n): Promise<Symlink> => {\n\ttarget = await template(target);\n\treturn new Symlink(target);\n};\n\nexport let isSymlink = (value: unknown): value is Symlink => {\n\treturn value instanceof Symlink;\n};\n\nexport class Symlink {\n\t#target: Template;\n\n\tconstructor(target: Template) {\n\t\tthis.#target = target;\n\t}\n\n\tasync serialize(): Promise<syscall.Symlink> {\n\t\tlet target = await this.#target.serialize();\n\t\treturn {\n\t\t\ttarget,\n\t\t};\n\t}\n\n\tstatic async deserialize(symlink: syscall.Symlink): Promise<Symlink> {\n\t\tlet target = await Template.deserialize(symlink.target);\n\t\treturn new Symlink(target);\n\t}\n\n\tasync hash(): Promise<ArtifactHash> {\n\t\treturn await addArtifact(this);\n\t}\n\n\ttarget(): Template {\n\t\treturn this.#target;\n\t}\n}\n", "import { Artifact, addArtifact, getArtifact, isArtifact } from \"./artifact.ts\";\nimport { Directory } from \"./directory.ts\";\nimport { File } from \"./file.ts\";\nimport { Placeholder } from \"./placeholder.ts\";\nimport { Symlink } from \"./symlink.ts\";\nimport * as syscall from \"./syscall.ts\";\nimport { Template } from \"./template.ts\";\n\nexport type Value =\n\t| nullish\n\t| boolean\n\t| number\n\t| string\n\t| Artifact\n\t| Placeholder\n\t| Template\n\t| Array<Value>\n\t| { [key: string]: Value };\n\nexport type nullish = undefined | null;\n\nexport let isNullish = (value: unknown): value is nullish => {\n\treturn value === undefined || value === null;\n};\n\nexport let isValue = (value: unknown): value is Value => {\n\treturn (\n\t\tvalue === undefined ||\n\t\tvalue === null ||\n\t\ttypeof value === \"boolean\" ||\n\t\ttypeof value === \"number\" ||\n\t\ttypeof value === \"string\" ||\n\t\tvalue instanceof Directory ||\n\t\tvalue instanceof File ||\n\t\tvalue instanceof Symlink ||\n\t\tvalue instanceof Template ||\n\t\tvalue instanceof Array ||\n\t\ttypeof value === \"object\"\n\t);\n};\n\nexport let serializeValue = async <T extends Value>(\n\tvalue: T,\n): Promise<syscall.Value> => {\n\tif (value === undefined || value === null) {\n\t\treturn {\n\t\t\tkind: \"null\",\n\t\t\tvalue,\n\t\t};\n\t} else if (typeof value === \"boolean\") {\n\t\treturn {\n\t\t\tkind: \"bool\",\n\t\t\tvalue,\n\t\t};\n\t} else if (typeof value === \"number\") {\n\t\treturn {\n\t\t\tkind: \"number\",\n\t\t\tvalue,\n\t\t};\n\t} else if (typeof value === \"string\") {\n\t\treturn {\n\t\t\tkind: \"string\",\n\t\t\tvalue,\n\t\t};\n\t} else if (isArtifact(value)) {\n\t\treturn {\n\t\t\tkind: \"artifact\",\n\t\t\tvalue: await value.hash(),\n\t\t};\n\t} else if (value instanceof Placeholder) {\n\t\treturn {\n\t\t\tkind: \"placeholder\",\n\t\t\tvalue: await value.serialize(),\n\t\t};\n\t} else if (value instanceof Template) {\n\t\treturn {\n\t\t\tkind: \"template\",\n\t\t\tvalue: await value.serialize(),\n\t\t};\n\t} else if (value instanceof Array) {\n\t\tlet serializedValue = await Promise.all(\n\t\t\tvalue.map((value) => serializeValue(value)),\n\t\t);\n\t\treturn {\n\t\t\tkind: \"array\",\n\t\t\tvalue: serializedValue,\n\t\t};\n\t} else if (typeof value === \"object\") {\n\t\tlet serializedValue = Object.fromEntries(\n\t\t\tawait Promise.all(\n\t\t\t\tObject.entries(value).map(async ([key, value]) => [\n\t\t\t\t\tkey,\n\t\t\t\t\tawait serializeValue(value),\n\t\t\t\t]),\n\t\t\t),\n\t\t);\n\t\treturn {\n\t\t\tkind: \"map\",\n\t\t\tvalue: serializedValue,\n\t\t};\n\t} else {\n\t\tthrow new Error(\"Failed to serialize the value.\");\n\t}\n};\n\nexport let deserializeValue = async (value: syscall.Value): Promise<Value> => {\n\tswitch (value.kind) {\n\t\tcase \"null\": {\n\t\t\treturn value.value;\n\t\t}\n\t\tcase \"bool\": {\n\t\t\treturn value.value;\n\t\t}\n\t\tcase \"number\": {\n\t\t\treturn value.value;\n\t\t}\n\t\tcase \"string\": {\n\t\t\treturn value.value;\n\t\t}\n\t\tcase \"artifact\": {\n\t\t\treturn await getArtifact(value.value);\n\t\t}\n\t\tcase \"placeholder\": {\n\t\t\treturn await Placeholder.deserialize(value.value);\n\t\t}\n\t\tcase \"template\": {\n\t\t\treturn await Template.deserialize(value.value);\n\t\t}\n\t\tcase \"array\": {\n\t\t\treturn await Promise.all(\n\t\t\t\tvalue.value.map((value) => deserializeValue(value)),\n\t\t\t);\n\t\t}\n\t\tcase \"map\": {\n\t\t\treturn Object.fromEntries(\n\t\t\t\tawait Promise.all(\n\t\t\t\t\tObject.entries(value.value).map(async ([key, value]) => [\n\t\t\t\t\t\tkey,\n\t\t\t\t\t\tawait deserializeValue(value),\n\t\t\t\t\t]),\n\t\t\t\t),\n\t\t\t);\n\t\t}\n\t}\n};\n", "import {\n\tArtifact,\n\tArtifactHash,\n\taddArtifact,\n\tgetArtifact,\n\tisArtifact,\n} from \"./artifact.ts\";\nimport { BlobLike, isBlobLike } from \"./blob.ts\";\nimport { file } from \"./file.ts\";\nimport { PathLike, path } from \"./path.ts\";\nimport { MaybePromise } from \"./resolve.ts\";\nimport * as syscall from \"./syscall.ts\";\nimport { assert } from \"./util.ts\";\nimport { isNullish, nullish } from \"./value.ts\";\n\ntype DirectoryArg = MaybePromise<nullish | Directory | DirectoryObject>;\n\ntype DirectoryObject = {\n\t[name: string]: MaybePromise<nullish | BlobLike | Artifact | DirectoryObject>;\n};\n\nexport let directory = async (\n\t...args: Array<DirectoryArg>\n): Promise<Directory> => {\n\tlet entries: Map<string, ArtifactHash> = new Map();\n\n\t// Apply each arg.\n\tfor (let arg of args) {\n\t\targ = await arg;\n\t\tif (isNullish(arg)) {\n\t\t\t// If the arg is null, then continue.\n\t\t} else if (arg instanceof Directory) {\n\t\t\t// If the arg is a directory, then apply each entry.\n\t\t\tfor (let [name, hash] of arg) {\n\t\t\t\tentries.set(name, hash);\n\t\t\t}\n\t\t} else {\n\t\t\t// If the arg is an object, then apply each entry.\n\t\t\tfor (let [key, value] of Object.entries(arg)) {\n\t\t\t\t// Separate the first path component from the trailing path components.\n\t\t\t\tlet [firstComponent, ...trailingComponents] = path(key).components();\n\t\t\t\tif (firstComponent === undefined) {\n\t\t\t\t\tthrow new Error(\"The path must have at least one component.\");\n\t\t\t\t}\n\n\t\t\t\t// All path components must be normal.\n\t\t\t\tif (firstComponent.kind !== \"normal\") {\n\t\t\t\t\tthrow new Error(`Invalid path component.`);\n\t\t\t\t}\n\t\t\t\tlet name = firstComponent.value;\n\n\t\t\t\tif (trailingComponents.length > 0) {\n\t\t\t\t\t// If there are trailing path components, then recurse.\n\t\t\t\t\tlet trailingPath = path(trailingComponents).toString();\n\n\t\t\t\t\t// Get an existing directory.\n\t\t\t\t\tlet entryHash = entries.get(name);\n\t\t\t\t\tlet entry;\n\t\t\t\t\tif (entryHash !== undefined) {\n\t\t\t\t\t\t// Get the entry artifact.\n\t\t\t\t\t\tentry = await getArtifact(entryHash);\n\n\t\t\t\t\t\t// Ensure the entry is a directory.\n\t\t\t\t\t\tif (!(entry instanceof Directory)) {\n\t\t\t\t\t\t\tentry = undefined;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Merge the entry with the trailing path.\n\t\t\t\t\tlet child = await directory(entry, {\n\t\t\t\t\t\t[trailingPath]: value,\n\t\t\t\t\t});\n\n\t\t\t\t\tentries.set(name, await addArtifact(child));\n\t\t\t\t} else {\n\t\t\t\t\t// If there are no trailing path components, then create the artifact specified by the value.\n\t\t\t\t\tvalue = await value;\n\t\t\t\t\tif (isNullish(value)) {\n\t\t\t\t\t\tentries.delete(name);\n\t\t\t\t\t} else if (isBlobLike(value)) {\n\t\t\t\t\t\tentries.set(name, await addArtifact(await file(value)));\n\t\t\t\t\t} else if (isArtifact(value)) {\n\t\t\t\t\t\tentries.set(name, await addArtifact(value));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tentries.set(name, await addArtifact(await directory(value)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn new Directory(entries);\n};\n\nexport let isDirectory = (value: unknown): value is Directory => {\n\treturn value instanceof Directory;\n};\n\nexport class Directory {\n\t#entries: Map<string, ArtifactHash>;\n\n\tconstructor(entries: Map<string, ArtifactHash>) {\n\t\tthis.#entries = entries;\n\t}\n\n\tasync serialize(): Promise<syscall.Directory> {\n\t\tlet entries = Object.fromEntries(Array.from(this.#entries.entries()));\n\t\treturn {\n\t\t\tentries,\n\t\t};\n\t}\n\n\tstatic async deserialize(directory: syscall.Directory): Promise<Directory> {\n\t\tlet entries = new Map(Object.entries(directory.entries));\n\t\treturn new Directory(entries);\n\t}\n\n\tasync hash(): Promise<ArtifactHash> {\n\t\treturn await addArtifact(this);\n\t}\n\n\tasync get(pathLike: PathLike): Promise<Artifact> {\n\t\tlet artifact = await this.tryGet(pathLike);\n\t\tassert(\n\t\t\tartifact !== undefined,\n\t\t\t`Failed to get the directory entry \"${pathLike}\".`,\n\t\t);\n\t\treturn artifact;\n\t}\n\n\tasync tryGet(pathLike: PathLike): Promise<Artifact | undefined> {\n\t\tlet artifact: Artifact = this;\n\t\tfor (let component of path(pathLike).components()) {\n\t\t\tassert(component.kind === \"normal\");\n\t\t\tif (!(artifact instanceof Directory)) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\tlet hash = artifact.#entries.get(component.value);\n\t\t\tif (!hash) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\tartifact = await getArtifact(hash);\n\t\t}\n\t\treturn artifact;\n\t}\n\n\tasync entries(): Promise<Map<string, Artifact>> {\n\t\tlet entries = new Map();\n\t\tfor await (let [name, artifact] of this) {\n\t\t\tentries.set(name, artifact);\n\t\t}\n\t\treturn entries;\n\t}\n\n\t*[Symbol.iterator](): Iterator<[string, ArtifactHash]> {\n\t\tfor (let [name, entry] of this.#entries) {\n\t\t\tyield [name, entry];\n\t\t}\n\t}\n\n\tasync *[Symbol.asyncIterator](): AsyncIterator<[string, Artifact]> {\n\t\tfor (let name of this.#entries.keys()) {\n\t\t\tyield [name, await this.get(name)];\n\t\t}\n\t}\n}\n", "import { Directory } from \"./directory.ts\";\nimport { File } from \"./file.ts\";\nimport { Symlink } from \"./symlink.ts\";\nimport * as syscall from \"./syscall.ts\";\n\nexport type ArtifactHash = string;\n\nexport type ArtifactKind = \"directory\" | \"file\" | \"symlink\";\n\nexport type Artifact = Directory | File | Symlink;\n\nexport let isArtifact = (value: unknown): value is Artifact => {\n\treturn (\n\t\tvalue instanceof Directory ||\n\t\tvalue instanceof File ||\n\t\tvalue instanceof Symlink\n\t);\n};\n\nexport let addArtifact = async (artifact: Artifact): Promise<ArtifactHash> => {\n\treturn await syscall.addArtifact(await serializeArtifact(artifact));\n};\n\nexport let getArtifact = async (hash: ArtifactHash): Promise<Artifact> => {\n\treturn await deserializeArtifact(await syscall.getArtifact(hash));\n};\n\nexport let serializeArtifact = async (\n\tartifact: Artifact,\n): Promise<syscall.Artifact> => {\n\tif (artifact instanceof Directory) {\n\t\treturn {\n\t\t\tkind: \"directory\",\n\t\t\tvalue: await artifact.serialize(),\n\t\t};\n\t} else if (artifact instanceof File) {\n\t\treturn {\n\t\t\tkind: \"file\",\n\t\t\tvalue: await artifact.serialize(),\n\t\t};\n\t} else if (artifact instanceof Symlink) {\n\t\treturn {\n\t\t\tkind: \"symlink\",\n\t\t\tvalue: await artifact.serialize(),\n\t\t};\n\t} else {\n\t\tthrow new Error(\"Unknown artifact type\");\n\t}\n};\n\nexport let deserializeArtifact = async (\n\tartifact: syscall.Artifact,\n): Promise<Artifact> => {\n\tswitch (artifact.kind) {\n\t\tcase \"directory\": {\n\t\t\treturn await Directory.deserialize(artifact.value);\n\t\t}\n\t\tcase \"file\": {\n\t\t\treturn await File.deserialize(artifact.value);\n\t\t}\n\t\tcase \"symlink\": {\n\t\t\treturn await Symlink.deserialize(artifact.value);\n\t\t}\n\t}\n};\n", "import { getArtifact } from \"./artifact.ts\";\nimport { Directory, isDirectory } from \"./directory.ts\";\nimport { Unresolved, resolve } from \"./resolve.ts\";\nimport * as syscall from \"./syscall.ts\";\nimport { assert } from \"./util.ts\";\n\nexport let bundle = async (\n\tartifact: Unresolved<Directory>,\n): Promise<Directory> => {\n\tartifact = await resolve(artifact);\n\tlet hash = await artifact.hash();\n\tlet bundledHash = await syscall.bundle(hash);\n\tlet bundledArtifact = await getArtifact(bundledHash);\n\tassert(isDirectory(bundledArtifact));\n\treturn bundledArtifact;\n};\n", "import * as syscall from \"./syscall.ts\";\n\nexport type Checksum = `${ChecksumAlgorithm}${\":\" | \"-\"}${string}`;\n\nexport type ChecksumAlgorithm = \"blake3\" | \"sha256\";\n\nexport let checksum = (\n\talgorithm: ChecksumAlgorithm,\n\tbytes: Uint8Array | string,\n): Checksum => {\n\treturn syscall.checksum(algorithm, bytes);\n};\n", "import { Value } from \"./value.ts\";\n\nexport let context: Map<string, Value> = new Map();\n", "import { call } from \"./call.ts\";\nimport { context } from \"./context.ts\";\nimport { PackageInstanceHash } from \"./package.ts\";\nimport { MaybePromise, Unresolved, resolve } from \"./resolve.ts\";\nimport * as syscall from \"./syscall.ts\";\nimport { assert } from \"./util.ts\";\nimport { Value, deserializeValue, serializeValue } from \"./value.ts\";\n\nexport let function_ = <\n\tA extends Array<Value> = Array<Value>,\n\tR extends Value = Value,\n>(\n\tf: (...args: A) => MaybePromise<R>,\n): Function<A, R> => {\n\t// Get the function's caller.\n\tlet { packageInstanceHash, line } = syscall.caller();\n\n\t// Get the function's name.\n\tlet name;\n\tif (line.startsWith(\"export default \")) {\n\t\tname = \"default\";\n\t} else if (line.startsWith(\"export let \")) {\n\t\tlet exportName = line.match(/^export let ([a-zA-Z0-9]+)\\b/)?.at(1);\n\t\tif (!exportName) {\n\t\t\tthrow new Error(\"Invalid use of tg.function.\");\n\t\t}\n\t\tname = exportName;\n\t} else {\n\t\tthrow new Error(\"Invalid use of tg.function.\");\n\t}\n\n\treturn new Function({\n\t\tpackageInstanceHash,\n\t\tname,\n\t\tf,\n\t});\n};\n\nexport let isFunction = (value: unknown): value is Function => {\n\treturn value instanceof Function;\n};\n\ntype FunctionConstructorArgs<A extends Array<Value>, R extends Value> = {\n\tpackageInstanceHash: PackageInstanceHash;\n\tname: string;\n\tf?: (...args: A) => MaybePromise<R>;\n};\n\nexport interface Function<\n\tA extends Array<Value> = Array<Value>,\n\tR extends Value = Value,\n> {\n\t(...args: { [K in keyof A]: Unresolved<A[K]> }): Promise<R>;\n}\n\nexport class Function<\n\tA extends Array<Value> = Array<Value>,\n\tR extends Value = Value,\n> extends globalThis.Function {\n\tpackageInstanceHash: PackageInstanceHash;\n\tname: string;\n\tf?: (...args: A) => MaybePromise<R>;\n\n\tconstructor(args: FunctionConstructorArgs<A, R>) {\n\t\tsuper();\n\n\t\tthis.packageInstanceHash = args.packageInstanceHash;\n\t\tthis.name = args.name;\n\t\tthis.f = args.f;\n\n\t\t// Proxy this object so that it is callable.\n\t\treturn new Proxy(this, {\n\t\t\tapply: (target, _, args) => target._call(...(args as A)),\n\t\t});\n\t}\n\n\tasync serialize(): Promise<syscall.Function> {\n\t\tlet packageInstanceHash = this.packageInstanceHash;\n\t\tlet name = this.name?.toString();\n\t\treturn {\n\t\t\tpackageInstanceHash,\n\t\t\tname,\n\t\t};\n\t}\n\n\tstatic async deserialize<A extends Array<Value>, R extends Value>(\n\t\tfunction_: syscall.Function,\n\t): Promise<Function<A, R>> {\n\t\tlet packageInstanceHash = function_.packageInstanceHash;\n\t\tlet name = function_.name;\n\t\treturn new Function({\n\t\t\tpackageInstanceHash,\n\t\t\tname,\n\t\t});\n\t}\n\n\tasync _call(...args: A): Promise<R> {\n\t\tlet context_ = new Map(context);\n\t\tlet resolvedArgs = await Promise.all(args.map(resolve));\n\t\treturn await call({\n\t\t\tfunction: this,\n\t\t\tcontext: context_,\n\t\t\targs: resolvedArgs,\n\t\t});\n\t}\n\n\tasync run(\n\t\tserializedContext: { [key: string]: syscall.Value },\n\t\tserializedArgs: Array<syscall.Value>,\n\t): Promise<syscall.Value> {\n\t\t// Deserialize and set the context.\n\t\tfor (let [key, value] of Object.entries(serializedContext)) {\n\t\t\tcontext.set(key, await deserializeValue(value));\n\t\t}\n\n\t\t// Deserialize the args.\n\t\tlet args = (await Promise.all(serializedArgs.map(deserializeValue))) as A;\n\n\t\t// Call the function.\n\t\tassert(this.f);\n\t\tlet output = await this.f(...args);\n\n\t\t// Serialize the output.\n\t\tlet serializedOutput = await serializeValue(output);\n\n\t\treturn serializedOutput;\n\t}\n}\n", "import { Function } from \"./function.ts\";\nimport { run } from \"./operation.ts\";\nimport * as syscall from \"./syscall.ts\";\nimport { Value, deserializeValue, nullish, serializeValue } from \"./value.ts\";\n\ntype CallArgs<T extends Value> = {\n\tfunction: Function<any, T>;\n\tcontext?: Map<string, Value> | nullish;\n\targs?: Array<Value> | nullish;\n};\n\nexport let call = async <T extends Value = Value>(\n\targs: CallArgs<T>,\n): Promise<T> => {\n\tlet function_ = args.function;\n\tlet context = args.context ?? new Map();\n\tlet args_ = args.args ?? [];\n\treturn await new Call<T>({\n\t\tfunction: function_,\n\t\tcontext,\n\t\targs: args_,\n\t}).run();\n};\n\nexport let isCall = (value: unknown): value is Call => {\n\treturn value instanceof Call;\n};\n\ntype CallConstructorArgs<T extends Value> = {\n\tfunction: Function<any, T>;\n\tcontext: Map<string, Value>;\n\targs: Array<Value>;\n};\n\nexport class Call<T extends Value = Value> {\n\t#function: Function<any, T>;\n\t#context: Map<string, Value>;\n\t#args: Array<Value>;\n\n\tconstructor(args: CallConstructorArgs<T>) {\n\t\tthis.#function = args.function;\n\t\tthis.#context = args.context;\n\t\tthis.#args = args.args;\n\t}\n\n\tasync serialize(): Promise<syscall.Call> {\n\t\tlet function_ = await this.#function.serialize();\n\t\tlet context = Object.fromEntries(\n\t\t\tawait Promise.all(\n\t\t\t\tArray.from(this.#context.entries()).map(async ([key, value]) => [\n\t\t\t\t\tkey,\n\t\t\t\t\tawait serializeValue(value),\n\t\t\t\t]),\n\t\t\t),\n\t\t);\n\t\tlet args = await Promise.all(this.#args.map((arg) => serializeValue(arg)));\n\t\treturn {\n\t\t\tfunction: function_,\n\t\t\tcontext,\n\t\t\targs,\n\t\t};\n\t}\n\n\tstatic async deserialize<T extends Value>(\n\t\tcall: syscall.Call,\n\t): Promise<Call<T>> {\n\t\tlet function_ = await Function.deserialize<Array<Value>, T>(call.function);\n\t\tlet context = new Map(\n\t\t\tawait Promise.all(\n\t\t\t\tObject.entries(call.context).map(\n\t\t\t\t\tasync ([key, value]): Promise<[string, Value]> => [\n\t\t\t\t\t\tkey,\n\t\t\t\t\t\tawait deserializeValue(value),\n\t\t\t\t\t],\n\t\t\t\t),\n\t\t\t),\n\t\t);\n\t\tlet args = await Promise.all(call.args.map((arg) => deserializeValue(arg)));\n\t\treturn new Call<T>({\n\t\t\tfunction: function_,\n\t\t\tcontext,\n\t\t\targs,\n\t\t});\n\t}\n\n\tasync run(): Promise<T> {\n\t\treturn (await run(this)) as T;\n\t}\n}\n", "import { Artifact } from \"./artifact.ts\";\nimport { Checksum } from \"./checksum.ts\";\nimport { run } from \"./operation.ts\";\nimport { placeholder } from \"./placeholder.ts\";\nimport { Unresolved, resolve } from \"./resolve.ts\";\nimport * as syscall from \"./syscall.ts\";\nimport { Template, TemplateLike, template } from \"./template.ts\";\nimport { nullish } from \"./value.ts\";\n\ntype ProcessArgs = {\n\tsystem: System;\n\tcommand: TemplateLike;\n\tenv?: Record<string, TemplateLike> | nullish;\n\targs?: Array<TemplateLike> | nullish;\n\tchecksum?: Checksum | nullish;\n\tunsafe?: boolean | nullish;\n\tnetwork?: boolean | nullish;\n\thostPaths?: Array<string> | nullish;\n};\n\ntype System = \"amd64_linux\" | \"arm64_linux\" | \"amd64_macos\" | \"arm64_macos\";\n\nexport let process = async (\n\targs: Unresolved<ProcessArgs>,\n): Promise<Artifact> => {\n\tlet resolvedArgs = await resolve(args);\n\tlet system = resolvedArgs.system;\n\tlet command = await template(resolvedArgs.command);\n\tlet env = Object.fromEntries(\n\t\tawait Promise.all(\n\t\t\tObject.entries(resolvedArgs.env ?? {}).map(async ([key, value]) => [\n\t\t\t\tkey,\n\t\t\t\tawait template(value),\n\t\t\t]),\n\t\t),\n\t);\n\tlet args_ = await Promise.all(\n\t\t(resolvedArgs.args ?? []).map(async (arg) => await template(arg)),\n\t);\n\tlet checksum = resolvedArgs.checksum ?? null;\n\tlet unsafe = resolvedArgs.unsafe ?? false;\n\tlet network = resolvedArgs.network ?? false;\n\tlet hostPaths = resolvedArgs.hostPaths ?? [];\n\treturn await new Process({\n\t\tsystem,\n\t\tenv,\n\t\tcommand,\n\t\targs: args_,\n\t\tchecksum,\n\t\tunsafe,\n\t\tnetwork,\n\t\thostPaths,\n\t}).run();\n};\n\nexport let output = placeholder(\"output\");\n\nexport type ProcessConstructorArgs = {\n\tsystem: System;\n\tcommand: Template;\n\tenv: Record<string, Template>;\n\targs: Array<Template>;\n\tchecksum: Checksum | nullish;\n\tunsafe: boolean;\n\tnetwork: boolean;\n\thostPaths: Array<string>;\n};\n\nexport class Process {\n\t#system: System;\n\t#command: Template;\n\t#env: Record<string, Template>;\n\t#args: Array<Template>;\n\t#checksum: Checksum | nullish;\n\t#unsafe: boolean;\n\t#network: boolean;\n\t#hostPaths: Array<string>;\n\n\tconstructor(args: ProcessConstructorArgs) {\n\t\tthis.#system = args.system;\n\t\tthis.#command = args.command;\n\t\tthis.#env = args.env;\n\t\tthis.#args = args.args;\n\t\tthis.#checksum = args.checksum;\n\t\tthis.#unsafe = args.unsafe;\n\t\tthis.#network = args.network;\n\t\tthis.#hostPaths = args.hostPaths;\n\t}\n\n\tasync serialize(): Promise<syscall.Process> {\n\t\tlet system = this.#system;\n\t\tlet command = await this.#command.serialize();\n\t\tlet env = Object.fromEntries(\n\t\t\tawait Promise.all(\n\t\t\t\tObject.entries(this.#env).map(async ([key, value]) => [\n\t\t\t\t\tkey,\n\t\t\t\t\tawait value.serialize(),\n\t\t\t\t]),\n\t\t\t),\n\t\t);\n\t\tlet args = await Promise.all(this.#args.map((arg) => arg.serialize()));\n\t\tlet checksum = this.#checksum;\n\t\tlet unsafe = this.#unsafe;\n\t\tlet network = this.#network;\n\t\tlet hostPaths = this.#hostPaths;\n\t\treturn {\n\t\t\tsystem,\n\t\t\tcommand,\n\t\t\tenv,\n\t\t\targs,\n\t\t\tchecksum,\n\t\t\tunsafe,\n\t\t\tnetwork,\n\t\t\thostPaths,\n\t\t};\n\t}\n\n\tstatic async deserialize(process: syscall.Process): Promise<Process> {\n\t\tlet system = process.system;\n\t\tlet command = await Template.deserialize(process.command);\n\t\tlet env = Object.fromEntries(\n\t\t\tawait Promise.all(\n\t\t\t\tObject.entries(process.env).map(async ([key, value]) => [\n\t\t\t\t\tkey,\n\t\t\t\t\tawait Template.deserialize(value),\n\t\t\t\t]),\n\t\t\t),\n\t\t);\n\t\tlet args = await Promise.all(\n\t\t\tprocess.args.map((arg) => Template.deserialize(arg)),\n\t\t);\n\t\tlet checksum = process.checksum;\n\t\tlet unsafe = process.unsafe;\n\t\tlet network = process.network;\n\t\tlet hostPaths = process.hostPaths;\n\t\treturn new Process({\n\t\t\tsystem,\n\t\t\tcommand,\n\t\t\tenv,\n\t\t\targs,\n\t\t\tchecksum,\n\t\t\tunsafe,\n\t\t\tnetwork,\n\t\t\thostPaths,\n\t\t});\n\t}\n\n\tasync run(): Promise<Artifact> {\n\t\treturn await run(this);\n\t}\n}\n", "import { Artifact } from \"./artifact.ts\";\nimport { Call } from \"./call.ts\";\nimport { Download } from \"./download.ts\";\nimport { Process } from \"./process.ts\";\nimport * as syscall from \"./syscall.ts\";\nimport { deserializeValue } from \"./value.ts\";\n\nexport type OperationHash = string;\n\nexport type OperationKind = \"download\" | \"process\" | \"call\";\n\nexport type Operation = Download | Process | Call;\n\nexport type Output<T extends Operation> = T extends Download\n\t? Artifact\n\t: T extends Process\n\t? Artifact\n\t: T extends Call<infer U>\n\t? U\n\t: never;\n\nexport let isOperation = (value: unknown): value is Operation => {\n\treturn (\n\t\tvalue instanceof Download ||\n\t\tvalue instanceof Process ||\n\t\tvalue instanceof Call\n\t);\n};\n\nexport let run = async <T extends Operation>(\n\toperation: T,\n): Promise<Output<T>> => {\n\tlet operationHash = await addOperation(operation);\n\tlet outputSerialized = await syscall.runOperation(operationHash);\n\tlet output = await deserializeValue(outputSerialized);\n\treturn output as Output<T>;\n};\n\nexport let addOperation = async (\n\toperation: Operation,\n): Promise<OperationHash> => {\n\treturn await syscall.addOperation(await serializeOperation(operation));\n};\n\nexport let getArtifact = async (hash: OperationHash): Promise<Operation> => {\n\treturn await deserializeOperation(await syscall.getOperation(hash));\n};\n\nexport let serializeOperation = async (\n\toperation: Operation,\n): Promise<syscall.Operation> => {\n\tif (operation instanceof Download) {\n\t\treturn {\n\t\t\tkind: \"download\",\n\t\t\tvalue: await operation.serialize(),\n\t\t};\n\t} else if (operation instanceof Process) {\n\t\treturn {\n\t\t\tkind: \"process\",\n\t\t\tvalue: await operation.serialize(),\n\t\t};\n\t} else if (operation instanceof Call) {\n\t\treturn {\n\t\t\tkind: \"call\",\n\t\t\tvalue: await operation.serialize(),\n\t\t};\n\t} else {\n\t\tthrow new Error(\"Cannot serialize operation.\");\n\t}\n};\n\nexport let deserializeOperation = async (\n\toperation: syscall.Operation,\n): Promise<Operation> => {\n\tswitch (operation.kind) {\n\t\tcase \"download\": {\n\t\t\treturn await Download.deserialize(operation.value);\n\t\t}\n\t\tcase \"process\": {\n\t\t\treturn await Process.deserialize(operation.value);\n\t\t}\n\t\tcase \"call\": {\n\t\t\treturn await Call.deserialize(operation.value);\n\t\t}\n\t}\n};\n", "import { Artifact } from \"./artifact.ts\";\nimport { Checksum } from \"./checksum.ts\";\nimport { run } from \"./operation.ts\";\nimport * as syscall from \"./syscall.ts\";\nimport { nullish } from \"./value.ts\";\n\nexport type DownloadArgs = {\n\turl: string;\n\tunpack?: boolean | nullish;\n\tchecksum?: Checksum | nullish;\n\tunsafe?: boolean | nullish;\n};\n\nexport let download = async (args: DownloadArgs): Promise<Artifact> => {\n\treturn await new Download(args).run();\n};\n\nexport let isDownload = (value: unknown): value is Download => {\n\treturn value instanceof Download;\n};\n\nexport class Download {\n\t#url: string;\n\t#unpack: boolean;\n\t#checksum: Checksum | nullish;\n\t#unsafe: boolean;\n\n\tconstructor(args: DownloadArgs) {\n\t\tthis.#url = args.url;\n\t\tthis.#unpack = args.unpack ?? false;\n\t\tthis.#checksum = args.checksum ?? null;\n\t\tthis.#unsafe = args.unsafe ?? false;\n\t}\n\n\tasync serialize(): Promise<syscall.Download> {\n\t\treturn {\n\t\t\turl: this.#url,\n\t\t\tunpack: this.#unpack,\n\t\t\tchecksum: this.#checksum,\n\t\t\tunsafe: this.#unsafe,\n\t\t};\n\t}\n\n\tstatic async deserialize(download: syscall.Download): Promise<Download> {\n\t\treturn new Download({\n\t\t\turl: download.url,\n\t\t\tunpack: download.unpack,\n\t\t\tchecksum: download.checksum,\n\t\t\tunsafe: download.unsafe,\n\t\t});\n\t}\n\n\tasync run(): Promise<Artifact> {\n\t\treturn await run(this);\n\t}\n}\n", "export function prepareStackTrace(\n\t_error: unknown,\n\tstructuredStackTrace: Array<CallSite>,\n) {\n\tlet callSites = structuredStackTrace.map((callSite) => {\n\t\treturn {\n\t\t\ttypeName: callSite.getTypeName(),\n\t\t\tfunctionName: callSite.getFunctionName(),\n\t\t\tmethodName: callSite.getMethodName(),\n\t\t\tfileName: callSite.getFileName(),\n\t\t\tlineNumber: callSite.getLineNumber(),\n\t\t\tcolumnNumber: callSite.getColumnNumber(),\n\t\t\tisEval: callSite.isEval(),\n\t\t\tisNative: callSite.isNative(),\n\t\t\tisConstructor: callSite.isConstructor(),\n\t\t\tisAsync: callSite.isAsync(),\n\t\t\tisPromiseAll: callSite.isPromiseAll(),\n\t\t\t// isPromiseAny: callSite.isPromiseAny(),\n\t\t\tpromiseIndex: callSite.getPromiseIndex(),\n\t\t};\n\t});\n\treturn { callSites };\n}\n\n/** This type is derived from <https://v8.dev/docs/stack-trace-api#customizing-stack-traces>. */\ntype CallSite = {\n\t/** Returns the type of this as a string. This is the name of the function stored in the constructor field of this, if available, otherwise the object\u2019s [[Class]] internal property. **/\n\tgetTypeName(): string;\n\n\t/** Returns the name of the current function, typically its name property. If a name property is not available an attempt is made to infer a name from the function\u2019s context. **/\n\tgetFunctionName(): string;\n\n\t/** Returns the name of the property of this or one of its prototypes that holds the current function. **/\n\tgetMethodName(): string;\n\n\t/** If this function was defined in a script returns the name of the script. **/\n\tgetFileName(): string | undefined;\n\n\t/** If this function was defined in a script returns the current line number. **/\n\tgetLineNumber(): number | undefined;\n\n\t/** If this function was defined in a script returns the current column number. **/\n\tgetColumnNumber(): number | undefined;\n\n\t/** If this function was created using a call to eval returns a string representing the location where eval was called. **/\n\tgetEvalOrigin(): any | undefined;\n\n\t/** does this call take place in code defined by a call to eval? **/\n\tisEval(): boolean;\n\n\t/** is this call in native V8 code? **/\n\tisNative(): boolean;\n\n\t/** is this a constructor call? **/\n\tisConstructor(): boolean;\n\n\t/** Is this an async call (i.e. await, Promise.all(), or Promise.any())? **/\n\tisAsync(): boolean;\n\n\t/** Is this an async call to Promise.all()? **/\n\tisPromiseAll(): boolean;\n\n\t// /** Is this an async call to Promise.any()? **/\n\t// isPromiseAny(): boolean;\n\n\t/** Returns the index of the promise element that was followed in Promise.all() or Promise.any() for async stack traces, or null if the CallSite is not an async Promise.all() or Promise.any() call. **/\n\tgetPromiseIndex(): number | null;\n};\n", "import { Artifact, deserializeArtifact, getArtifact } from \"./artifact.ts\";\nimport * as syscall from \"./syscall.ts\";\n\nexport let include = async (path: string): Promise<Artifact> => {\n\tlet caller = syscall.caller();\n\treturn await deserializeArtifact(await syscall.include(caller, path));\n};\n", "import * as syscall from \"./syscall.ts\";\n\n/** Write to the log. */\nexport let log = (...args: Array<unknown>) => {\n\tlet string = args.map((arg) => stringify(arg)).join(\" \");\n\tsyscall.log(string);\n};\n\nlet stringify = (value: unknown): string => {\n\treturn stringifyInner(value, new Set());\n};\n\nlet stringifyInner = (value: unknown, visited: Set<unknown>): string => {\n\tswitch (typeof value) {\n\t\tcase \"string\": {\n\t\t\treturn `\"${value}\"`;\n\t\t}\n\t\tcase \"number\": {\n\t\t\treturn value.toString();\n\t\t}\n\t\tcase \"boolean\": {\n\t\t\treturn value ? \"true\" : \"false\";\n\t\t}\n\t\tcase \"undefined\": {\n\t\t\treturn \"undefined\";\n\t\t}\n\t\tcase \"object\": {\n\t\t\treturn stringifyObject(value, visited);\n\t\t}\n\t\tcase \"function\": {\n\t\t\treturn `[function ${value.name ?? \"(anonymous)\"}]`;\n\t\t}\n\t\tcase \"symbol\": {\n\t\t\treturn \"[symbol]\";\n\t\t}\n\t\tcase \"bigint\": {\n\t\t\treturn value.toString();\n\t\t}\n\t}\n};\n\nlet stringifyObject = (value: object | null, visited: Set<unknown>): string => {\n\t// Handle null.\n\tif (value === null) {\n\t\treturn \"null\";\n\t}\n\n\t// If the value is in the visited set, then indicate that this is a circular reference.\n\tif (visited.has(value)) {\n\t\treturn \"[circular]\";\n\t}\n\n\t// Add the value to the visited set.\n\tvisited.add(value);\n\n\tif (value instanceof Array) {\n\t\t// Handle an array.\n\t\treturn `[${value\n\t\t\t.map((value) => stringifyInner(value, visited))\n\t\t\t.join(\", \")}]`;\n\t} else if (value instanceof Error) {\n\t\t// Handle an error.\n\t\treturn value.stack ?? \"\";\n\t} else if (value instanceof Promise) {\n\t\t// Handle a promise.\n\t\treturn \"[promise]\";\n\t} else {\n\t\t// Handle any other object.\n\t\tlet constructorName = \"\";\n\t\tif (\n\t\t\tvalue.constructor !== undefined &&\n\t\t\tvalue.constructor.name !== \"Object\"\n\t\t) {\n\t\t\tconstructorName = `${value.constructor.name} `;\n\t\t}\n\t\tlet entries = Object.entries(value).map(\n\t\t\t([key, value]) => `${key}: ${stringifyInner(value, visited)}`,\n\t\t);\n\t\treturn `${constructorName}{ ${entries.join(\", \")} }`;\n\t}\n};\n", "export type MapLike<K extends string, V> = Record<K, V> | Map<K, V>;\n\nexport let map = <K extends string, V>(value: MapLike<K, V>): Map<K, V> => {\n\tif (value instanceof Map) {\n\t\treturn value;\n\t} else {\n\t\treturn new Map(Object.entries(value) as Array<[K, V]>);\n\t}\n};\n", "import { array } from \"./array.ts\";\nimport { isArtifact, getArtifact } from \"./artifact.ts\";\nimport { Blob, blob, isBlobLike } from \"./blob.ts\";\nimport { bundle } from \"./bundle.ts\";\nimport { checksum } from \"./checksum.ts\";\nimport { context } from \"./context.ts\";\nimport { Directory, directory, isDirectory } from \"./directory.ts\";\nimport { download } from \"./download.ts\";\nimport { prepareStackTrace } from \"./error.ts\";\nimport { File, file, isFile } from \"./file.ts\";\nimport { function_ } from \"./function.ts\";\nimport { include } from \"./include.ts\";\nimport { log } from \"./log.ts\";\nimport { map } from \"./map.ts\";\nimport { Path, isPath, path } from \"./path.ts\";\nimport { Placeholder, isPlaceholder, placeholder } from \"./placeholder.ts\";\nimport { output, process } from \"./process.ts\";\nimport { resolve } from \"./resolve.ts\";\nimport { Symlink, isSymlink, symlink } from \"./symlink.ts\";\nimport { Template, isTemplate, t, template } from \"./template.ts\";\n\n// Set `Error.prepareStackTrace`.\nObject.defineProperties(Error, {\n\tprepareStackTrace: { value: prepareStackTrace },\n});\n\n// Create the console global.\nlet console = {\n\tlog,\n};\nObject.defineProperties(globalThis, {\n\tconsole: { value: console },\n});\n\n// Create the tg global.\nlet tg = {\n\tBlob,\n\tDirectory,\n\tFile,\n\tPath,\n\tPlaceholder,\n\tSymlink,\n\tTemplate,\n\tarray,\n\tblob,\n\tbundle,\n\tchecksum,\n\tcontext,\n\tdirectory,\n\tdownload,\n\tfile,\n\tfunction: function_,\n\tgetArtifact,\n\tinclude,\n\tisArtifact,\n\tisBlobLike,\n\tisDirectory,\n\tisFile,\n\tisPath,\n\tisPlaceholder,\n\tisSymlink,\n\tisTemplate,\n\tlog,\n\tmap,\n\toutput,\n\tpath,\n\tplaceholder,\n\tprocess,\n\tresolve,\n\tsymlink,\n\ttemplate,\n};\nObject.defineProperties(globalThis, {\n\tt: { value: t },\n\ttg: { value: tg },\n});\n"],
  "mappings": "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",
  "names": ["array", "value", "log", "value", "cause", "caller", "include", "path", "checksum", "algorithm", "bytes", "encodeUtf8", "string", "decodeUtf8", "addBlob", "blob", "getBlob", "hash", "addArtifact", "artifact", "getArtifact", "addOperation", "operation", "cause", "runOperation", "hash", "cause", "bundle", "isBlobLike", "value", "Blob", "blob", "blobLike", "addBlob", "bytes", "encodeUtf8", "#hash", "hash", "getBlob", "decodeUtf8", "file", "arg", "isBlobLike", "File", "blob", "isFile", "blobHash", "executable", "references", "reference", "value", "#blobHash", "#executable", "#references", "args", "addArtifact", "Blob", "getArtifact", "path", "Path", "isPath", "value", "#components", "pathLike", "components", "component", "lastComponent", "result", "other", "assert", "condition", "message", "placeholder", "name", "Placeholder", "isPlaceholder", "value", "#name", "resolve", "value", "Directory", "File", "Symlink", "Placeholder", "Template", "key", "t", "strings", "placeholders", "components", "i", "string", "placeholder", "template", "templateLike", "resolvedTemplateLike", "resolve", "collectComponents", "Template", "isTemplate", "value", "#components", "component", "serializeTemplateComponent", "deserializeTemplateComponent", "f", "isArtifact", "addArtifact", "Placeholder", "getArtifact", "symlink", "target", "template", "Symlink", "isSymlink", "value", "#target", "Template", "addArtifact", "isNullish", "value", "serializeValue", "value", "isArtifact", "Placeholder", "Template", "key", "deserializeValue", "getArtifact", "directory", "args", "entries", "arg", "isNullish", "Directory", "name", "hash", "key", "value", "firstComponent", "trailingComponents", "path", "trailingPath", "entryHash", "entry", "getArtifact", "child", "addArtifact", "isBlobLike", "file", "isArtifact", "isDirectory", "#entries", "pathLike", "artifact", "assert", "component", "isArtifact", "value", "Directory", "File", "Symlink", "addArtifact", "artifact", "serializeArtifact", "getArtifact", "hash", "deserializeArtifact", "bundle", "artifact", "resolve", "hash", "bundledHash", "bundledArtifact", "getArtifact", "assert", "isDirectory", "checksum", "algorithm", "bytes", "context", "function_", "f", "packageInstanceHash", "line", "caller", "name", "exportName", "Function", "Function", "args", "target", "_", "packageInstanceHash", "name", "function_", "context_", "context", "resolvedArgs", "resolve", "call", "serializedContext", "serializedArgs", "key", "value", "deserializeValue", "assert", "output", "serializeValue", "call", "args", "function_", "context", "args_", "Call", "Call", "#function", "#context", "#args", "args", "function_", "context", "key", "value", "serializeValue", "arg", "call", "Function", "deserializeValue", "run", "process", "args", "resolvedArgs", "resolve", "system", "command", "template", "env", "key", "value", "args_", "arg", "checksum", "unsafe", "network", "hostPaths", "Process", "output", "placeholder", "#system", "#command", "#env", "#args", "#checksum", "#unsafe", "#network", "#hostPaths", "Template", "run", "run", "operation", "operationHash", "addOperation", "outputSerialized", "runOperation", "deserializeValue", "serializeOperation", "serializeOperation", "operation", "Download", "Process", "Call", "download", "args", "Download", "Download", "#url", "#unpack", "#checksum", "#unsafe", "args", "download", "run", "prepareStackTrace", "_error", "structuredStackTrace", "callSite", "include", "path", "caller", "deserializeArtifact", "log", "args", "string", "arg", "stringify", "value", "stringifyInner", "visited", "stringifyObject", "constructorName", "entries", "key", "map", "value", "prepareStackTrace", "console", "log", "tg", "Blob", "Directory", "File", "Path", "Placeholder", "Symlink", "Template", "array", "blob", "bundle", "checksum", "context", "directory", "download", "file", "function_", "getArtifact", "include", "isArtifact", "isBlobLike", "isDirectory", "isFile", "isPath", "isPlaceholder", "isSymlink", "isTemplate", "map", "output", "path", "placeholder", "process", "resolve", "symlink", "template", "t"]
}
