export let test = tg.target(async () => {
	await testDirectory();
	await testFile();
	await testSymlink();
});

let testDirectory = async () => {
	await testDirectoryGet();
	await testDirectoryNew();
};

let testDirectoryGet = async () => {
	let directory = await tg.directory({
		["foo/bar/baz"]: "hello",
		["foo/qux"]: tg.symlink("bar/baz"),
	});
	tg.Directory.assert(await directory.get(""));
	tg.Directory.assert(await directory.get("foo"));
	tg.Directory.assert(await directory.get("foo/bar"));
	tg.File.assert(await directory.get("foo/qux"));
};

let testDirectoryNew = async () => {
	let foo = tg.directory({
		foo: "foo",
		fooSymlink: tg.symlink("foo"),
	});
	let bar = tg.directory({
		bar: "bar",
		barSymlink: tg.symlink("bar"),
	});
	let foobar = await tg.directory(foo, bar);
	tg.File.assert(await foobar.get("foo"));
	tg.File.assert(await foobar.get("fooSymlink"));
	tg.File.assert(await foobar.get("bar"));
	tg.File.assert(await foobar.get("barSymlink"));
};

let testFile = async () => {
	let file = await tg.file("hello");
	let text = await file.text();
	tg.assert(text === "hello");
};

let testSymlink = async () => {
	await testSymlinkToFile();
	await testSymlinkInDirectory();
	await testSymlinkWithPathInDirectory();
	await testSymlinkThroughSymlink();
	await testRelativePathSymlink();
	await testDeepRelativePathSymlink();
	await testDependencyIndirection();
	await testMultipleLevelsOfIndirection();
};

let testSymlinkToFile = async () => {
	let hello = await tg.file("hello");
	let symlink = await tg.symlink(hello);
	let resolved = await symlink.resolve();
	tg.File.assert(resolved);
	let text = await resolved.text();
	tg.assert(text === "hello");
};

let testSymlinkInDirectory = async () => {
	let hello = await tg.file("hello");
	let directory = await tg.directory({
		symlink: tg.symlink(hello),
	});
	let resolved = await directory.get("symlink");
	tg.File.assert(resolved);
	let text = await resolved.text();
	tg.assert(text === "hello");
};

let testSymlinkWithPathInDirectory = async () => {
	let directory = await tg.directory({
		hello: "hello",
	});
	let symlink = await tg.symlink(t`${directory}/hello`);
	let resolved = await symlink.resolve();
	tg.File.assert(resolved);
	let text = await resolved.text();
	tg.assert(text === "hello");
};

let testSymlinkThroughSymlink = async () => {
	let foo = await tg.directory({
		"subdirectory/hello": "hello",
	});
	let bar = await tg.directory({
		"subdirectory/world": tg.symlink(t`${foo}`),
	});
	let symlink = await tg.symlink(
		t`${bar}/subdirectory/world/subdirectory/hello`,
	);
	let resolved = await symlink.resolve();
	tg.File.assert(resolved);
	let text = await resolved.text();
	tg.assert(text === "hello");
};

let testRelativePathSymlink = async () => {
	let directory = await tg.directory({
		hello: "hello",
		symlink: tg.symlink("hello"),
	});
	let resolved = await directory.get("symlink");
	tg.File.assert(resolved);
	let text = await resolved.text();
	tg.assert(text === "hello");
};

let testDeepRelativePathSymlink = async () => {
	let directory = await tg.directory({
		hello: "hello",
		foo: {
			bar: {
				baz: {
					symlink: tg.symlink("../../../hello"),
				},
			},
		},
	});
	let resolved = await directory.get("foo/bar/baz/symlink");
	tg.File.assert(resolved);
	let text = await resolved.text();
	tg.assert(text === "hello");
};

let testMultipleLevelsOfIndirection = async () => {
	let foo = await tg.directory({
		link: tg.symlink("subdirectory"),
		"subdirectory/hello": "hello",
	});
	let bar = await tg.directory({
		baz: tg.symlink(foo),
	});
	let resolved = await bar.get("baz/link/hello");
	tg.File.assert(resolved);
	let text = await resolved.text();
	tg.assert(text === "hello");
};

export let testDependencyIndirection = async () => {
	let dependency = tg.directory({
		["bin/hello"]: tg.file("hello"),
	});
	let project = tg.directory({
		["dependencies/dependency"]: tg.symlink(dependency),
	});
	let symlink = await tg.symlink(
		t`${project}/dependencies/dependency/bin/hello`,
	);
	let resolved = await symlink.resolve();
	tg.File.assert(resolved);
	let text = await resolved.text();
	tg.assert(text === "hello");
};

// export let example = await tg.target(async () => {
// 	let utils = tg.download({
// 		url: "https://github.com/tangramdotdev/bootstrap/releases/download/v2023.07.06/utils_arm64_linux.tar.zstd",
// 		checksum: "sha256:36c0dcfb02e61a07f4654e1ca6047cdefb17ce1f2e37fcb2ba5dc20695b3e273",
// 		unpack: ".tar.zstd",
// 	});
// 	let file = tg.file("hello");
// 	return tg.run({
// 		host: "arm64_linux",
// 		executable: "/bin/sh",
// 		args: ["-c", t`cat ${file} > ${tg.output}`],
// 		env: {
// 			PATH: t`${utils}/bin`
// 		}
// 	});
// });

// export let example = await tg.target(async () => {
// 	let host = tg.env.get()["host"] as tg.System;
// 	let dash = tg.download({
// 		url: "https://github.com/tangramdotdev/bootstrap/releases/download/v2023.07.06/dash_universal_macos.tar.zstd",
// 		checksum:
// 			"sha256:579d924e4da700f590aa39202305016fe70402c1499f66c211f4b9a2ab614cd5",
// 		unpack: ".tar.zstd",
// 	});
// 	let utils = tg.download({
// 		url: "https://github.com/tangramdotdev/bootstrap/releases/download/v2023.07.06/utils_universal_macos.tar.zstd",
// 		checksum:
// 			"sha256:eb94f2451dfaa5f423d271dde1ac47f475ab5343b4feeb194a7386f0a4d8e227",
// 		unpack: ".tar.zstd",
// 	});
// 	let file = tg.file("hello");
// 	return tg.run({
// 		host,
// 		executable: t`/bin/sh`,
// 		args: ["-c", t`cat ${file} > ${tg.output}`],
// 		env: {
// 			PATH: t`${utils}/bin`
// 		}
// 	});
// 	return dash;
// });
